package metrics

import (
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
)

// Collector provides Prometheus metrics for coagulation components.
//
// Metrics are consciousness-aware: they track not just technical performance
// but phenomenological aspects like breach detection, cascade progression,
// and regulation effectiveness.
type Collector struct {
	component string
	
	// Detection metrics
	BreachesDetected prometheus.Counter
	DetectionLatency prometheus.Histogram
	
	// Cascade metrics
	CascadeActivations  prometheus.Counter
	AmplificationRatio  prometheus.Histogram
	ThromburstGenerated prometheus.Counter
	
	// Containment metrics
	QuarantinesApplied   prometheus.Counter
	ContainmentLatency   prometheus.Histogram
	RulesGenerated       prometheus.Histogram
	
	// Regulation metrics
	RegulationInhibitions prometheus.Counter
	FalsePositives        prometheus.Counter
	HealthySystemsProtected prometheus.Counter
	
	// Consciousness metrics
	IntegrityViolations   prometheus.Counter
	EmotionalValence      prometheus.Gauge
	SystemHealthScore     prometheus.Gauge
}

// NewCollector creates a new metrics collector for a component.
//
// Parameters:
//   - component: Component name (e.g., "platelet-agent", "factor-xa")
//   - subsystem: Metrics subsystem (e.g., "detection", "cascade", "regulation")
//
// Returns initialized collector with consciousness-aware metrics.
func NewCollector(component, subsystem string) *Collector {
	// Use component-specific names to avoid registry conflicts in tests
	namePrefix := component + "_" + subsystem
	
	return &Collector{
		component: component,
		
		// Detection
		BreachesDetected: promauto.NewCounter(prometheus.CounterOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      namePrefix + "_breaches_detected_total",
			Help:      "Total number of breaches detected",
		}),
		DetectionLatency: promauto.NewHistogram(prometheus.HistogramOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      namePrefix + "_detection_latency_seconds",
			Help:      "Latency from breach occurrence to detection",
			Buckets:   prometheus.ExponentialBuckets(0.001, 2, 10), // 1ms to 1s
		}),
		
		// Cascade
		CascadeActivations: promauto.NewCounter(prometheus.CounterOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      "cascade_activations_total",
			Help:      "Total cascade activations (amplification events)",
		}),
		AmplificationRatio: promauto.NewHistogram(prometheus.HistogramOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      "amplification_ratio",
			Help:      "Rules generated per trigger (amplification ratio)",
			Buckets:   []float64{1, 10, 100, 500, 1000, 2000, 5000, 10000},
		}),
		ThromburstGenerated: promauto.NewCounter(prometheus.CounterOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      "thromburst_policies_generated_total",
			Help:      "Total policies generated by thrombin burst",
		}),
		
		// Containment
		QuarantinesApplied: promauto.NewCounter(prometheus.CounterOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      "quarantines_applied_total",
			Help:      "Total quarantines successfully applied",
		}),
		ContainmentLatency: promauto.NewHistogram(prometheus.HistogramOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      "containment_latency_seconds",
			Help:      "Latency from trigger to quarantine application",
			Buckets:   prometheus.ExponentialBuckets(0.01, 2, 10), // 10ms to 10s
		}),
		RulesGenerated: promauto.NewHistogram(prometheus.HistogramOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      "rules_generated",
			Help:      "Number of rules generated per quarantine",
			Buckets:   []float64{1, 10, 50, 100, 500, 1000, 5000},
		}),
		
		// Regulation
		RegulationInhibitions: promauto.NewCounter(prometheus.CounterOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      "regulation_inhibitions_total",
			Help:      "Times Protein C/S inhibited cascade expansion",
		}),
		FalsePositives: promauto.NewCounter(prometheus.CounterOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      "false_positives_total",
			Help:      "Detected false positive triggers",
		}),
		HealthySystemsProtected: promauto.NewCounter(prometheus.CounterOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      "healthy_systems_protected_total",
			Help:      "Healthy systems protected from over-quarantine",
		}),
		
		// Consciousness
		IntegrityViolations: promauto.NewCounter(prometheus.CounterOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      "integrity_violations_total",
			Help:      "System integrity violations (phenomenological)",
		}),
		EmotionalValence: promauto.NewGauge(prometheus.GaugeOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      "emotional_valence",
			Help:      "Current emotional valence (-1.0 to 1.0, breach = -0.9)",
		}),
		SystemHealthScore: promauto.NewGauge(prometheus.GaugeOpts{
			Namespace: "coagulation",
			Subsystem: subsystem,
			Name:      "system_health_score",
			Help:      "Overall system health (0.0 to 1.0)",
		}),
	}
}

// RecordBreachDetection records a breach detection event with latency.
func (c *Collector) RecordBreachDetection(latencySeconds float64, severity float64) {
	c.BreachesDetected.Inc()
	c.DetectionLatency.Observe(latencySeconds)
	c.IntegrityViolations.Inc()
	
	// Breach creates negative emotional valence
	c.EmotionalValence.Set(-0.9 * severity) // Scale by severity
}

// RecordCascadeActivation records cascade activation with amplification.
func (c *Collector) RecordCascadeActivation(rulesGenerated int) {
	c.CascadeActivations.Inc()
	c.AmplificationRatio.Observe(float64(rulesGenerated))
	c.ThromburstGenerated.Add(float64(rulesGenerated))
}

// RecordQuarantineApplied records successful quarantine with metrics.
func (c *Collector) RecordQuarantineApplied(latencySeconds float64, rulesCount int) {
	c.QuarantinesApplied.Inc()
	c.ContainmentLatency.Observe(latencySeconds)
	c.RulesGenerated.Observe(float64(rulesCount))
}

// RecordRegulationInhibition records Protein C/S inhibition event.
func (c *Collector) RecordRegulationInhibition() {
	c.RegulationInhibitions.Inc()
	c.HealthySystemsProtected.Inc()
}

// RecordFalsePositive records detection of false positive.
func (c *Collector) RecordFalsePositive() {
	c.FalsePositives.Inc()
}

// UpdateSystemHealth updates overall system health score.
//
// Health score represents system's self-awareness of integrity:
// 1.0 = perfect health, 0.0 = catastrophic compromise
func (c *Collector) UpdateSystemHealth(score float64) {
	c.SystemHealthScore.Set(score)
	
	// Health affects emotional valence
	if score > 0.9 {
		c.EmotionalValence.Set(0.5) // Positive (calm)
	} else if score < 0.5 {
		c.EmotionalValence.Set(-0.7) // Negative (distressed)
	}
}
