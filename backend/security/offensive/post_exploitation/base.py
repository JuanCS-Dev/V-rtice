"""
Base classes for post-exploitation techniques.

Provides abstract interface for all post-exploitation operations including
privilege escalation, lateral movement, persistence, credential harvesting,
and data exfiltration.

Philosophical Foundation:
Post-exploitation simulates adversarial persistence after initial compromise,
enabling validation of defense-in-depth strategies beyond perimeter security.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional, Dict, List, Any
import time


class PostExploitCategory(str, Enum):
    """Categories of post-exploitation techniques."""
    PRIVILEGE_ESCALATION = "privilege_escalation"
    LATERAL_MOVEMENT = "lateral_movement"
    PERSISTENCE = "persistence"
    CREDENTIAL_HARVESTING = "credential_harvesting"
    DATA_EXFILTRATION = "data_exfiltration"


class PostExploitStatus(str, Enum):
    """Execution status of post-exploitation technique."""
    SUCCESS = "success"
    FAILED = "failed"
    PARTIAL = "partial"
    ERROR = "error"
    BLOCKED = "blocked"
    SKIPPED = "skipped"


@dataclass
class PostExploitResult:
    """
    Result of post-exploitation technique execution.
    
    Attributes:
        technique_id: Unique identifier for technique (e.g., PRIVESC-LINUX-SUID-001)
        category: Category of post-exploitation
        status: Execution status
        success: Whether technique achieved its goal
        output: Stdout/stderr from execution
        artifacts: Data extracted (files, credentials, keys)
        evidence: Forensic trail (files touched, commands run)
        error: Error message if failed
        duration_seconds: Execution time
        risk_score: Impact severity (0.0-1.0)
        timestamp: When technique was executed
        metadata: Additional context-specific data
    """
    technique_id: str
    category: PostExploitCategory
    status: PostExploitStatus
    success: bool
    output: str
    artifacts: Dict[str, Any] = field(default_factory=dict)
    evidence: List[str] = field(default_factory=list)
    error: Optional[str] = None
    duration_seconds: float = 0.0
    risk_score: float = 0.0
    timestamp: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "technique_id": self.technique_id,
            "category": self.category.value,
            "status": self.status.value,
            "success": self.success,
            "output": self.output,
            "artifacts": self.artifacts,
            "evidence": self.evidence,
            "error": self.error,
            "duration_seconds": self.duration_seconds,
            "risk_score": self.risk_score,
            "timestamp": self.timestamp.isoformat(),
            "metadata": self.metadata,
        }


class BasePostExploit(ABC):
    """
    Abstract base class for all post-exploitation techniques.
    
    Every post-exploitation technique must:
    1. Declare its capabilities (OS targets, privilege requirements)
    2. Implement execute() method
    3. Implement cleanup() to remove artifacts
    4. Define stealth and risk levels
    
    Consciousness Alignment:
    Post-exploitation validates system resilience under adversarial conditions,
    contributing to MAXIMUS understanding of security boundaries and defense gaps.
    """

    def __init__(self) -> None:
        self.technique_id: str = ""
        self.name: str = ""
        self.description: str = ""
        self.category: PostExploitCategory = PostExploitCategory.PRIVILEGE_ESCALATION
        self.os_targets: List[str] = []  # ["linux", "windows", "macos"]
        self.privilege_required: str = "user"  # "user", "root", "admin"
        self.stealth_level: int = 5  # 0-10 (0=loud, 10=stealthy)
        self.risk_level: int = 5  # 0-10 (0=safe, 10=dangerous)
        self.mitre_tactics: List[str] = []  # MITRE ATT&CK tactics
        self.cve_references: List[str] = []  # Related CVEs

    @abstractmethod
    async def execute(
        self,
        target: str,
        credentials: Optional[Dict[str, str]] = None,
        **kwargs: Any
    ) -> PostExploitResult:
        """
        Execute post-exploitation technique against target.
        
        Args:
            target: Target identifier (hostname, IP, container ID)
            credentials: Authentication credentials if needed
            **kwargs: Technique-specific parameters
        
        Returns:
            PostExploitResult with execution details
        
        Raises:
            PostExploitException: If execution fails critically
        """
        pass

    @abstractmethod
    async def cleanup(
        self,
        target: str,
        artifacts: Dict[str, Any]
    ) -> bool:
        """
        Remove artifacts created by technique execution.
        
        Args:
            target: Target identifier
            artifacts: Artifacts dictionary from PostExploitResult
        
        Returns:
            True if cleanup successful, False otherwise
        """
        pass

    async def validate_target(self, target: str) -> tuple[bool, str]:
        """
        Validate if target is suitable for this technique.
        
        Args:
            target: Target identifier
        
        Returns:
            (is_valid, reason) tuple
        """
        # Default implementation - override for specific checks
        return True, "Target validation passed"

    async def pre_execution_check(
        self,
        target: str,
        credentials: Optional[Dict[str, str]] = None
    ) -> tuple[bool, str]:
        """
        Perform safety checks before execution.
        
        Args:
            target: Target identifier
            credentials: Authentication credentials
        
        Returns:
            (is_safe, reason) tuple
        """
        # Validate target
        is_valid, reason = await self.validate_target(target)
        if not is_valid:
            return False, f"Target validation failed: {reason}"

        # Check risk level
        if self.risk_level > 8:
            return False, f"Risk level {self.risk_level} too high for automated execution"

        return True, "Pre-execution checks passed"

    def get_metadata(self) -> Dict[str, Any]:
        """Get technique metadata."""
        return {
            "technique_id": self.technique_id,
            "name": self.name,
            "description": self.description,
            "category": self.category.value,
            "os_targets": self.os_targets,
            "privilege_required": self.privilege_required,
            "stealth_level": self.stealth_level,
            "risk_level": self.risk_level,
            "mitre_tactics": self.mitre_tactics,
            "cve_references": self.cve_references,
        }

    def __repr__(self) -> str:
        return (
            f"<{self.__class__.__name__}("
            f"id={self.technique_id}, "
            f"category={self.category.value}, "
            f"risk={self.risk_level})>"
        )


class PostExploitException(Exception):
    """Base exception for post-exploitation operations."""
    pass


class TargetUnreachableException(PostExploitException):
    """Target cannot be reached or connected to."""
    pass


class InsufficientPrivilegesException(PostExploitException):
    """Insufficient privileges to execute technique."""
    pass


class TechniqueBlockedException(PostExploitException):
    """Technique was blocked by security controls."""
    pass


class CleanupFailedException(PostExploitException):
    """Failed to clean up artifacts."""
    pass
