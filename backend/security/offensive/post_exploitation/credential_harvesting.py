"""
Password File Extraction - Credential Harvesting Technique.

Extracts and cracks password files (/etc/shadow, /etc/passwd) for credential theft.

Technique ID: CRED-PASSWORD-FILES-001
MITRE ATT&CK: T1003.008 (OS Credential Dumping: /etc/passwd and /etc/shadow)

Stealth Level: 5/10 (requires file access, leaves logs)
Risk Level: 4/10 (read-only operation, but sensitive data)
"""

import asyncio
import logging
from typing import Optional, Dict, Any, List
import time
import hashlib

from .base import (
    BasePostExploit,
    PostExploitCategory,
    PostExploitResult,
    PostExploitStatus,
    InsufficientPrivilegesException,
)

logger = logging.getLogger(__name__)


class PasswordFileExtraction(BasePostExploit):
    """
    Extract and crack Unix password files for credential harvesting.
    
    Technique Flow:
    1. Check read permissions on /etc/shadow (requires root/sudo)
    2. Extract /etc/passwd for usernames
    3. Extract /etc/shadow for password hashes
    4. Combine data into crackable format
    5. Optionally attempt basic hash cracking
    6. Identify weak/crackable passwords
    
    Supported Hash Types:
    - $1$ = MD5
    - $2a$ = Blowfish
    - $5$ = SHA-256
    - $6$ = SHA-512
    - $y$ = yescrypt
    
    Defense Evasion:
    - Read-only operation (no file modification)
    - Legitimate system file access
    - Can use existing access methods (sudo, SUID)
    
    Consciousness Alignment:
    Validates password policy strength and file permission hardening.
    Tests whether organizations use strong password hashing and restrict
    shadow file access appropriately.
    """

    def __init__(self) -> None:
        super().__init__()
        self.technique_id = "CRED-PASSWORD-FILES-001"
        self.name = "Password File Extraction"
        self.description = "Extract and crack Unix password files"
        self.category = PostExploitCategory.CREDENTIAL_HARVESTING
        self.os_targets = ["linux", "unix"]
        self.privilege_required = "root"  # Typically requires root for /etc/shadow
        self.stealth_level = 5
        self.risk_level = 4
        self.mitre_tactics = ["T1003.008"]

        # Common weak passwords for quick cracking
        self.weak_passwords = [
            "password", "123456", "admin", "root", "toor",
            "Password1", "Welcome1", "qwerty", "letmein",
            "changeme", "P@ssw0rd", "password123",
        ]

    async def execute(
        self,
        target: str,
        credentials: Optional[Dict[str, str]] = None,
        **kwargs: Any
    ) -> PostExploitResult:
        """
        Execute password file extraction.
        
        Args:
            target: Target system identifier
            credentials: Current access credentials (should include root)
            **kwargs: Options (crack_weak, output_format)
        
        Returns:
            PostExploitResult with extracted credentials
        """
        start_time = time.time()
        evidence: List[str] = []

        try:
            is_safe, reason = await self.pre_execution_check(target, credentials)
            if not is_safe:
                return self._create_failed_result(reason, start_time, evidence)

            logger.info(f"[{self.technique_id}] Extracting password files from {target}")
            evidence.append(f"Technique {self.technique_id} initiated")

            # Step 1: Check /etc/shadow permissions
            logger.debug(f"[{self.technique_id}] Checking /etc/shadow access")
            shadow_readable = await self._check_shadow_access(target, credentials)

            if not shadow_readable:
                return self._create_failed_result(
                    "Cannot read /etc/shadow (insufficient privileges)",
                    start_time,
                    evidence,
                    metadata={"privilege_required": "root"}
                )

            evidence.append("Verified /etc/shadow read access")

            # Step 2: Extract /etc/passwd
            logger.debug(f"[{self.technique_id}] Extracting /etc/passwd")
            passwd_content = await self._extract_passwd(target, credentials)

            if not passwd_content:
                return self._create_failed_result(
                    "Failed to read /etc/passwd",
                    start_time,
                    evidence
                )

            evidence.append("Extracted /etc/passwd")

            # Step 3: Extract /etc/shadow
            logger.debug(f"[{self.technique_id}] Extracting /etc/shadow")
            shadow_content = await self._extract_shadow(target, credentials)

            if not shadow_content:
                return self._create_failed_result(
                    "Failed to read /etc/shadow",
                    start_time,
                    evidence
                )

            evidence.append("Extracted /etc/shadow")

            # Step 4: Parse and combine data
            users = await self._parse_password_files(passwd_content, shadow_content)
            evidence.append(f"Parsed {len(users)} user accounts")

            # Step 5: Identify hash types
            users_with_hashes = [u for u in users if u.get("hash")]
            evidence.append(f"Found {len(users_with_hashes)} accounts with password hashes")

            # Step 6: Optional weak password cracking
            crack_weak = kwargs.get("crack_weak", True)
            cracked_passwords = []

            if crack_weak and users_with_hashes:
                logger.debug(f"[{self.technique_id}] Attempting weak password cracking")
                cracked_passwords = await self._crack_weak_passwords(users_with_hashes)
                
                if cracked_passwords:
                    evidence.append(f"Cracked {len(cracked_passwords)} weak password(s)")

            # Step 7: Generate output
            output = self._format_output(users, cracked_passwords)

            return PostExploitResult(
                technique_id=self.technique_id,
                category=self.category,
                status=PostExploitStatus.SUCCESS,
                success=True,
                output=output,
                artifacts={
                    "users": users,
                    "users_with_hashes": users_with_hashes,
                    "cracked_passwords": cracked_passwords,
                    "total_users": len(users),
                    "total_hashes": len(users_with_hashes),
                    "total_cracked": len(cracked_passwords),
                    "passwd_file": "/etc/passwd",
                    "shadow_file": "/etc/shadow",
                },
                evidence=evidence,
                error=None,
                duration_seconds=time.time() - start_time,
                risk_score=0.7,
                metadata={
                    "credential_harvesting": True,
                    "weak_passwords_found": len(cracked_passwords) > 0,
                    "password_policy_weak": len(cracked_passwords) > 0,
                }
            )

        except InsufficientPrivilegesException as e:
            logger.error(f"[{self.technique_id}] Insufficient privileges: {e}")
            return self._create_failed_result(
                f"Insufficient privileges: {e}",
                start_time,
                evidence
            )

        except Exception as e:
            logger.exception(f"[{self.technique_id}] Unexpected error")
            return self._create_error_result(
                f"Unexpected error: {str(e)}",
                start_time,
                evidence
            )

    async def cleanup(
        self,
        target: str,
        artifacts: Dict[str, Any]
    ) -> bool:
        """
        Cleanup for password extraction (typically none needed).
        
        Args:
            target: Target system
            artifacts: Extraction artifacts
        
        Returns:
            True (no cleanup required for read-only operation)
        """
        logger.info(f"[{self.technique_id}] No cleanup required (read-only operation)")
        return True

    # Private helper methods

    async def _check_shadow_access(
        self,
        target: str,
        credentials: Optional[Dict[str, str]]
    ) -> bool:
        """Check if /etc/shadow is readable."""
        # In production: test -r /etc/shadow
        await asyncio.sleep(0.05)
        
        # Simulate: check if we have root credentials
        if credentials and credentials.get("privilege") == "root":
            return True
        
        # Default: assume we can read if we got this far
        return True

    async def _extract_passwd(
        self,
        target: str,
        credentials: Optional[Dict[str, str]]
    ) -> str:
        """Extract /etc/passwd content."""
        # In production: cat /etc/passwd
        await asyncio.sleep(0.05)

        # Simulated /etc/passwd content
        passwd = """root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
admin:x:1000:1000:Admin User:/home/admin:/bin/bash
testuser:x:1001:1001:Test User:/home/testuser:/bin/bash
webuser:x:1002:1002:Web User:/var/www:/bin/sh
"""
        return passwd

    async def _extract_shadow(
        self,
        target: str,
        credentials: Optional[Dict[str, str]]
    ) -> str:
        """Extract /etc/shadow content."""
        # In production: sudo cat /etc/shadow
        await asyncio.sleep(0.05)

        # Simulated /etc/shadow content (weak passwords for testing)
        shadow = """root:$6$rounds=656000$salt$longhash:19000:0:99999:7:::
daemon:*:19000:0:99999:7:::
bin:*:19000:0:99999:7:::
sys:*:19000:0:99999:7:::
admin:$6$salt$hash_of_password:19000:0:99999:7:::
testuser:$6$salt$hash_of_123456:19000:0:99999:7:::
webuser:$6$salt$hash_of_welcome:19000:0:99999:7:::
"""
        return shadow

    async def _parse_password_files(
        self,
        passwd: str,
        shadow: str
    ) -> List[Dict[str, Any]]:
        """Parse passwd and shadow files into user records."""
        users = []

        # Parse passwd
        passwd_lines = [l.strip() for l in passwd.split('\n') if l.strip()]
        shadow_lines = [l.strip() for l in shadow.split('\n') if l.strip()]

        # Build shadow lookup
        shadow_dict = {}
        for line in shadow_lines:
            parts = line.split(':')
            if len(parts) >= 2:
                username = parts[0]
                password_hash = parts[1]
                shadow_dict[username] = password_hash

        # Parse users
        for line in passwd_lines:
            parts = line.split(':')
            if len(parts) >= 7:
                username = parts[0]
                uid = parts[2]
                gid = parts[3]
                home = parts[5]
                shell = parts[6]

                hash_value = shadow_dict.get(username, '')
                hash_type = self._identify_hash_type(hash_value)

                users.append({
                    "username": username,
                    "uid": int(uid) if uid.isdigit() else 0,
                    "gid": int(gid) if gid.isdigit() else 0,
                    "home": home,
                    "shell": shell,
                    "hash": hash_value,
                    "hash_type": hash_type,
                    "hash_disabled": hash_value in ('*', '!', '!!', ''),
                })

        return users

    def _identify_hash_type(self, hash_value: str) -> str:
        """Identify password hash type."""
        if not hash_value or hash_value in ('*', '!', '!!', 'x'):
            return "disabled"
        elif hash_value.startswith('$1$'):
            return "MD5"
        elif hash_value.startswith('$2a$') or hash_value.startswith('$2b$'):
            return "Blowfish"
        elif hash_value.startswith('$5$'):
            return "SHA-256"
        elif hash_value.startswith('$6$'):
            return "SHA-512"
        elif hash_value.startswith('$y$'):
            return "yescrypt"
        else:
            return "unknown"

    async def _crack_weak_passwords(
        self,
        users: List[Dict[str, Any]]
    ) -> List[Dict[str, str]]:
        """
        Attempt to crack weak passwords.
        
        Returns:
            List of cracked credentials
        """
        cracked = []

        # Simulate cracking weak passwords
        await asyncio.sleep(0.2)

        # For testing: simulate finding weak passwords
        for user in users:
            if user["username"] in ["testuser", "webuser"]:
                cracked.append({
                    "username": user["username"],
                    "password": "weak_password_123",
                    "hash_type": user["hash_type"],
                })

        return cracked

    def _format_output(
        self,
        users: List[Dict[str, Any]],
        cracked: List[Dict[str, str]]
    ) -> str:
        """Format extraction output."""
        output = "Password File Extraction Results:\n"
        output += "=" * 60 + "\n\n"

        output += f"Total Users: {len(users)}\n"
        users_with_hashes = [u for u in users if u["hash"] and not u["hash_disabled"]]
        output += f"Users with Password Hashes: {len(users_with_hashes)}\n"
        output += f"Cracked Passwords: {len(cracked)}\n\n"

        if cracked:
            output += "CRACKED CREDENTIALS:\n"
            output += "-" * 60 + "\n"
            for cred in cracked:
                output += f"  {cred['username']}:{cred['password']} ({cred['hash_type']})\n"
            output += "\n"

        output += "USERS WITH HASHES:\n"
        output += "-" * 60 + "\n"
        for user in users_with_hashes[:10]:  # Show first 10
            output += f"  {user['username']} (UID: {user['uid']}, Hash: {user['hash_type']})\n"

        if len(users_with_hashes) > 10:
            output += f"  ... and {len(users_with_hashes) - 10} more\n"

        return output

    def _create_failed_result(
        self,
        reason: str,
        start_time: float,
        evidence: List[str],
        metadata: Optional[Dict[str, Any]] = None
    ) -> PostExploitResult:
        """Helper to create failed result."""
        return PostExploitResult(
            technique_id=self.technique_id,
            category=self.category,
            status=PostExploitStatus.FAILED,
            success=False,
            output="",
            artifacts={},
            evidence=evidence,
            error=reason,
            duration_seconds=time.time() - start_time,
            risk_score=0.0,
            metadata=metadata or {}
        )

    def _create_error_result(
        self,
        error: str,
        start_time: float,
        evidence: List[str]
    ) -> PostExploitResult:
        """Helper to create error result."""
        return PostExploitResult(
            technique_id=self.technique_id,
            category=self.category,
            status=PostExploitStatus.ERROR,
            success=False,
            output="",
            artifacts={},
            evidence=evidence,
            error=error,
            duration_seconds=time.time() - start_time,
            risk_score=0.0
        )
