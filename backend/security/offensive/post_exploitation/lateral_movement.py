"""
SSH Key Propagation - Lateral Movement Technique.

Steals SSH private keys and uses them for lateral movement across network.

Technique ID: LATERAL-SSH-PROPAGATION-001
MITRE ATT&CK: T1021.004 (Remote Services: SSH), T1552.004 (Unsecured Credentials: Private Keys)

Stealth Level: 8/10 (legitimate SSH usage)
Risk Level: 3/10 (non-destructive reconnaissance)
"""

import asyncio
import logging
from typing import Optional, Dict, Any, List
import time

from .base import (
    BasePostExploit,
    PostExploitCategory,
    PostExploitResult,
    PostExploitStatus,
)

logger = logging.getLogger(__name__)


class SSHKeyPropagation(BasePostExploit):
    """
    Steals SSH private keys and uses them for lateral movement.
    
    Technique Flow:
    1. Find SSH private keys in ~/.ssh/, /root/.ssh/
    2. Extract keys without passphrases
    3. Scan network for SSH servers
    4. Attempt authentication with stolen keys
    5. Establish persistence on compromised hosts
    
    Common SSH Key Locations:
    - ~/.ssh/id_rsa, ~/.ssh/id_ed25519, ~/.ssh/id_ecdsa
    - /root/.ssh/
    - /home/*/.ssh/
    - Custom locations in SSH config
    
    Defense Evasion:
    - Uses legitimate SSH protocol
    - No exploit code dropped
    - Mimics normal admin SSH activity
    - Leaves minimal forensic trail
    
    Consciousness Alignment:
    Validates SSH key management practices and network segmentation.
    Tests whether organizations properly protect and rotate SSH credentials.
    """

    def __init__(self) -> None:
        super().__init__()
        self.technique_id = "LATERAL-SSH-PROPAGATION-001"
        self.name = "SSH Key Propagation"
        self.description = "Lateral movement via stolen SSH private keys"
        self.category = PostExploitCategory.LATERAL_MOVEMENT
        self.os_targets = ["linux", "macos", "unix"]
        self.privilege_required = "user"
        self.stealth_level = 8
        self.risk_level = 3
        self.mitre_tactics = ["T1021.004", "T1552.004"]

        # Common SSH key filenames
        self.ssh_key_files = [
            "id_rsa",
            "id_ed25519",
            "id_ecdsa",
            "id_dsa",
            "identity",
        ]

    async def execute(
        self,
        target: str,
        credentials: Optional[Dict[str, str]] = None,
        **kwargs: Any
    ) -> PostExploitResult:
        """
        Execute SSH key propagation lateral movement.
        
        Args:
            target: Initial compromised target
            credentials: Current access credentials
            **kwargs: Options (network_range, max_hops)
        
        Returns:
            PostExploitResult with lateral movement details
        """
        start_time = time.time()
        evidence: List[str] = []

        try:
            is_safe, reason = await self.pre_execution_check(target, credentials)
            if not is_safe:
                return self._create_failed_result(reason, start_time, evidence)

            logger.info(f"[{self.technique_id}] Starting SSH key propagation from {target}")
            evidence.append(f"Technique {self.technique_id} initiated on {target}")

            # Step 1: Find SSH private keys on compromised host
            logger.debug(f"[{self.technique_id}] Searching for SSH private keys")
            ssh_keys = await self._find_ssh_keys(target, credentials)

            if not ssh_keys:
                return self._create_failed_result(
                    "No SSH private keys found on target",
                    start_time,
                    evidence
                )

            evidence.append(f"Found {len(ssh_keys)} SSH private key(s)")
            logger.info(f"[{self.technique_id}] Found {len(ssh_keys)} SSH keys")

            # Step 2: Filter keys without passphrases
            usable_keys = await self._filter_usable_keys(ssh_keys)
            
            if not usable_keys:
                return self._create_failed_result(
                    f"Found {len(ssh_keys)} keys but all require passphrases",
                    start_time,
                    evidence,
                    metadata={"keys_found": len(ssh_keys)}
                )

            evidence.append(f"Identified {len(usable_keys)} usable key(s) (no passphrase)")
            logger.info(f"[{self.technique_id}] {len(usable_keys)} keys usable")

            # Step 3: Discover network targets
            network_range = kwargs.get("network_range", "auto")
            targets = await self._discover_ssh_targets(target, network_range)

            evidence.append(f"Discovered {len(targets)} potential SSH target(s)")
            logger.info(f"[{self.technique_id}] Found {len(targets)} SSH targets")

            # Step 4: Attempt lateral movement
            compromised_hosts = await self._attempt_lateral_movement(
                usable_keys,
                targets,
                max_hops=kwargs.get("max_hops", 3)
            )

            if compromised_hosts:
                evidence.append(f"Successfully compromised {len(compromised_hosts)} additional host(s)")
                
                return PostExploitResult(
                    technique_id=self.technique_id,
                    category=self.category,
                    status=PostExploitStatus.SUCCESS,
                    success=True,
                    output=self._format_output(compromised_hosts),
                    artifacts={
                        "stolen_keys": [k["path"] for k in usable_keys],
                        "compromised_hosts": compromised_hosts,
                        "initial_target": target,
                        "key_count": len(usable_keys),
                        "movement_graph": self._build_movement_graph(
                            target,
                            compromised_hosts
                        ),
                    },
                    evidence=evidence,
                    error=None,
                    duration_seconds=time.time() - start_time,
                    risk_score=0.6,
                    metadata={
                        "lateral_movement_successful": True,
                        "hosts_compromised": len(compromised_hosts),
                        "attack_vector": "ssh_key_reuse",
                    }
                )
            else:
                return self._create_failed_result(
                    f"Found {len(usable_keys)} keys but could not authenticate to any targets",
                    start_time,
                    evidence,
                    metadata={
                        "keys_tried": len(usable_keys),
                        "targets_attempted": len(targets),
                    }
                )

        except Exception as e:
            logger.exception(f"[{self.technique_id}] Unexpected error")
            return self._create_error_result(
                f"Unexpected error: {str(e)}",
                start_time,
                evidence
            )

    async def cleanup(
        self,
        target: str,
        artifacts: Dict[str, Any]
    ) -> bool:
        """
        Clean up SSH connections and copied keys.
        
        Args:
            target: Original target
            artifacts: Artifacts from execution
        
        Returns:
            True if cleanup successful
        """
        try:
            logger.info(f"[{self.technique_id}] Starting cleanup")

            # Close SSH connections to compromised hosts
            compromised = artifacts.get("compromised_hosts", [])
            for host in compromised:
                await self._close_ssh_connection(host["ip"])

            logger.info(f"[{self.technique_id}] Cleanup completed")
            return True

        except Exception as e:
            logger.error(f"[{self.technique_id}] Cleanup failed: {e}")
            return False

    # Private helper methods

    async def _find_ssh_keys(
        self,
        target: str,
        credentials: Optional[Dict[str, str]]
    ) -> List[Dict[str, Any]]:
        """
        Find SSH private keys on target system.
        
        Returns:
            List of key info dicts
        """
        # In production: execute find command for .ssh directories
        # Simulate finding keys
        await asyncio.sleep(0.1)

        # Simulated keys found
        keys = [
            {
                "path": "/home/user/.ssh/id_rsa",
                "type": "rsa",
                "size": 2048,
                "fingerprint": "SHA256:abc123...",
            },
            {
                "path": "/home/user/.ssh/id_ed25519",
                "type": "ed25519",
                "size": 256,
                "fingerprint": "SHA256:def456...",
            },
        ]

        return keys

    async def _filter_usable_keys(
        self,
        keys: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """
        Filter keys without passphrases.
        
        Returns:
            List of usable keys
        """
        # In production: try to read keys, check if encrypted
        await asyncio.sleep(0.05)

        # Simulate: assume first key is usable
        return keys[:1] if keys else []

    async def _discover_ssh_targets(
        self,
        source: str,
        network_range: str
    ) -> List[str]:
        """
        Discover SSH servers on network.
        
        Returns:
            List of target IPs/hostnames
        """
        # In production: nmap -p 22 scan or parse known_hosts
        await asyncio.sleep(0.15)

        # Simulated targets
        targets = [
            "10.0.1.10",
            "10.0.1.20",
            "10.0.1.30",
        ]

        return targets

    async def _attempt_lateral_movement(
        self,
        keys: List[Dict[str, Any]],
        targets: List[str],
        max_hops: int
    ) -> List[Dict[str, Any]]:
        """
        Attempt SSH authentication to targets with stolen keys.
        
        Returns:
            List of successfully compromised hosts
        """
        compromised = []

        for target in targets[:max_hops]:
            for key in keys:
                # In production: ssh -i key target
                await asyncio.sleep(0.1)

                # Simulate: 50% success rate for testing
                if len(compromised) < 2:
                    compromised.append({
                        "ip": target,
                        "hostname": f"host-{target.split('.')[-1]}",
                        "key_used": key["path"],
                        "access_level": "user",
                    })
                    break  # Success, move to next target

        return compromised

    async def _close_ssh_connection(self, host: str) -> None:
        """Close SSH connection."""
        await asyncio.sleep(0.02)

    def _format_output(self, hosts: List[Dict[str, Any]]) -> str:
        """Format output of compromised hosts."""
        output = "SSH Lateral Movement Results:\n"
        output += "=" * 50 + "\n\n"
        
        for idx, host in enumerate(hosts, 1):
            output += f"{idx}. {host['hostname']} ({host['ip']})\n"
            output += f"   Key: {host['key_used']}\n"
            output += f"   Access: {host['access_level']}\n\n"

        return output

    def _build_movement_graph(
        self,
        initial: str,
        compromised: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Build lateral movement graph."""
        return {
            "root": initial,
            "nodes": [h["ip"] for h in compromised],
            "edges": [(initial, h["ip"]) for h in compromised],
        }

    def _create_failed_result(
        self,
        reason: str,
        start_time: float,
        evidence: List[str],
        metadata: Optional[Dict[str, Any]] = None
    ) -> PostExploitResult:
        """Helper to create failed result."""
        return PostExploitResult(
            technique_id=self.technique_id,
            category=self.category,
            status=PostExploitStatus.FAILED,
            success=False,
            output="",
            artifacts={},
            evidence=evidence,
            error=reason,
            duration_seconds=time.time() - start_time,
            risk_score=0.0,
            metadata=metadata or {}
        )

    def _create_error_result(
        self,
        error: str,
        start_time: float,
        evidence: List[str]
    ) -> PostExploitResult:
        """Helper to create error result."""
        return PostExploitResult(
            technique_id=self.technique_id,
            category=self.category,
            status=PostExploitStatus.ERROR,
            success=False,
            output="",
            artifacts={},
            evidence=evidence,
            error=error,
            duration_seconds=time.time() - start_time,
            risk_score=0.0
        )
