"""
Exploit Templates - CWE-specific exploit templates for wargaming.

Provides exploit templates for common CWEs:
- CWE-89: SQL Injection
- CWE-79: Cross-Site Scripting (XSS)
- CWE-502: Deserialization of Untrusted Data
- CWE-22: Path Traversal
- CWE-78: OS Command Injection
- CWE-798: Use of Hard-coded Credentials

Each template includes:
- Language-specific exploit code
- Setup commands (dependencies, environment)
- Expected behavior (exit codes)
"""

import logging
from typing import Dict


from .workflow_generator import ExploitContext

logger = logging.getLogger(__name__)


class ExploitTemplateLibrary:
    """
    Library of exploit templates organized by CWE.

    Features:
    - CWE-specific exploits
    - Multi-language support (Python, JavaScript, bash)
    - Customizable per vulnerability context
    """

    def __init__(self):
        """Initialize exploit template library."""
        self._templates: Dict[str, ExploitContext] = {}
        self._load_templates()

        logger.info(f"ExploitTemplateLibrary loaded: {len(self._templates)} templates")

    def get_template(self, cwe_id: str, language: str = "python") -> ExploitContext:
        """
        Get exploit template for CWE.

        Args:
            cwe_id: CWE identifier (e.g., "CWE-89")
            language: Programming language (python, javascript, bash)

        Returns:
            ExploitContext for the CWE

        Raises:
            KeyError: If template not found
        """
        template_key = f"{cwe_id}:{language}"

        if template_key not in self._templates:
            # Fallback to generic template
            logger.warning(f"No template for {template_key}, using generic")
            return self._get_generic_template(language)

        logger.info(f"Using template: {template_key}")
        return self._templates[template_key]

    def _load_templates(self) -> None:
        """Load all exploit templates."""
        # CWE-89: SQL Injection
        self._templates["CWE-89:python"] = self._cwe_89_python()
        self._templates["CWE-89:javascript"] = self._cwe_89_javascript()

        # CWE-79: Cross-Site Scripting (XSS)
        self._templates["CWE-79:python"] = self._cwe_79_python()
        self._templates["CWE-79:javascript"] = self._cwe_79_javascript()

        # CWE-502: Deserialization
        self._templates["CWE-502:python"] = self._cwe_502_python()
        self._templates["CWE-502:javascript"] = self._cwe_502_javascript()

        # CWE-22: Path Traversal
        self._templates["CWE-22:python"] = self._cwe_22_python()
        self._templates["CWE-22:bash"] = self._cwe_22_bash()

        # CWE-78: OS Command Injection
        self._templates["CWE-78:python"] = self._cwe_78_python()
        self._templates["CWE-78:bash"] = self._cwe_78_bash()

        # CWE-798: Hard-coded Credentials
        self._templates["CWE-798:bash"] = self._cwe_798_bash()

    # ==================== CWE-89: SQL Injection ====================

    def _cwe_89_python(self) -> ExploitContext:
        """SQL Injection exploit (Python)."""
        return ExploitContext(
            language="python",
            setup_commands=[
                "pip install --quiet sqlalchemy",
            ],
            exploit_script="""
import sys
import sqlite3

# Create test database
conn = sqlite3.connect(':memory:')
cursor = conn.cursor()
cursor.execute('CREATE TABLE users (id INTEGER, username TEXT, password TEXT)')
cursor.execute("INSERT INTO users VALUES (1, 'admin', 'secret')")
conn.commit()

# Vulnerable query (should be in target code, but we simulate here)
malicious_input = "admin' OR '1'='1"

try:
    # This simulates vulnerable code
    query = f"SELECT * FROM users WHERE username = '{malicious_input}'"
    cursor.execute(query)
    results = cursor.fetchall()

    if len(results) > 0:
        print(f"[EXPLOIT SUCCESS] SQL Injection worked! Retrieved {len(results)} rows")
        print(f"Data: {results}")
        sys.exit(1)  # Exit 1 = exploit succeeded (vulnerable)
    else:
        print("[EXPLOIT FAILED] SQL Injection blocked")
        sys.exit(0)  # Exit 0 = exploit failed (patched)

except Exception as e:
    print(f"[EXPLOIT ERROR] {e}")
    sys.exit(2)  # Exit 2 = inconclusive
""",
            expected_exit_before=1,  # Vulnerable
            expected_exit_after=0,  # Fixed
        )

    def _cwe_89_javascript(self) -> ExploitContext:
        """SQL Injection exploit (JavaScript)."""
        return ExploitContext(
            language="javascript",
            setup_commands=[
                "npm install --silent better-sqlite3",
            ],
            exploit_script="""
const Database = require('better-sqlite3');

// Create test database
const db = new Database(':memory:');
db.exec('CREATE TABLE users (id INTEGER, username TEXT, password TEXT)');
db.exec("INSERT INTO users VALUES (1, 'admin', 'secret')");

// Malicious input
const maliciousInput = "admin' OR '1'='1";

try {
    // Vulnerable query
    const query = `SELECT * FROM users WHERE username = '${maliciousInput}'`;
    const results = db.prepare(query).all();

    if (results.length > 0) {
        console.log(`[EXPLOIT SUCCESS] SQL Injection worked! Retrieved ${results.length} rows`);
        process.exit(1);  // Vulnerable
    } else {
        console.log('[EXPLOIT FAILED] SQL Injection blocked');
        process.exit(0);  // Fixed
    }
} catch (error) {
    console.log(`[EXPLOIT ERROR] ${error.message}`);
    process.exit(2);  // Inconclusive
}
""",
            expected_exit_before=1,
            expected_exit_after=0,
        )

    # ==================== CWE-79: Cross-Site Scripting ====================

    def _cwe_79_python(self) -> ExploitContext:
        """XSS exploit (Python)."""
        return ExploitContext(
            language="python",
            setup_commands=[],
            exploit_script="""
import sys
import html

# Malicious input
malicious_input = '<script>alert("XSS")</script>'

# Simulate vulnerable code (no HTML escaping)
def vulnerable_render(user_input):
    return f"<div>Hello {user_input}</div>"

# Simulate patched code (HTML escaping)
def patched_render(user_input):
    return f"<div>Hello {html.escape(user_input)}</div>"

# Test vulnerable code
output = vulnerable_render(malicious_input)

if '<script>' in output:
    print(f"[EXPLOIT SUCCESS] XSS payload present in output")
    print(f"Output: {output}")
    sys.exit(1)  # Vulnerable
else:
    print(f"[EXPLOIT FAILED] XSS payload escaped")
    print(f"Output: {output}")
    sys.exit(0)  # Fixed
""",
            expected_exit_before=1,
            expected_exit_after=0,
        )

    def _cwe_79_javascript(self) -> ExploitContext:
        """XSS exploit (JavaScript)."""
        return ExploitContext(
            language="javascript",
            setup_commands=[],
            exploit_script="""
// Malicious input
const maliciousInput = '<script>alert("XSS")</script>';

// Simulate vulnerable code
function vulnerableRender(userInput) {
    return `<div>Hello ${userInput}</div>`;
}

// Test
const output = vulnerableRender(maliciousInput);

if (output.includes('<script>')) {
    console.log('[EXPLOIT SUCCESS] XSS payload present in output');
    console.log(`Output: ${output}`);
    process.exit(1);  // Vulnerable
} else {
    console.log('[EXPLOIT FAILED] XSS payload escaped');
    console.log(`Output: ${output}`);
    process.exit(0);  // Fixed
}
""",
            expected_exit_before=1,
            expected_exit_after=0,
        )

    # ==================== CWE-502: Deserialization ====================

    def _cwe_502_python(self) -> ExploitContext:
        """Deserialization exploit (Python)."""
        return ExploitContext(
            language="python",
            setup_commands=[],
            exploit_script="""
import sys
import pickle
import base64

# Malicious payload (executes code on deserialization)
class Exploit:
    def __reduce__(self):
        import os
        return (os.system, ('echo VULNERABLE',))

# Serialize exploit
malicious_data = base64.b64encode(pickle.dumps(Exploit())).decode()

try:
    # Vulnerable code: deserialize untrusted data
    obj = pickle.loads(base64.b64decode(malicious_data))

    print("[EXPLOIT SUCCESS] Code executed during deserialization")
    sys.exit(1)  # Vulnerable

except Exception as e:
    print(f"[EXPLOIT FAILED] Deserialization blocked: {e}")
    sys.exit(0)  # Fixed
""",
            expected_exit_before=1,
            expected_exit_after=0,
        )

    def _cwe_502_javascript(self) -> ExploitContext:
        """Deserialization exploit (JavaScript)."""
        return ExploitContext(
            language="javascript",
            setup_commands=[],
            exploit_script="""
// Malicious JSON with __proto__ pollution
const maliciousInput = '{"__proto__": {"polluted": true}}';

try {
    // Vulnerable: unsafe JSON parse
    const obj = JSON.parse(maliciousInput);
    Object.assign({}, obj);

    // Check if prototype was polluted
    if (({}).polluted === true) {
        console.log('[EXPLOIT SUCCESS] Prototype pollution successful');
        process.exit(1);  // Vulnerable
    } else {
        console.log('[EXPLOIT FAILED] Prototype pollution blocked');
        process.exit(0);  // Fixed
    }
} catch (error) {
    console.log(`[EXPLOIT FAILED] ${error.message}`);
    process.exit(0);  // Fixed
}
""",
            expected_exit_before=1,
            expected_exit_after=0,
        )

    # ==================== CWE-22: Path Traversal ====================

    def _cwe_22_python(self) -> ExploitContext:
        """Path Traversal exploit (Python)."""
        return ExploitContext(
            language="python",
            setup_commands=[],
            exploit_script="""
import sys
import os

# Malicious input
malicious_path = "../../../etc/passwd"

# Simulate vulnerable code
def vulnerable_read_file(user_path):
    full_path = f"/app/uploads/{user_path}"
    try:
        with open(full_path, 'r') as f:
            return f.read()
    except:
        return None

# Check if /etc/passwd exists (we're on Linux)
if os.path.exists('/etc/passwd'):
    # Try path traversal
    content = vulnerable_read_file(malicious_path)

    if content and 'root:' in content:
        print("[EXPLOIT SUCCESS] Path traversal successful, read /etc/passwd")
        sys.exit(1)  # Vulnerable
    else:
        print("[EXPLOIT FAILED] Path traversal blocked")
        sys.exit(0)  # Fixed
else:
    print("[EXPLOIT SKIPPED] /etc/passwd not found (not Linux)")
    sys.exit(2)  # Inconclusive
""",
            expected_exit_before=1,
            expected_exit_after=0,
        )

    def _cwe_22_bash(self) -> ExploitContext:
        """Path Traversal exploit (bash)."""
        return ExploitContext(
            language="bash",
            setup_commands=[],
            exploit_script="""
#!/bin/bash

# Malicious input
MALICIOUS_PATH="../../../etc/passwd"

# Simulate vulnerable code
BASE_DIR="/tmp/uploads"
mkdir -p "$BASE_DIR"

# Vulnerable: no path sanitization
FULL_PATH="$BASE_DIR/$MALICIOUS_PATH"

if [ -f "$FULL_PATH" ]; then
    echo "[EXPLOIT SUCCESS] Path traversal successful"
    cat "$FULL_PATH" | head -5
    exit 1  # Vulnerable
else
    echo "[EXPLOIT FAILED] Path traversal blocked"
    exit 0  # Fixed
fi
""",
            expected_exit_before=1,
            expected_exit_after=0,
        )

    # ==================== CWE-78: Command Injection ====================

    def _cwe_78_python(self) -> ExploitContext:
        """Command Injection exploit (Python)."""
        return ExploitContext(
            language="python",
            setup_commands=[],
            exploit_script="""
import sys
import subprocess

# Malicious input
malicious_input = "test; echo VULNERABLE"

try:
    # Vulnerable: shell=True with user input
    result = subprocess.run(
        f"echo {malicious_input}",
        shell=True,
        capture_output=True,
        text=True,
        timeout=5
    )

    if 'VULNERABLE' in result.stdout:
        print("[EXPLOIT SUCCESS] Command injection successful")
        print(f"Output: {result.stdout}")
        sys.exit(1)  # Vulnerable
    else:
        print("[EXPLOIT FAILED] Command injection blocked")
        sys.exit(0)  # Fixed

except Exception as e:
    print(f"[EXPLOIT ERROR] {e}")
    sys.exit(2)  # Inconclusive
""",
            expected_exit_before=1,
            expected_exit_after=0,
        )

    def _cwe_78_bash(self) -> ExploitContext:
        """Command Injection exploit (bash)."""
        return ExploitContext(
            language="bash",
            setup_commands=[],
            exploit_script="""
#!/bin/bash

# Malicious input
MALICIOUS_INPUT="test; echo VULNERABLE"

# Vulnerable: eval with user input
OUTPUT=$(eval "echo $MALICIOUS_INPUT" 2>&1)

if echo "$OUTPUT" | grep -q "VULNERABLE"; then
    echo "[EXPLOIT SUCCESS] Command injection successful"
    echo "Output: $OUTPUT"
    exit 1  # Vulnerable
else
    echo "[EXPLOIT FAILED] Command injection blocked"
    exit 0  # Fixed
fi
""",
            expected_exit_before=1,
            expected_exit_after=0,
        )

    # ==================== CWE-798: Hard-coded Credentials ====================

    def _cwe_798_bash(self) -> ExploitContext:
        """Hard-coded Credentials check (bash)."""
        return ExploitContext(
            language="bash",
            setup_commands=[],
            exploit_script="""
#!/bin/bash

# Search for hard-coded credentials in source code
PATTERNS=(
    "password.*=.*['\\\"][^'\\\"]+['\\\"]"
    "api_key.*=.*['\\\"][^'\\\"]+['\\\"]"
    "secret.*=.*['\\\"][^'\\\"]+['\\\"]"
    "token.*=.*['\\\"][^'\\\"]+['\\\"]"
)

FOUND=0

for pattern in "${PATTERNS[@]}"; do
    if grep -rE "$pattern" . --include="*.py" --include="*.js" --include="*.go" 2>/dev/null | grep -v test | head -1; then
        echo "[EXPLOIT SUCCESS] Found hard-coded credential pattern: $pattern"
        FOUND=1
        break
    fi
done

if [ $FOUND -eq 1 ]; then
    exit 1  # Vulnerable
else
    echo "[EXPLOIT FAILED] No hard-coded credentials found"
    exit 0  # Fixed
fi
""",
            expected_exit_before=1,
            expected_exit_after=0,
        )

    # ==================== Generic Template ====================

    def _get_generic_template(self, language: str) -> ExploitContext:
        """Generic exploit template (placeholder)."""
        return ExploitContext(
            language=language,
            setup_commands=[],
            exploit_script="""
# Generic exploit placeholder
# This should be customized per vulnerability

echo "[EXPLOIT] Running generic exploit template"
echo "[EXPLOIT] Vulnerability context not specific enough"

# Default: assume no vulnerability can be reproduced
exit 2  # Inconclusive
""",
            expected_exit_before=2,  # Inconclusive
            expected_exit_after=2,  # Inconclusive
        )
