-- MAXIMUS Adaptive Immunity Database Schema
-- Purpose: Store APVs, patches, audit logs, and few-shot learning examples
-- Author: MAXIMUS Team
-- Date: 2025-10-11
-- Compliance: Doutrina MAXIMUS | NO PLACEHOLDER | Production-Ready

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";  -- For text search optimization

-- ============================================================================
-- TABLE: apvs (Actionable Prioritized Vulnerabilities)
-- ============================================================================
-- Purpose: Store processed vulnerabilities from Oráculo
-- Flow: Oráculo → APV → Kafka → Eureka
-- Retention: 90 days (cleanup job TBD)

CREATE TABLE apvs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    cve_id VARCHAR(50) NOT NULL UNIQUE,
    
    -- Raw data from threat feed
    raw_vulnerability JSONB NOT NULL,
    
    -- Enriched data (CVSS, CWE, signatures)
    enriched_vulnerability JSONB NOT NULL,
    
    -- Final APV object (actionable)
    apv_object JSONB NOT NULL,
    
    -- Priority level
    priority VARCHAR(20) NOT NULL CHECK (priority IN ('critical', 'high', 'medium', 'low')),
    
    -- Status tracking
    status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'confirmed', 'rejected', 'patched', 'ignored')),
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT NOW(),
    processed_at TIMESTAMP,
    confirmed_at TIMESTAMP,
    patched_at TIMESTAMP,
    
    -- Source tracking
    source_feed VARCHAR(100) NOT NULL,  -- OSV.dev, NVD, Docker Security
    oraculo_version VARCHAR(20) DEFAULT '1.0.0',
    
    -- Metadata
    affected_services TEXT[],  -- Array of service names
    remediation_strategy VARCHAR(50),
    
    -- Observability
    processing_duration_ms INTEGER,
    
    CONSTRAINT valid_processing_duration CHECK (processing_duration_ms >= 0)
);

-- Indexes for performance
CREATE INDEX idx_apvs_cve_id ON apvs(cve_id);
CREATE INDEX idx_apvs_status ON apvs(status);
CREATE INDEX idx_apvs_priority ON apvs(priority);
CREATE INDEX idx_apvs_created_at ON apvs(created_at DESC);
CREATE INDEX idx_apvs_source_feed ON apvs(source_feed);
CREATE INDEX idx_apvs_affected_services ON apvs USING GIN(affected_services);
CREATE INDEX idx_apvs_apv_object ON apvs USING GIN(apv_object jsonb_path_ops);

-- Full-text search index on raw vulnerability
CREATE INDEX idx_apvs_raw_vuln_search ON apvs USING GIN(to_tsvector('english', raw_vulnerability::text));

COMMENT ON TABLE apvs IS 'Actionable Prioritized Vulnerabilities processed by Oráculo';
COMMENT ON COLUMN apvs.cve_id IS 'CVE identifier (e.g., CVE-2024-12345)';
COMMENT ON COLUMN apvs.priority IS 'MAXIMUS calculated priority based on CVSS + context';
COMMENT ON COLUMN apvs.status IS 'Lifecycle: pending → processing → confirmed → patched';

-- ============================================================================
-- TABLE: patches (Generated patches from Eureka)
-- ============================================================================
-- Purpose: Store remediation patches generated by Eureka
-- Flow: Eureka → Patch → Git → Validation → Merge
-- Retention: Permanent (audit trail)

CREATE TABLE patches (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    cve_id VARCHAR(50) NOT NULL,
    
    -- Strategy used
    strategy VARCHAR(50) NOT NULL CHECK (strategy IN ('dependency_upgrade', 'code_patch', 'coagulation_waf', 'manual_review')),
    
    -- Patch content
    patch_diff TEXT NOT NULL,
    patch_size_bytes INTEGER GENERATED ALWAYS AS (length(patch_diff)) STORED,
    
    -- LLM metadata (if applicable)
    llm_model VARCHAR(100),
    llm_confidence FLOAT CHECK (llm_confidence >= 0 AND llm_confidence <= 1),
    llm_prompt_tokens INTEGER,
    llm_completion_tokens INTEGER,
    llm_cost_usd NUMERIC(10, 4),
    
    -- Git integration
    git_branch VARCHAR(255),
    git_commit_sha VARCHAR(40),
    git_pr_number INTEGER,
    git_pr_url TEXT,
    
    -- Validation status
    validation_status VARCHAR(50) DEFAULT 'pending' CHECK (validation_status IN ('pending', 'validating', 'passed', 'failed', 'merged', 'rejected')),
    validation_logs JSONB,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT NOW(),
    validated_at TIMESTAMP,
    merged_at TIMESTAMP,
    
    -- Metrics
    generation_duration_ms INTEGER,
    validation_duration_ms INTEGER,
    
    -- Metadata
    affected_files TEXT[],
    breaking_changes BOOLEAN DEFAULT FALSE,
    
    CONSTRAINT patches_cve_fk FOREIGN KEY (cve_id) REFERENCES apvs(cve_id) ON DELETE CASCADE,
    CONSTRAINT valid_confidence CHECK (llm_confidence IS NULL OR (llm_confidence >= 0 AND llm_confidence <= 1)),
    CONSTRAINT valid_durations CHECK (generation_duration_ms >= 0 AND validation_duration_ms >= 0)
);

-- Indexes
CREATE INDEX idx_patches_cve_id ON patches(cve_id);
CREATE INDEX idx_patches_status ON patches(validation_status);
CREATE INDEX idx_patches_created_at ON patches(created_at DESC);
CREATE INDEX idx_patches_strategy ON patches(strategy);
CREATE INDEX idx_patches_git_branch ON patches(git_branch);
CREATE INDEX idx_patches_llm_model ON patches(llm_model);
CREATE INDEX idx_patches_merged_at ON patches(merged_at DESC) WHERE merged_at IS NOT NULL;

COMMENT ON TABLE patches IS 'Remediation patches generated by Eureka for confirmed vulnerabilities';
COMMENT ON COLUMN patches.strategy IS 'Remediation strategy: upgrade, patch, waf, or manual';
COMMENT ON COLUMN patches.llm_confidence IS 'LLM confidence score for code_patch strategy (0.0-1.0)';
COMMENT ON COLUMN patches.validation_status IS 'Lifecycle: pending → validating → passed → merged';

-- ============================================================================
-- TABLE: audit_log (Complete audit trail)
-- ============================================================================
-- Purpose: Immutable audit log for all immune system events
-- Flow: All services → Audit Log
-- Retention: 1 year (compliance requirement)

CREATE TABLE audit_log (
    id BIGSERIAL PRIMARY KEY,
    
    -- Event identification
    event_type VARCHAR(100) NOT NULL,
    event_category VARCHAR(50) NOT NULL CHECK (event_category IN ('oraculo', 'eureka', 'validation', 'deployment', 'security', 'system')),
    
    -- Event data
    event_data JSONB NOT NULL,
    
    -- Source tracking
    source_service VARCHAR(100) NOT NULL,
    source_host VARCHAR(255),
    source_version VARCHAR(20),
    
    -- Timestamp (immutable)
    timestamp TIMESTAMP DEFAULT NOW() NOT NULL,
    
    -- Security context
    user_id VARCHAR(100),
    session_id VARCHAR(100),
    ip_address INET,
    
    -- Severity
    severity VARCHAR(20) NOT NULL DEFAULT 'info' CHECK (severity IN ('debug', 'info', 'warning', 'error', 'critical')),
    
    -- Tracing
    trace_id VARCHAR(100),  -- Distributed tracing
    span_id VARCHAR(100),
    parent_span_id VARCHAR(100),
    
    -- Metadata
    tags TEXT[],
    
    CONSTRAINT valid_timestamp CHECK (timestamp <= NOW())
);

-- Indexes for query performance
CREATE INDEX idx_audit_timestamp ON audit_log(timestamp DESC);
CREATE INDEX idx_audit_event_type ON audit_log(event_type);
CREATE INDEX idx_audit_event_category ON audit_log(event_category);
CREATE INDEX idx_audit_source ON audit_log(source_service);
CREATE INDEX idx_audit_severity ON audit_log(severity);
CREATE INDEX idx_audit_user_id ON audit_log(user_id) WHERE user_id IS NOT NULL;
CREATE INDEX idx_audit_trace_id ON audit_log(trace_id) WHERE trace_id IS NOT NULL;
CREATE INDEX idx_audit_tags ON audit_log USING GIN(tags);
CREATE INDEX idx_audit_event_data ON audit_log USING GIN(event_data jsonb_path_ops);

COMMENT ON TABLE audit_log IS 'Immutable audit trail for all Adaptive Immunity events';
COMMENT ON COLUMN audit_log.event_type IS 'Event type: apv_generated, patch_created, validation_completed, etc.';
COMMENT ON COLUMN audit_log.trace_id IS 'Distributed tracing ID for end-to-end flow tracking';

-- ============================================================================
-- TABLE: vulnerability_fixes (Few-shot learning database)
-- ============================================================================
-- Purpose: Store curated vulnerability fix examples for LLM prompting
-- Flow: Manual curation + automated collection → LLM context
-- Retention: Permanent

CREATE TABLE vulnerability_fixes (
    id SERIAL PRIMARY KEY,
    
    -- Vulnerability classification
    cwe_id VARCHAR(20) NOT NULL,
    vulnerability_type VARCHAR(100) NOT NULL,
    
    -- Code examples
    vulnerable_code TEXT NOT NULL,
    fixed_code TEXT NOT NULL,
    
    -- Explanation
    explanation TEXT NOT NULL,
    rationale TEXT,  -- Why this fix works
    
    -- Metadata
    language VARCHAR(50) NOT NULL DEFAULT 'python',
    framework VARCHAR(100),  -- Django, FastAPI, Flask, etc.
    
    -- Source tracking
    source VARCHAR(255) NOT NULL,  -- OWASP, CVE, GitHub Advisory, etc.
    source_url TEXT,
    cve_reference VARCHAR(50),
    
    -- Quality metrics
    confidence_score FLOAT CHECK (confidence_score >= 0 AND confidence_score <= 1),
    usage_count INTEGER DEFAULT 0,  -- Track how often used in prompts
    success_rate FLOAT,  -- Track success rate when used
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    last_used_at TIMESTAMP,
    
    -- Tags for filtering
    tags TEXT[],
    
    CONSTRAINT valid_confidence CHECK (confidence_score IS NULL OR (confidence_score >= 0 AND confidence_score <= 1)),
    CONSTRAINT valid_success_rate CHECK (success_rate IS NULL OR (success_rate >= 0 AND success_rate <= 1))
);

-- Indexes
CREATE INDEX idx_vul_fixes_cwe ON vulnerability_fixes(cwe_id);
CREATE INDEX idx_vul_fixes_lang ON vulnerability_fixes(language);
CREATE INDEX idx_vul_fixes_vuln_type ON vulnerability_fixes(vulnerability_type);
CREATE INDEX idx_vul_fixes_framework ON vulnerability_fixes(framework) WHERE framework IS NOT NULL;
CREATE INDEX idx_vul_fixes_confidence ON vulnerability_fixes(confidence_score DESC) WHERE confidence_score IS NOT NULL;
CREATE INDEX idx_vul_fixes_usage ON vulnerability_fixes(usage_count DESC);
CREATE INDEX idx_vul_fixes_tags ON vulnerability_fixes USING GIN(tags);

-- Full-text search on code and explanation
CREATE INDEX idx_vul_fixes_code_search ON vulnerability_fixes USING GIN(
    to_tsvector('english', vulnerable_code || ' ' || fixed_code || ' ' || explanation)
);

COMMENT ON TABLE vulnerability_fixes IS 'Curated vulnerability fix examples for LLM few-shot learning';
COMMENT ON COLUMN vulnerability_fixes.usage_count IS 'Number of times this example was used in LLM prompts';
COMMENT ON COLUMN vulnerability_fixes.success_rate IS 'Success rate of patches generated using this example';

-- ============================================================================
-- SEED DATA: Initial few-shot examples
-- ============================================================================

INSERT INTO vulnerability_fixes (cwe_id, vulnerability_type, vulnerable_code, fixed_code, explanation, rationale, language, source, source_url, confidence_score, tags) VALUES
-- SQL Injection
('CWE-89', 'SQL Injection', 
'query = f"SELECT * FROM users WHERE id = {user_id}"
cursor.execute(query)',
'query = "SELECT * FROM users WHERE id = %s"
cursor.execute(query, (user_id,))',
'Use parameterized queries to prevent SQL injection. Never concatenate user input into SQL strings.',
'Parameterized queries ensure user input is properly escaped and typed, preventing malicious SQL from being executed.',
'python',
'OWASP Top 10',
'https://owasp.org/www-community/attacks/SQL_Injection',
1.0,
ARRAY['sql', 'injection', 'database', 'parameterized']),

-- XSS
('CWE-79', 'Cross-Site Scripting (XSS)',
'return f"<div>Hello {user_name}</div>"',
'from html import escape
return f"<div>Hello {escape(user_name)}</div>"',
'Always escape user input before rendering in HTML to prevent XSS attacks.',
'HTML escaping converts special characters (<, >, &, etc.) to HTML entities, preventing script injection.',
'python',
'OWASP Top 10',
'https://owasp.org/www-community/attacks/xss/',
1.0,
ARRAY['xss', 'html', 'escape', 'injection']),

-- Path Traversal
('CWE-22', 'Path Traversal',
'file_path = f"/data/{filename}"
with open(file_path, "r") as f:
    return f.read()',
'from pathlib import Path
base_dir = Path("/data")
file_path = (base_dir / filename).resolve()
if not file_path.is_relative_to(base_dir):
    raise ValueError("Invalid path")
with open(file_path, "r") as f:
    return f.read()',
'Validate and sanitize file paths to prevent directory traversal attacks. Use Path.resolve() and check containment.',
'Path.resolve() normalizes the path and removes ../ segments. Checking is_relative_to() ensures the final path stays within allowed directory.',
'python',
'OWASP',
'https://owasp.org/www-community/attacks/Path_Traversal',
0.95,
ARRAY['path-traversal', 'filesystem', 'validation']),

-- Command Injection
('CWE-78', 'OS Command Injection',
'import os
os.system(f"ping -c 4 {host}")',
'import subprocess
result = subprocess.run(["ping", "-c", "4", host], capture_output=True, text=True, timeout=10)
return result.stdout',
'Use subprocess with argument list instead of shell=True to prevent command injection.',
'Passing arguments as list prevents shell interpretation of special characters. Setting timeout prevents hanging.',
'python',
'OWASP',
'https://owasp.org/www-community/attacks/Command_Injection',
1.0,
ARRAY['command-injection', 'subprocess', 'shell']),

-- Insecure Deserialization
('CWE-502', 'Insecure Deserialization',
'import pickle
data = pickle.loads(user_input)',
'import json
data = json.loads(user_input)
# Or use safe serialization like MessagePack',
'Avoid pickle for untrusted data. Use JSON or other safe serialization formats.',
'pickle can execute arbitrary code during deserialization. JSON is data-only and safe for untrusted input.',
'python',
'OWASP Top 10',
'https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data',
1.0,
ARRAY['deserialization', 'pickle', 'json', 'rce']),

-- Weak Cryptography
('CWE-327', 'Use of Weak Cryptographic Algorithm',
'import hashlib
password_hash = hashlib.md5(password.encode()).hexdigest()',
'import bcrypt
password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())',
'Use bcrypt or Argon2 for password hashing, not MD5 or SHA1.',
'bcrypt and Argon2 are designed for password hashing with adaptive cost. MD5 is fast and vulnerable to rainbow tables.',
'python',
'CWE',
'https://cwe.mitre.org/data/definitions/327.html',
1.0,
ARRAY['crypto', 'hashing', 'password', 'bcrypt']),

-- SSRF
('CWE-918', 'Server-Side Request Forgery (SSRF)',
'import requests
url = request.args.get("url")
response = requests.get(url)',
'import requests
from urllib.parse import urlparse

url = request.args.get("url")
parsed = urlparse(url)

# Whitelist allowed domains
ALLOWED_DOMAINS = ["api.example.com", "trusted.service.com"]
if parsed.hostname not in ALLOWED_DOMAINS:
    raise ValueError("Domain not allowed")

response = requests.get(url, timeout=5)',
'Validate and whitelist URLs before making requests to prevent SSRF attacks.',
'SSRF allows attackers to make requests to internal services. Domain whitelisting prevents unauthorized access.',
'python',
'OWASP',
'https://owasp.org/www-community/attacks/Server_Side_Request_Forgery',
0.9,
ARRAY['ssrf', 'requests', 'validation', 'whitelist']);

-- ============================================================================
-- VIEWS: Convenience views for common queries
-- ============================================================================

-- Active vulnerabilities view
CREATE VIEW active_vulnerabilities AS
SELECT 
    a.id,
    a.cve_id,
    a.priority,
    a.status,
    a.created_at,
    a.affected_services,
    a.remediation_strategy,
    COUNT(p.id) as patch_count,
    MAX(p.created_at) as latest_patch_created
FROM apvs a
LEFT JOIN patches p ON a.cve_id = p.cve_id
WHERE a.status NOT IN ('patched', 'ignored')
GROUP BY a.id
ORDER BY 
    CASE a.priority 
        WHEN 'critical' THEN 1 
        WHEN 'high' THEN 2 
        WHEN 'medium' THEN 3 
        ELSE 4 
    END,
    a.created_at DESC;

COMMENT ON VIEW active_vulnerabilities IS 'Active (unpatched) vulnerabilities with patch counts';

-- Patch success metrics view
CREATE VIEW patch_success_metrics AS
SELECT 
    strategy,
    COUNT(*) as total_patches,
    COUNT(*) FILTER (WHERE validation_status = 'passed') as passed,
    COUNT(*) FILTER (WHERE validation_status = 'failed') as failed,
    COUNT(*) FILTER (WHERE validation_status = 'merged') as merged,
    ROUND(AVG(generation_duration_ms), 2) as avg_generation_ms,
    ROUND(AVG(validation_duration_ms), 2) as avg_validation_ms,
    ROUND(AVG(llm_cost_usd), 4) as avg_cost_usd
FROM patches
GROUP BY strategy;

COMMENT ON VIEW patch_success_metrics IS 'Patch success metrics by remediation strategy';

-- ============================================================================
-- FUNCTIONS: Utility functions
-- ============================================================================

-- Function to update patch statistics in vulnerability_fixes
CREATE OR REPLACE FUNCTION update_fix_usage_stats()
RETURNS TRIGGER AS $$
BEGIN
    -- This would be called when a patch using a specific fix example succeeds
    -- Implementation depends on how we track which examples were used
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for vulnerability_fixes updated_at
CREATE TRIGGER update_vulnerability_fixes_updated_at
    BEFORE UPDATE ON vulnerability_fixes
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- SECURITY: Row-level security (optional, for multi-tenancy future)
-- ============================================================================

-- Enable RLS on sensitive tables (disabled by default, enable when needed)
-- ALTER TABLE audit_log ENABLE ROW LEVEL SECURITY;
-- CREATE POLICY audit_log_read_policy ON audit_log FOR SELECT USING (true);
-- CREATE POLICY audit_log_insert_policy ON audit_log FOR INSERT WITH CHECK (true);

-- ============================================================================
-- GRANTS: Permissions
-- ============================================================================

-- Grant permissions to maximus user
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO maximus;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO maximus;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO maximus;

-- ============================================================================
-- COMPLETION
-- ============================================================================

-- Insert marker record
INSERT INTO audit_log (event_type, event_category, event_data, source_service, severity) VALUES (
    'schema_initialized',
    'system',
    '{"version": "1.0.0", "tables": ["apvs", "patches", "audit_log", "vulnerability_fixes"], "seed_examples": 7}'::jsonb,
    'init_script',
    'info'
);

-- Success message
DO $$
BEGIN
    RAISE NOTICE '✅ MAXIMUS Adaptive Immunity Database Schema initialized successfully';
    RAISE NOTICE '   - Tables: apvs, patches, audit_log, vulnerability_fixes';
    RAISE NOTICE '   - Views: active_vulnerabilities, patch_success_metrics';
    RAISE NOTICE '   - Seed data: 7 few-shot examples';
    RAISE NOTICE '   - Indexes: Optimized for query performance';
    RAISE NOTICE '   - Ready for Oráculo-Eureka integration';
END $$;
