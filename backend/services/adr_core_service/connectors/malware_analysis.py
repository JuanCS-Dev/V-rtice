"""Malware Analysis Connector for file hash and sample analysis.

This module provides a connector to the Malware Analysis Service. It is used
to analyze file hashes, submit samples for sandboxing, and retrieve detailed
analysis reports including YARA matches and behavioral data.
"""

import httpx
import logging
from typing import Dict, Any, Optional
from datetime import datetime

from .base import BaseConnector

logger = logging.getLogger(__name__)


class MalwareAnalysisConnector(BaseConnector):
    """Connects to the Malware Analysis Service for in-depth file analysis.

    This connector facilitates the analysis of file hashes and the submission
    of file samples. It enriches threat data with malware family information,
    YARA rule matches, and behavioral analysis results from a sandbox environment.

    Attributes:
        cache (Dict[str, Any]): An in-memory cache for hash analysis results.
    """

    def __init__(self, base_url: str = "http://localhost:8006"):
        """Initializes the MalwareAnalysisConnector.

        Args:
            base_url (str, optional): The base URL of the Malware Analysis Service.
                Defaults to "http://localhost:8006".
        """
        config = {
            'endpoint': base_url,
            'timeout': 60.0,  # Analysis can be slow
            'enabled': True
        }
        super().__init__(config)
        self.cache = {}
        logger.info(f"Initialized MalwareAnalysisConnector for URL: {base_url}")

    async def health_check(self) -> bool:
        """Checks if the Malware Analysis Service is reachable and healthy.

        Returns:
            bool: True if the service is healthy, False otherwise.
        """
        try:
            response = await self.client.get(f"{self.endpoint}/health")
            response.raise_for_status()
            return response.status_code == 200
        except (httpx.HTTPError, Exception) as e:
            logger.error(f"Malware Analysis Service health check failed: {e}")
            return False

    async def analyze_hash(self, file_hash: str) -> Optional[Dict[str, Any]]:
        """Analyzes a file hash (MD5, SHA1, or SHA256) for known malware.

        Args:
            file_hash (str): The file hash to analyze.

        Returns:
            Optional[Dict[str, Any]]: A dictionary with analysis results, or None.
        """
        if file_hash in self.cache:
            logger.debug(f"Cache hit for hash: {file_hash}")
            return self.cache[file_hash]

        try:
            response = await self._make_request(
                'POST',
                '/api/malware/analyze',
                data={'hash': file_hash}
            )

            if response:
                enriched_data = self._format_response(response, file_hash)
                self.cache[file_hash] = enriched_data
                logger.info(
                    f"Malware analysis for {file_hash}: Malware={enriched_data['is_malware']}, "
                    f"Family={enriched_data['malware_family']}"
                )
                return enriched_data
            return None
        except Exception as e:
            logger.error(f"Error analyzing hash {file_hash}: {e}")
            return None

    def _format_response(self, response: Dict, file_hash: str) -> Dict[str, Any]:
        """Formats the raw service response into a structured dictionary."""
        return {
            'hash': file_hash,
            'is_malware': response.get('is_malware', False),
            'confidence': response.get('confidence', 0),
            'malware_family': response.get('malware_family'),
            'threat_name': response.get('threat_name'),
            'yara_matches': response.get('yara_matches', []),
            'av_detections': response.get('av_detections', {}),
            'behaviors': response.get('behaviors', []),
            'file_type': response.get('file_type'),
            'file_size': response.get('file_size'),
            'threat_score': response.get('threat_score', 0),
            'severity': response.get('severity', 'unknown'),
            'analyzed_at': datetime.utcnow().isoformat(),
            'enriched_by': 'malware_analysis_service'
        }

    async def enrich(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Enriches a threat detection object with malware analysis.

        Extracts file hashes from the detection data, analyzes them, and adds
        the results to the threat's `enriched_context`. Also adjusts the threat
        score based on the findings.

        Args:
            data (Dict[str, Any]): The threat detection object to enrich.

        Returns:
            Dict[str, Any]: The enriched threat detection object.
        """
        hashes_to_analyze = self._extract_hashes_from_threat(data)
        malware_results = {}

        for hash_val in hashes_to_analyze:
            result = await self.analyze_hash(hash_val)
            if result:
                malware_results[hash_val] = result

        if 'enriched_context' not in data:
            data['enriched_context'] = {}
        data['enriched_context']['malware_analysis'] = malware_results

        if malware_results:
            self._adjust_threat_score(data, malware_results)

        return data

    def _extract_hashes_from_threat(self, data: Dict[str, Any]) -> set:
        """Extracts unique file hashes from a threat data dictionary."""
        hashes = set()
        if 'file_hash' in data and isinstance(data['file_hash'], str):
            hashes.add(data['file_hash'])

        for indicator in data.get('indicators', []):
            if isinstance(indicator, dict) and indicator.get('type') == 'hash':
                hashes.add(indicator.get('value'))
            elif isinstance(indicator, str) and len(indicator) in [32, 40, 64]:
                hashes.add(indicator)
        return hashes

    def _adjust_threat_score(self, data: Dict[str, Any], malware_results: Dict[str, Any]):
        """Adjusts threat score based on malware analysis results."""
        malware_scores = [
            result['threat_score']
            for result in malware_results.values()
            if result.get('is_malware')
        ]

        if not malware_scores:
            return

        max_malware_score = max(malware_scores)
        original_score = data.get('threat_score', 0)
        # Heavily weight malware score (80% malware score, 20% original)
        adjusted_score = int(max_malware_score * 0.8 + original_score * 0.2)

        data['threat_score_original'] = original_score
        data['threat_score'] = adjusted_score
        data['threat_score_adjusted_by'] = 'malware_analysis'

        if adjusted_score >= 80:
            data['severity'] = 'critical'
        elif adjusted_score >= 60:
            data['severity'] = 'high'

        logger.info(
            f"Threat score adjusted: {original_score} -> {adjusted_score} based on malware analysis."
        )

        families = [r['malware_family'] for r in malware_results.values() if r.get('malware_family')]
        if families:
            data['malware_families'] = list(set(families))

    async def get_yara_rules(self) -> Optional[List[Dict]]:
        """Retrieves the list of available YARA rules from the service.

        Returns:
            Optional[List[Dict]]: A list of YARA rules, or None on failure.
        """
        try:
            response = await self._make_request('GET', '/api/yara/rules')
            return response.get('rules', []) if response else None
        except Exception as e:
            logger.error(f"Error getting YARA rules: {e}")
            return None

    async def submit_sample(self, file_path: str) -> Optional[str]:
        """Submits a file sample for sandboxed analysis.

        Args:
            file_path (str): The local path to the file to submit.

        Returns:
            Optional[str]: The analysis job ID if submission is successful, else None.
        """
        try:
            with open(file_path, 'rb') as f:
                files = {'file': (file_path, f.read())}
                response = await self.client.post(
                    f"{self.endpoint}/api/malware/submit",
                    files=files,
                    timeout=120.0  # Allow more time for upload
                )
                response.raise_for_status()
                result = response.json()
                return result.get('job_id')
        except FileNotFoundError:
            logger.error(f"File not found for submission: {file_path}")
            return None
        except Exception as e:
            logger.error(f"Error submitting sample {file_path}: {e}")
            return None