"""HCL Executor Service - Main FastAPI Application.

This service is responsible for executing action plans generated by the HCL Planner.
It listens on a Kafka topic for new action plans, validates them, and then uses
a Kubernetes controller to apply the changes to the cluster infrastructure.

It also provides manual override endpoints for direct intervention.

- Consumes action plans from the `system.actions` Kafka topic.
- Executes actions (e.g., scaling, resource adjustment) via the Kubernetes API.
- Provides a REST API for manual actions and status monitoring.
"""

import logging
import os
import json
from contextlib import asynccontextmanager
from typing import Dict, List, Optional

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

from .k8s_controller import KubernetesController
from .action_executor import ActionExecutor

# Conditional Kafka import
try:
    from aiokafka import AIOKafkaConsumer
    KAFKA_AVAILABLE = True
except ImportError:
    KAFKA_AVAILABLE = False

# ============================================================================
# Configuration and Initialization
# ============================================================================

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

KAFKA_BROKERS = os.getenv("KAFKA_BROKERS", "localhost:9092")
K8S_NAMESPACE = os.getenv("K8S_NAMESPACE", "default")
DRY_RUN = os.getenv("DRY_RUN", "false").lower() == "true"

state: Dict[str, Any] = {}

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Manages the application's lifespan for startup and shutdown events."""
    logger.info("Starting HCL Executor Service...")
    state['k8s_controller'] = KubernetesController(namespace=K8S_NAMESPACE)
    state['action_executor'] = ActionExecutor(state['k8s_controller'], dry_run=DRY_RUN)
    
    # Kafka consumer setup would go here in a full implementation
    
    yield
    
    logger.info("Shutting down HCL Executor Service...")

app = FastAPI(
    title="HCL Executor Service",
    description="Executes HCL decisions on the Kubernetes cluster.",
    version="1.0.0",
    lifespan=lifespan
)

# ============================================================================
# Pydantic Models
# ============================================================================

class ActionPlan(BaseModel):
    """Request model for manually executing an action plan."""
    decision_id: str
    actions: List[Dict[str, Any]]

class ScaleRequest(BaseModel):
    """Request model for manually scaling a service."""
    service: str
    target_replicas: int

# ============================================================================
# API Endpoints
# ============================================================================

@app.get("/health")
async def health_check():
    """Provides a basic health check of the service."""
    return {"status": "healthy", "service": "hcl_executor", "dry_run": DRY_RUN}

@app.post("/execute", tags=["Execution"])
async def execute_action_plan(plan: ActionPlan):
    """Manually triggers the execution of a given action plan.

    This endpoint is typically used for testing or manual overrides.

    Args:
        plan (ActionPlan): The action plan to be executed.

    Returns:
        Dict: The result of the execution.
    """
    executor: ActionExecutor = state['action_executor']
    try:
        result = await executor.execute_action_plan(plan.decision_id, plan.actions)
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/scale", tags=["Manual Actions"])
async def scale_service(request: ScaleRequest):
    """Manually scales a deployment to a specific number of replicas.

    Args:
        request (ScaleRequest): The details of the scaling operation.

    Returns:
        Dict: The result from the Kubernetes controller.
    """
    executor: ActionExecutor = state['action_executor']
    action = {"type": "scale_service", "service": request.service, "target_replicas": request.target_replicas}
    try:
        return await executor._execute_single_action(action)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8004)