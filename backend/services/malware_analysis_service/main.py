"""
Malware Analysis Service - OFFLINE FIRST
Sistema primário: Análise offline com heurísticas e database local
Sistema secundário (opcional): APIs externas como VirusTotal

ZERO TRUST em APIs externas - tudo pode ser feito offline
"""

from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import httpx
import hashlib
import os
import magic
from datetime import datetime
from typing import Optional, List, Dict
import asyncio
from offline_malware_engine import OfflineMalwareEngine

app = FastAPI(title="Malware Analysis Service - Offline First")

# Initialize offline engine
offline_engine = OfflineMalwareEngine()

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# API Keys (OPCIONAL - sistema funciona 100% sem elas)
USE_EXTERNAL_APIS = os.getenv("USE_EXTERNAL_APIS", "false").lower() == "true"
VIRUSTOTAL_API_KEY = os.getenv("VIRUSTOTAL_API_KEY", "")
HYBRID_ANALYSIS_API_KEY = os.getenv("HYBRID_ANALYSIS_API_KEY", "")

# Models
class HashAnalysisRequest(BaseModel):
    hash_value: str
    hash_type: str = "auto"  # auto, md5, sha1, sha256

class URLAnalysisRequest(BaseModel):
    url: str

class AnalysisResponse(BaseModel):
    analysis_id: str
    target: str
    target_type: str  # file, hash, url
    threat_score: int  # 0-100
    is_malicious: bool
    malware_families: List[str]
    file_type: Optional[str]
    file_size: Optional[int]
    hashes: Optional[Dict[str, str]]
    detections: Dict[str, int]  # malicious, suspicious, clean
    vendors: List[dict]  # Lista de detecções por vendor
    behavior: Optional[dict]
    network_activity: Optional[List[dict]]
    recommendations: List[str]
    timestamp: str

# Funções auxiliares
def calculate_hash(file_content: bytes, hash_type: str = "all") -> dict:
    """Calcula hashes do arquivo"""
    hashes = {}

    if hash_type in ["all", "md5"]:
        hashes["md5"] = hashlib.md5(file_content).hexdigest()

    if hash_type in ["all", "sha1"]:
        hashes["sha1"] = hashlib.sha1(file_content).hexdigest()

    if hash_type in ["all", "sha256"]:
        hashes["sha256"] = hashlib.sha256(file_content).hexdigest()

    return hashes

def detect_hash_type(hash_value: str) -> str:
    """Detecta o tipo de hash"""
    length = len(hash_value)

    if length == 32:
        return "md5"
    elif length == 40:
        return "sha1"
    elif length == 64:
        return "sha256"
    else:
        return "unknown"

async def check_virustotal_hash(hash_value: str) -> dict:
    """Consulta VirusTotal para análise de hash"""
    if not VIRUSTOTAL_API_KEY:
        return {"error": "API key not configured", "available": False}

    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.get(
                f"https://www.virustotal.com/api/v3/files/{hash_value}",
                headers={"x-apikey": VIRUSTOTAL_API_KEY}
            )

            if response.status_code == 200:
                data = response.json()["data"]
                attributes = data.get("attributes", {})
                stats = attributes.get("last_analysis_stats", {})

                return {
                    "available": True,
                    "malicious": stats.get("malicious", 0),
                    "suspicious": stats.get("suspicious", 0),
                    "harmless": stats.get("harmless", 0),
                    "undetected": stats.get("undetected", 0),
                    "total_vendors": sum(stats.values()),
                    "file_type": attributes.get("type_description", "Unknown"),
                    "file_size": attributes.get("size", 0),
                    "names": attributes.get("names", []),
                    "magic": attributes.get("magic", ""),
                    "first_submission": attributes.get("first_submission_date", None),
                    "last_analysis": attributes.get("last_analysis_date", None),
                    "tags": attributes.get("tags", []),
                    "popular_threat_category": attributes.get("popular_threat_category", ""),
                    "crowdsourced_ids_stats": attributes.get("crowdsourced_ids_stats", {}),
                    "sandbox_verdicts": attributes.get("sandbox_verdicts", {}),
                    "last_analysis_results": attributes.get("last_analysis_results", {})
                }
            elif response.status_code == 404:
                return {"available": True, "found": False, "message": "Hash not found in VirusTotal"}
    except Exception as e:
        return {"error": str(e), "available": False}

    return {"available": False}

async def check_virustotal_url(url: str) -> dict:
    """Consulta VirusTotal para análise de URL"""
    if not VIRUSTOTAL_API_KEY:
        return {"error": "API key not configured", "available": False}

    try:
        # Primeiro, submit a URL
        async with httpx.AsyncClient(timeout=30.0) as client:
            # Encode URL in base64 URL-safe
            import base64
            url_id = base64.urlsafe_b64encode(url.encode()).decode().strip("=")

            response = await client.get(
                f"https://www.virustotal.com/api/v3/urls/{url_id}",
                headers={"x-apikey": VIRUSTOTAL_API_KEY}
            )

            if response.status_code == 200:
                data = response.json()["data"]
                attributes = data.get("attributes", {})
                stats = attributes.get("last_analysis_stats", {})

                return {
                    "available": True,
                    "malicious": stats.get("malicious", 0),
                    "suspicious": stats.get("suspicious", 0),
                    "harmless": stats.get("harmless", 0),
                    "undetected": stats.get("undetected", 0),
                    "total_vendors": sum(stats.values()),
                    "categories": attributes.get("categories", {}),
                    "last_final_url": attributes.get("last_final_url", url),
                    "reputation": attributes.get("reputation", 0),
                    "tags": attributes.get("tags", []),
                    "times_submitted": attributes.get("times_submitted", 0),
                    "last_analysis_results": attributes.get("last_analysis_results", {})
                }
    except Exception as e:
        return {"error": str(e), "available": False}

    return {"available": False}

def analyze_file_locally(file_content: bytes, filename: str) -> dict:
    """Análise local básica do arquivo"""
    try:
        # Detecção de tipo MIME
        file_type = magic.from_buffer(file_content, mime=True)

        # Detecção de padrões suspeitos
        suspicious_patterns = []

        # Verifica strings suspeitas (exemplo básico)
        content_str = file_content.decode('latin-1', errors='ignore').lower()

        suspicious_keywords = [
            'eval(', 'exec(', 'system(', 'shell_exec', 'passthru',
            'base64_decode', 'gzinflate', 'str_rot13',
            'powershell', 'cmd.exe', '/c ', 'wget ', 'curl ',
            'nc -', 'netcat', '/bin/sh', '/bin/bash'
        ]

        for keyword in suspicious_keywords:
            if keyword in content_str:
                suspicious_patterns.append(keyword)

        # Entropia (arquivos com alta entropia podem estar compactados/criptografados)
        import math
        from collections import Counter

        byte_counts = Counter(file_content)
        entropy = 0
        for count in byte_counts.values():
            probability = count / len(file_content)
            entropy -= probability * math.log2(probability)

        is_high_entropy = entropy > 7.5  # Arquivos normais têm ~6-7

        return {
            "file_type": file_type,
            "file_size": len(file_content),
            "suspicious_patterns": suspicious_patterns,
            "entropy": round(entropy, 2),
            "high_entropy": is_high_entropy,
            "analysis": {
                "local_verdict": "suspicious" if (suspicious_patterns or is_high_entropy) else "unknown"
            }
        }
    except Exception as e:
        return {"error": str(e)}

def generate_recommendations(is_malicious: bool, threat_score: int, malware_families: List[str]) -> List[str]:
    """Gera recomendações baseadas na análise"""
    recommendations = []

    if is_malicious:
        recommendations.append("🚨 QUARANTINE: Arquivo identificado como malicioso")
        recommendations.append("🔥 DELETE: Remover imediatamente do sistema")
        recommendations.append("🔍 INVESTIGATE: Verificar outros arquivos relacionados")
        recommendations.append("📋 ISOLATE: Isolar sistemas comprometidos")

        if threat_score >= 80:
            recommendations.append("⚠️ CRITICAL: Ameaça crítica detectada")
            recommendations.append("📞 ALERT: Notificar equipe de resposta a incidentes")

        if malware_families:
            recommendations.append(f"🦠 Malware identificado: {', '.join(malware_families[:3])}")
    elif threat_score >= 40:
        recommendations.append("⚠️ SUSPICIOUS: Arquivo suspeito detectado")
        recommendations.append("🔬 DEEP ANALYSIS: Análise em sandbox recomendada")
        recommendations.append("🔍 MONITOR: Monitorar comportamento se executado")
    else:
        recommendations.append("✅ CLEAN: Arquivo aparenta ser limpo")
        recommendations.append("📊 SAFE: Nenhuma ameaça significativa detectada")

    return recommendations

@app.get("/")
async def root():
    db_stats = offline_engine.get_database_stats()
    return {
        "service": "Malware Analysis Service - Offline First",
        "status": "online",
        "version": "2.0.0",
        "mode": "offline-first" if not USE_EXTERNAL_APIS else "hybrid",
        "capabilities": {
            "file_analysis": True,
            "hash_lookup": True,
            "url_analysis": True,
            "offline_analysis": True,
            "heuristic_engine": True,
            "local_database": True,
            "external_apis": USE_EXTERNAL_APIS
        },
        "database": db_stats
    }

@app.get("/api/malware/database/stats")
async def get_database_stats():
    """Retorna estatísticas do database local de malware"""
    return offline_engine.get_database_stats()

@app.post("/api/malware/analyze-file", response_model=AnalysisResponse)
async def analyze_file(file: UploadFile = File(...)):
    """
    Analisa um arquivo para detecção de malware - OFFLINE FIRST
    1. Usa offline engine (heurísticas + database local)
    2. Opcionalmente complementa com APIs externas (se habilitado)
    """
    # Ler conteúdo do arquivo
    file_content = await file.read()

    # ============================
    # FASE 1: ANÁLISE OFFLINE (PRIMÁRIA)
    # ============================
    offline_result = offline_engine.analyze_file(file_content, file.filename)

    hashes = offline_result.get("hashes", calculate_hash(file_content))
    threat_score = offline_result.get("threat_score", 0)
    is_malicious = offline_result.get("is_malicious", False)
    malware_families = offline_result.get("malware_family", [])

    # Análise local básica (para file_type)
    local_analysis = analyze_file_locally(file_content, file.filename)

    vendors = [{
        "name": "Offline Engine",
        "category": "local_analysis",
        "result": f"Threat Score: {threat_score}",
        "confidence": offline_result.get("confidence", "medium")
    }]

    detections = {
        "malicious": 1 if is_malicious else 0,
        "suspicious": 1 if threat_score >= 40 and not is_malicious else 0,
        "clean": 1 if threat_score < 40 else 0
    }

    # ============================
    # FASE 2: APIs EXTERNAS (OPCIONAL - apenas se habilitado)
    # ============================
    if USE_EXTERNAL_APIS and VIRUSTOTAL_API_KEY:
        vt_result = await check_virustotal_hash(hashes["sha256"])

        if vt_result.get("available") and vt_result.get("found", True):
            malicious = vt_result.get("malicious", 0)
            suspicious = vt_result.get("suspicious", 0)
            harmless = vt_result.get("harmless", 0)
            total = vt_result.get("total_vendors", 1)

            # Combinar scores (offline 60%, virustotal 40%)
            vt_score = int(((malicious * 100) + (suspicious * 50)) / total) if total > 0 else 0
            threat_score = int(threat_score * 0.6 + vt_score * 0.4)
            is_malicious = is_malicious or (malicious > 0)

            # Adicionar malware families do VT
            if vt_result.get("popular_threat_category"):
                if vt_result["popular_threat_category"] not in malware_families:
                    malware_families.append(vt_result["popular_threat_category"])

            # Adicionar vendors do VT
            for vendor_name, result in vt_result.get("last_analysis_results", {}).items():
                if result.get("category") in ["malicious", "suspicious"]:
                    vendors.append({
                        "name": vendor_name,
                        "category": result.get("category"),
                        "result": result.get("result", "")
                    })

            detections = {
                "malicious": malicious + detections["malicious"],
                "suspicious": suspicious + detections["suspicious"],
                "clean": harmless + detections["clean"]
            }

    recommendations = generate_recommendations(is_malicious, threat_score, malware_families)

    # Adicionar informação sobre modo offline
    if not USE_EXTERNAL_APIS:
        recommendations.insert(0, "ℹ️ OFFLINE MODE: Análise baseada apenas em heurísticas locais")

    analysis_id = f"MA-{datetime.now().strftime('%Y%m%d%H%M%S')}-{hashes['md5'][:8]}"

    return AnalysisResponse(
        analysis_id=analysis_id,
        target=file.filename,
        target_type="file",
        threat_score=threat_score,
        is_malicious=is_malicious,
        malware_families=malware_families[:5],
        file_type=local_analysis.get("file_type", "Unknown"),
        file_size=len(file_content),
        hashes=hashes,
        detections=detections,
        vendors=vendors[:10],  # Top 10 vendors
        behavior={"offline_indicators": offline_result.get("indicators", [])},
        network_activity=None,
        recommendations=recommendations,
        timestamp=datetime.now().isoformat()
    )

@app.post("/api/malware/analyze-hash", response_model=AnalysisResponse)
async def analyze_hash(request: HashAnalysisRequest):
    """
    Analisa um hash (MD5/SHA1/SHA256) para verificar se é malware conhecido - OFFLINE FIRST
    1. Busca no database local
    2. Opcionalmente consulta APIs externas (se habilitado)
    """
    hash_value = request.hash_value.lower()
    hash_type = request.hash_type

    # Auto-detect hash type
    if hash_type == "auto":
        hash_type = detect_hash_type(hash_value)

    if hash_type == "unknown":
        raise HTTPException(status_code=400, detail="Tipo de hash inválido")

    # ============================
    # FASE 1: BUSCA OFFLINE (PRIMÁRIA)
    # ============================
    offline_result = offline_engine.check_hash(hash_value, hash_type)

    if offline_result.get("found"):
        # Hash encontrado no database local
        return AnalysisResponse(
            analysis_id=f"MA-{datetime.now().strftime('%Y%m%d%H%M%S')}-{hash_value[:8]}",
            target=hash_value,
            target_type="hash",
            threat_score=offline_result["threat_score"],
            is_malicious=offline_result["is_malicious"],
            malware_families=[offline_result["malware_family"]],
            file_type=None,
            file_size=None,
            hashes={hash_type: hash_value},
            detections={"malicious": 1, "suspicious": 0, "clean": 0},
            vendors=[{
                "name": "Local Database",
                "category": "malicious",
                "result": offline_result["malware_family"]
            }],
            behavior={"description": offline_result.get("description", "")},
            network_activity=None,
            recommendations=generate_recommendations(True, 100, [offline_result["malware_family"]]),
            timestamp=datetime.now().isoformat()
        )

    # ============================
    # FASE 2: APIs EXTERNAS (OPCIONAL)
    # ============================
    if USE_EXTERNAL_APIS and VIRUSTOTAL_API_KEY:
        vt_result = await check_virustotal_hash(hash_value)

        if vt_result.get("available") and vt_result.get("found", True):
            # Processar resultados do VT
            malicious = vt_result.get("malicious", 0)
            suspicious = vt_result.get("suspicious", 0)
            harmless = vt_result.get("harmless", 0)
            total = vt_result.get("total_vendors", 1)

            threat_score = int(((malicious * 100) + (suspicious * 50)) / total) if total > 0 else 0
            is_malicious = malicious > 0 or threat_score >= 60

            malware_families = []
            if vt_result.get("popular_threat_category"):
                malware_families.append(vt_result["popular_threat_category"])

            vendors = []
            for vendor_name, result in vt_result.get("last_analysis_results", {}).items():
                if result.get("category") in ["malicious", "suspicious"]:
                    vendors.append({
                        "name": vendor_name,
                        "category": result.get("category"),
                        "result": result.get("result", "")
                    })

            recommendations = generate_recommendations(is_malicious, threat_score, malware_families)

            return AnalysisResponse(
                analysis_id=f"MA-{datetime.now().strftime('%Y%m%d%H%M%S')}-{hash_value[:8]}",
                target=hash_value,
                target_type="hash",
                threat_score=threat_score,
                is_malicious=is_malicious,
                malware_families=malware_families[:5],
                file_type=vt_result.get("file_type"),
                file_size=vt_result.get("file_size"),
                hashes={hash_type: hash_value},
                detections={"malicious": malicious, "suspicious": suspicious, "clean": harmless},
                vendors=vendors[:10],
                behavior=None,
                network_activity=None,
                recommendations=recommendations,
                timestamp=datetime.now().isoformat()
            )

    # Hash não encontrado em lugar nenhum
    return AnalysisResponse(
        analysis_id=f"MA-{datetime.now().strftime('%Y%m%d%H%M%S')}-{hash_value[:8]}",
        target=hash_value,
        target_type="hash",
        threat_score=0,
        is_malicious=False,
        malware_families=[],
        file_type=None,
        file_size=None,
        hashes={hash_type: hash_value},
        detections={"malicious": 0, "suspicious": 0, "clean": 0},
        vendors=[],
        behavior=None,
        network_activity=None,
        recommendations=["ℹ️ Hash não encontrado no database local" + (" nem em APIs externas" if USE_EXTERNAL_APIS else "")],
        timestamp=datetime.now().isoformat()
    )

@app.post("/api/malware/analyze-url", response_model=AnalysisResponse)
async def analyze_url(request: URLAnalysisRequest):
    """
    Analisa uma URL para detecção de phishing e malware
    Nota: Análise de URL depende de APIs externas (VirusTotal) ou análise local básica
    """
    url = request.url

    # Análise local básica de URL
    threat_score = 0
    is_malicious = False
    malware_families = []
    indicators = []

    # Heurísticas locais para URLs
    url_lower = url.lower()

    # Domínios suspeitos
    suspicious_tlds = ['.tk', '.ml', '.ga', '.cf', '.gq', '.xyz', '.top']
    if any(url_lower.endswith(tld) for tld in suspicious_tlds):
        threat_score += 30
        indicators.append("TLD suspeito detectado")

    # Palavras-chave suspeitas
    suspicious_keywords = ['login', 'account', 'verify', 'secure', 'update', 'confirm']
    if any(kw in url_lower for kw in suspicious_keywords):
        threat_score += 20
        indicators.append("URL contém palavras de phishing")

    # URL muito longa (possível ofuscação)
    if len(url) > 150:
        threat_score += 25
        indicators.append("URL excessivamente longa")

    # IP direto ao invés de domínio
    import re
    if re.search(r'https?://\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}', url):
        threat_score += 35
        indicators.append("URL usa IP direto ao invés de domínio")

    vendors = [{
        "name": "Local URL Analysis",
        "category": "heuristic",
        "result": f"Threat Score: {threat_score}"
    }]

    # ============================
    # APIs EXTERNAS (OPCIONAL)
    # ============================
    if USE_EXTERNAL_APIS and VIRUSTOTAL_API_KEY:
        vt_result = await check_virustotal_url(url)

        if vt_result.get("available"):
            malicious = vt_result.get("malicious", 0)
            suspicious = vt_result.get("suspicious", 0)
            harmless = vt_result.get("harmless", 0)
            total = vt_result.get("total_vendors", 1)

            vt_score = int(((malicious * 100) + (suspicious * 50)) / total) if total > 0 else 0
            threat_score = int(threat_score * 0.5 + vt_score * 0.5)
            is_malicious = malicious > 0 or threat_score >= 60

            malware_families = list(vt_result.get("categories", {}).keys())[:3]

            for vendor_name, result in vt_result.get("last_analysis_results", {}).items():
                if result.get("category") in ["malicious", "suspicious"]:
                    vendors.append({
                        "name": vendor_name,
                        "category": result.get("category"),
                        "result": result.get("result", "")
                    })
    else:
        is_malicious = threat_score >= 60

    recommendations = generate_recommendations(is_malicious, threat_score, malware_families)

    if not USE_EXTERNAL_APIS:
        recommendations.insert(0, "ℹ️ OFFLINE MODE: Análise baseada apenas em heurísticas locais de URL")

    return AnalysisResponse(
        analysis_id=f"MA-{datetime.now().strftime('%Y%m%d%H%M%S')}-URL",
        target=url,
        target_type="url",
        threat_score=threat_score,
        is_malicious=is_malicious,
        malware_families=malware_families,
        file_type=None,
        file_size=None,
        hashes=None,
        detections={"malicious": 1 if is_malicious else 0, "suspicious": 1 if threat_score >= 40 else 0, "clean": 1 if threat_score < 40 else 0},
        vendors=vendors[:10],
        behavior={"local_indicators": indicators},
        network_activity=None,
        recommendations=recommendations,
        timestamp=datetime.now().isoformat()
    )

@app.get("/health")
async def health():
    return {"status": "healthy"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8014)