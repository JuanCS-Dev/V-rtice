"""
Malware Analysis Service - OFFLINE FIRST
Sistema primÃ¡rio: AnÃ¡lise offline com heurÃ­sticas e database local
Sistema secundÃ¡rio (opcional): APIs externas como VirusTotal

ZERO TRUST em APIs externas - tudo pode ser feito offline
"""

from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import httpx
import hashlib
import os
import magic
from datetime import datetime
from typing import Optional, List, Dict
import asyncio
from offline_malware_engine import OfflineMalwareEngine

app = FastAPI(title="Malware Analysis Service - Offline First")

# Initialize offline engine
offline_engine = OfflineMalwareEngine()

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# API Keys (OPCIONAL - sistema funciona 100% sem elas)
USE_EXTERNAL_APIS = os.getenv("USE_EXTERNAL_APIS", "false").lower() == "true"
VIRUSTOTAL_API_KEY = os.getenv("VIRUSTOTAL_API_KEY", "")
HYBRID_ANALYSIS_API_KEY = os.getenv("HYBRID_ANALYSIS_API_KEY", "")

# Models
class HashAnalysisRequest(BaseModel):
    hash_value: str
    hash_type: str = "auto"  # auto, md5, sha1, sha256

class URLAnalysisRequest(BaseModel):
    url: str

class AnalysisResponse(BaseModel):
    analysis_id: str
    target: str
    target_type: str  # file, hash, url
    threat_score: int  # 0-100
    is_malicious: bool
    malware_families: List[str]
    file_type: Optional[str]
    file_size: Optional[int]
    hashes: Optional[Dict[str, str]]
    detections: Dict[str, int]  # malicious, suspicious, clean
    vendors: List[dict]  # Lista de detecÃ§Ãµes por vendor
    behavior: Optional[dict]
    network_activity: Optional[List[dict]]
    recommendations: List[str]
    timestamp: str

# FunÃ§Ãµes auxiliares
def calculate_hash(file_content: bytes, hash_type: str = "all") -> dict:
    """Calcula hashes do arquivo"""
    hashes = {}

    if hash_type in ["all", "md5"]:
        hashes["md5"] = hashlib.md5(file_content).hexdigest()

    if hash_type in ["all", "sha1"]:
        hashes["sha1"] = hashlib.sha1(file_content).hexdigest()

    if hash_type in ["all", "sha256"]:
        hashes["sha256"] = hashlib.sha256(file_content).hexdigest()

    return hashes

def detect_hash_type(hash_value: str) -> str:
    """Detecta o tipo de hash"""
    length = len(hash_value)

    if length == 32:
        return "md5"
    elif length == 40:
        return "sha1"
    elif length == 64:
        return "sha256"
    else:
        return "unknown"

async def check_virustotal_hash(hash_value: str) -> dict:
    """Consulta VirusTotal para anÃ¡lise de hash"""
    if not VIRUSTOTAL_API_KEY:
        return {"error": "API key not configured", "available": False}

    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.get(
                f"https://www.virustotal.com/api/v3/files/{hash_value}",
                headers={"x-apikey": VIRUSTOTAL_API_KEY}
            )

            if response.status_code == 200:
                data = response.json()["data"]
                attributes = data.get("attributes", {})
                stats = attributes.get("last_analysis_stats", {})

                return {
                    "available": True,
                    "malicious": stats.get("malicious", 0),
                    "suspicious": stats.get("suspicious", 0),
                    "harmless": stats.get("harmless", 0),
                    "undetected": stats.get("undetected", 0),
                    "total_vendors": sum(stats.values()),
                    "file_type": attributes.get("type_description", "Unknown"),
                    "file_size": attributes.get("size", 0),
                    "names": attributes.get("names", []),
                    "magic": attributes.get("magic", ""),
                    "first_submission": attributes.get("first_submission_date", None),
                    "last_analysis": attributes.get("last_analysis_date", None),
                    "tags": attributes.get("tags", []),
                    "popular_threat_category": attributes.get("popular_threat_category", ""),
                    "crowdsourced_ids_stats": attributes.get("crowdsourced_ids_stats", {}),
                    "sandbox_verdicts": attributes.get("sandbox_verdicts", {}),
                    "last_analysis_results": attributes.get("last_analysis_results", {})
                }
            elif response.status_code == 404:
                return {"available": True, "found": False, "message": "Hash not found in VirusTotal"}
    except Exception as e:
        return {"error": str(e), "available": False}

    return {"available": False}

async def check_virustotal_url(url: str) -> dict:
    """Consulta VirusTotal para anÃ¡lise de URL"""
    if not VIRUSTOTAL_API_KEY:
        return {"error": "API key not configured", "available": False}

    try:
        # Primeiro, submit a URL
        async with httpx.AsyncClient(timeout=30.0) as client:
            # Encode URL in base64 URL-safe
            import base64
            url_id = base64.urlsafe_b64encode(url.encode()).decode().strip("=")

            response = await client.get(
                f"https://www.virustotal.com/api/v3/urls/{url_id}",
                headers={"x-apikey": VIRUSTOTAL_API_KEY}
            )

            if response.status_code == 200:
                data = response.json()["data"]
                attributes = data.get("attributes", {})
                stats = attributes.get("last_analysis_stats", {})

                return {
                    "available": True,
                    "malicious": stats.get("malicious", 0),
                    "suspicious": stats.get("suspicious", 0),
                    "harmless": stats.get("harmless", 0),
                    "undetected": stats.get("undetected", 0),
                    "total_vendors": sum(stats.values()),
                    "categories": attributes.get("categories", {}),
                    "last_final_url": attributes.get("last_final_url", url),
                    "reputation": attributes.get("reputation", 0),
                    "tags": attributes.get("tags", []),
                    "times_submitted": attributes.get("times_submitted", 0),
                    "last_analysis_results": attributes.get("last_analysis_results", {})
                }
    except Exception as e:
        return {"error": str(e), "available": False}

    return {"available": False}

def analyze_file_locally(file_content: bytes, filename: str) -> dict:
    """AnÃ¡lise local bÃ¡sica do arquivo"""
    try:
        # DetecÃ§Ã£o de tipo MIME
        file_type = magic.from_buffer(file_content, mime=True)

        # DetecÃ§Ã£o de padrÃµes suspeitos
        suspicious_patterns = []

        # Verifica strings suspeitas (exemplo bÃ¡sico)
        content_str = file_content.decode('latin-1', errors='ignore').lower()

        suspicious_keywords = [
            'eval(', 'exec(', 'system(', 'shell_exec', 'passthru',
            'base64_decode', 'gzinflate', 'str_rot13',
            'powershell', 'cmd.exe', '/c ', 'wget ', 'curl ',
            'nc -', 'netcat', '/bin/sh', '/bin/bash'
        ]

        for keyword in suspicious_keywords:
            if keyword in content_str:
                suspicious_patterns.append(keyword)

        # Entropia (arquivos com alta entropia podem estar compactados/criptografados)
        import math
        from collections import Counter

        byte_counts = Counter(file_content)
        entropy = 0
        for count in byte_counts.values():
            probability = count / len(file_content)
            entropy -= probability * math.log2(probability)

        is_high_entropy = entropy > 7.5  # Arquivos normais tÃªm ~6-7

        return {
            "file_type": file_type,
            "file_size": len(file_content),
            "suspicious_patterns": suspicious_patterns,
            "entropy": round(entropy, 2),
            "high_entropy": is_high_entropy,
            "analysis": {
                "local_verdict": "suspicious" if (suspicious_patterns or is_high_entropy) else "unknown"
            }
        }
    except Exception as e:
        return {"error": str(e)}

def generate_recommendations(is_malicious: bool, threat_score: int, malware_families: List[str]) -> List[str]:
    """Gera recomendaÃ§Ãµes baseadas na anÃ¡lise"""
    recommendations = []

    if is_malicious:
        recommendations.append("ðŸš¨ QUARANTINE: Arquivo identificado como malicioso")
        recommendations.append("ðŸ”¥ DELETE: Remover imediatamente do sistema")
        recommendations.append("ðŸ” INVESTIGATE: Verificar outros arquivos relacionados")
        recommendations.append("ðŸ“‹ ISOLATE: Isolar sistemas comprometidos")

        if threat_score >= 80:
            recommendations.append("âš ï¸ CRITICAL: AmeaÃ§a crÃ­tica detectada")
            recommendations.append("ðŸ“ž ALERT: Notificar equipe de resposta a incidentes")

        if malware_families:
            recommendations.append(f"ðŸ¦  Malware identificado: {', '.join(malware_families[:3])}")
    elif threat_score >= 40:
        recommendations.append("âš ï¸ SUSPICIOUS: Arquivo suspeito detectado")
        recommendations.append("ðŸ”¬ DEEP ANALYSIS: AnÃ¡lise em sandbox recomendada")
        recommendations.append("ðŸ” MONITOR: Monitorar comportamento se executado")
    else:
        recommendations.append("âœ… CLEAN: Arquivo aparenta ser limpo")
        recommendations.append("ðŸ“Š SAFE: Nenhuma ameaÃ§a significativa detectada")

    return recommendations

@app.get("/")
async def root():
    db_stats = offline_engine.get_database_stats()
    return {
        "service": "Malware Analysis Service - Offline First",
        "status": "online",
        "version": "2.0.0",
        "mode": "offline-first" if not USE_EXTERNAL_APIS else "hybrid",
        "capabilities": {
            "file_analysis": True,
            "hash_lookup": True,
            "url_analysis": True,
            "offline_analysis": True,
            "heuristic_engine": True,
            "local_database": True,
            "external_apis": USE_EXTERNAL_APIS
        },
        "database": db_stats
    }

@app.get("/api/malware/database/stats")
async def get_database_stats():
    """Retorna estatÃ­sticas do database local de malware"""
    return offline_engine.get_database_stats()

@app.post("/api/malware/analyze-file", response_model=AnalysisResponse)
async def analyze_file(file: UploadFile = File(...)):
    """
    Analisa um arquivo para detecÃ§Ã£o de malware - OFFLINE FIRST
    1. Usa offline engine (heurÃ­sticas + database local)
    2. Opcionalmente complementa com APIs externas (se habilitado)
    """
    # Ler conteÃºdo do arquivo
    file_content = await file.read()

    # ============================
    # FASE 1: ANÃLISE OFFLINE (PRIMÃRIA)
    # ============================
    offline_result = offline_engine.analyze_file(file_content, file.filename)

    hashes = offline_result.get("hashes", calculate_hash(file_content))
    threat_score = offline_result.get("threat_score", 0)
    is_malicious = offline_result.get("is_malicious", False)
    malware_families = offline_result.get("malware_family", [])

    # AnÃ¡lise local bÃ¡sica (para file_type)
    local_analysis = analyze_file_locally(file_content, file.filename)

    vendors = [{
        "name": "Offline Engine",
        "category": "local_analysis",
        "result": f"Threat Score: {threat_score}",
        "confidence": offline_result.get("confidence", "medium")
    }]

    detections = {
        "malicious": 1 if is_malicious else 0,
        "suspicious": 1 if threat_score >= 40 and not is_malicious else 0,
        "clean": 1 if threat_score < 40 else 0
    }

    # ============================
    # FASE 2: APIs EXTERNAS (OPCIONAL - apenas se habilitado)
    # ============================
    if USE_EXTERNAL_APIS and VIRUSTOTAL_API_KEY:
        vt_result = await check_virustotal_hash(hashes["sha256"])

        if vt_result.get("available") and vt_result.get("found", True):
            malicious = vt_result.get("malicious", 0)
            suspicious = vt_result.get("suspicious", 0)
            harmless = vt_result.get("harmless", 0)
            total = vt_result.get("total_vendors", 1)

            # Combinar scores (offline 60%, virustotal 40%)
            vt_score = int(((malicious * 100) + (suspicious * 50)) / total) if total > 0 else 0
            threat_score = int(threat_score * 0.6 + vt_score * 0.4)
            is_malicious = is_malicious or (malicious > 0)

            # Adicionar malware families do VT
            if vt_result.get("popular_threat_category"):
                if vt_result["popular_threat_category"] not in malware_families:
                    malware_families.append(vt_result["popular_threat_category"])

            # Adicionar vendors do VT
            for vendor_name, result in vt_result.get("last_analysis_results", {}).items():
                if result.get("category") in ["malicious", "suspicious"]:
                    vendors.append({
                        "name": vendor_name,
                        "category": result.get("category"),
                        "result": result.get("result", "")
                    })

            detections = {
                "malicious": malicious + detections["malicious"],
                "suspicious": suspicious + detections["suspicious"],
                "clean": harmless + detections["clean"]
            }

    recommendations = generate_recommendations(is_malicious, threat_score, malware_families)

    # Adicionar informaÃ§Ã£o sobre modo offline
    if not USE_EXTERNAL_APIS:
        recommendations.insert(0, "â„¹ï¸ OFFLINE MODE: AnÃ¡lise baseada apenas em heurÃ­sticas locais")

    analysis_id = f"MA-{datetime.now().strftime('%Y%m%d%H%M%S')}-{hashes['md5'][:8]}"

    return AnalysisResponse(
        analysis_id=analysis_id,
        target=file.filename,
        target_type="file",
        threat_score=threat_score,
        is_malicious=is_malicious,
        malware_families=malware_families[:5],
        file_type=local_analysis.get("file_type", "Unknown"),
        file_size=len(file_content),
        hashes=hashes,
        detections=detections,
        vendors=vendors[:10],  # Top 10 vendors
        behavior={"offline_indicators": offline_result.get("indicators", [])},
        network_activity=None,
        recommendations=recommendations,
        timestamp=datetime.now().isoformat()
    )

@app.post("/api/malware/analyze-hash", response_model=AnalysisResponse)
async def analyze_hash(request: HashAnalysisRequest):
    """
    Analisa um hash (MD5/SHA1/SHA256) para verificar se Ã© malware conhecido - OFFLINE FIRST
    1. Busca no database local
    2. Opcionalmente consulta APIs externas (se habilitado)
    """
    hash_value = request.hash_value.lower()
    hash_type = request.hash_type

    # Auto-detect hash type
    if hash_type == "auto":
        hash_type = detect_hash_type(hash_value)

    if hash_type == "unknown":
        raise HTTPException(status_code=400, detail="Tipo de hash invÃ¡lido")

    # ============================
    # FASE 1: BUSCA OFFLINE (PRIMÃRIA)
    # ============================
    offline_result = offline_engine.check_hash(hash_value, hash_type)

    if offline_result.get("found"):
        # Hash encontrado no database local
        return AnalysisResponse(
            analysis_id=f"MA-{datetime.now().strftime('%Y%m%d%H%M%S')}-{hash_value[:8]}",
            target=hash_value,
            target_type="hash",
            threat_score=offline_result["threat_score"],
            is_malicious=offline_result["is_malicious"],
            malware_families=[offline_result["malware_family"]],
            file_type=None,
            file_size=None,
            hashes={hash_type: hash_value},
            detections={"malicious": 1, "suspicious": 0, "clean": 0},
            vendors=[{
                "name": "Local Database",
                "category": "malicious",
                "result": offline_result["malware_family"]
            }],
            behavior={"description": offline_result.get("description", "")},
            network_activity=None,
            recommendations=generate_recommendations(True, 100, [offline_result["malware_family"]]),
            timestamp=datetime.now().isoformat()
        )

    # ============================
    # FASE 2: APIs EXTERNAS (OPCIONAL)
    # ============================
    if USE_EXTERNAL_APIS and VIRUSTOTAL_API_KEY:
        vt_result = await check_virustotal_hash(hash_value)

        if vt_result.get("available") and vt_result.get("found", True):
            # Processar resultados do VT
            malicious = vt_result.get("malicious", 0)
            suspicious = vt_result.get("suspicious", 0)
            harmless = vt_result.get("harmless", 0)
            total = vt_result.get("total_vendors", 1)

            threat_score = int(((malicious * 100) + (suspicious * 50)) / total) if total > 0 else 0
            is_malicious = malicious > 0 or threat_score >= 60

            malware_families = []
            if vt_result.get("popular_threat_category"):
                malware_families.append(vt_result["popular_threat_category"])

            vendors = []
            for vendor_name, result in vt_result.get("last_analysis_results", {}).items():
                if result.get("category") in ["malicious", "suspicious"]:
                    vendors.append({
                        "name": vendor_name,
                        "category": result.get("category"),
                        "result": result.get("result", "")
                    })

            recommendations = generate_recommendations(is_malicious, threat_score, malware_families)

            return AnalysisResponse(
                analysis_id=f"MA-{datetime.now().strftime('%Y%m%d%H%M%S')}-{hash_value[:8]}",
                target=hash_value,
                target_type="hash",
                threat_score=threat_score,
                is_malicious=is_malicious,
                malware_families=malware_families[:5],
                file_type=vt_result.get("file_type"),
                file_size=vt_result.get("file_size"),
                hashes={hash_type: hash_value},
                detections={"malicious": malicious, "suspicious": suspicious, "clean": harmless},
                vendors=vendors[:10],
                behavior=None,
                network_activity=None,
                recommendations=recommendations,
                timestamp=datetime.now().isoformat()
            )

    # Hash nÃ£o encontrado em lugar nenhum
    return AnalysisResponse(
        analysis_id=f"MA-{datetime.now().strftime('%Y%m%d%H%M%S')}-{hash_value[:8]}",
        target=hash_value,
        target_type="hash",
        threat_score=0,
        is_malicious=False,
        malware_families=[],
        file_type=None,
        file_size=None,
        hashes={hash_type: hash_value},
        detections={"malicious": 0, "suspicious": 0, "clean": 0},
        vendors=[],
        behavior=None,
        network_activity=None,
        recommendations=["â„¹ï¸ Hash nÃ£o encontrado no database local" + (" nem em APIs externas" if USE_EXTERNAL_APIS else "")],
        timestamp=datetime.now().isoformat()
    )

@app.post("/api/malware/analyze-url", response_model=AnalysisResponse)
async def analyze_url(request: URLAnalysisRequest):
    """
    Analisa uma URL para detecÃ§Ã£o de phishing e malware
    Nota: AnÃ¡lise de URL depende de APIs externas (VirusTotal) ou anÃ¡lise local bÃ¡sica
    """
    url = request.url

    # AnÃ¡lise local bÃ¡sica de URL
    threat_score = 0
    is_malicious = False
    malware_families = []
    indicators = []

    # HeurÃ­sticas locais para URLs
    url_lower = url.lower()

    # DomÃ­nios suspeitos
    suspicious_tlds = ['.tk', '.ml', '.ga', '.cf', '.gq', '.xyz', '.top']
    if any(url_lower.endswith(tld) for tld in suspicious_tlds):
        threat_score += 30
        indicators.append("TLD suspeito detectado")

    # Palavras-chave suspeitas
    suspicious_keywords = ['login', 'account', 'verify', 'secure', 'update', 'confirm']
    if any(kw in url_lower for kw in suspicious_keywords):
        threat_score += 20
        indicators.append("URL contÃ©m palavras de phishing")

    # URL muito longa (possÃ­vel ofuscaÃ§Ã£o)
    if len(url) > 150:
        threat_score += 25
        indicators.append("URL excessivamente longa")

    # IP direto ao invÃ©s de domÃ­nio
    import re
    if re.search(r'https?://\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}', url):
        threat_score += 35
        indicators.append("URL usa IP direto ao invÃ©s de domÃ­nio")

    vendors = [{
        "name": "Local URL Analysis",
        "category": "heuristic",
        "result": f"Threat Score: {threat_score}"
    }]

    # ============================
    # APIs EXTERNAS (OPCIONAL)
    # ============================
    if USE_EXTERNAL_APIS and VIRUSTOTAL_API_KEY:
        vt_result = await check_virustotal_url(url)

        if vt_result.get("available"):
            malicious = vt_result.get("malicious", 0)
            suspicious = vt_result.get("suspicious", 0)
            harmless = vt_result.get("harmless", 0)
            total = vt_result.get("total_vendors", 1)

            vt_score = int(((malicious * 100) + (suspicious * 50)) / total) if total > 0 else 0
            threat_score = int(threat_score * 0.5 + vt_score * 0.5)
            is_malicious = malicious > 0 or threat_score >= 60

            malware_families = list(vt_result.get("categories", {}).keys())[:3]

            for vendor_name, result in vt_result.get("last_analysis_results", {}).items():
                if result.get("category") in ["malicious", "suspicious"]:
                    vendors.append({
                        "name": vendor_name,
                        "category": result.get("category"),
                        "result": result.get("result", "")
                    })
    else:
        is_malicious = threat_score >= 60

    recommendations = generate_recommendations(is_malicious, threat_score, malware_families)

    if not USE_EXTERNAL_APIS:
        recommendations.insert(0, "â„¹ï¸ OFFLINE MODE: AnÃ¡lise baseada apenas em heurÃ­sticas locais de URL")

    return AnalysisResponse(
        analysis_id=f"MA-{datetime.now().strftime('%Y%m%d%H%M%S')}-URL",
        target=url,
        target_type="url",
        threat_score=threat_score,
        is_malicious=is_malicious,
        malware_families=malware_families,
        file_type=None,
        file_size=None,
        hashes=None,
        detections={"malicious": 1 if is_malicious else 0, "suspicious": 1 if threat_score >= 40 else 0, "clean": 1 if threat_score < 40 else 0},
        vendors=vendors[:10],
        behavior={"local_indicators": indicators},
        network_activity=None,
        recommendations=recommendations,
        timestamp=datetime.now().isoformat()
    )

@app.get("/health")
async def health():
    return {"status": "healthy"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8014)