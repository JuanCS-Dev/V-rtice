"""
Post-Exploitation Agent - Post-Compromise Operations.

Autonomous agent for post-exploitation activities with reinforcement learning.
Implements privilege escalation, lateral movement, and persistence.
"""

from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class PostExploitAction(Enum):
    """Post-exploitation action types."""
    PRIVILEGE_ESCALATION = "privilege_escalation"
    LATERAL_MOVEMENT = "lateral_movement"
    PERSISTENCE = "persistence"
    CREDENTIAL_HARVESTING = "credential_harvesting"
    DATA_EXFILTRATION = "data_exfiltration"
    CLEANUP = "cleanup"


class ActionStatus(Enum):
    """Action execution status."""
    PLANNED = "planned"
    EXECUTING = "executing"
    SUCCESS = "success"
    FAILED = "failed"
    ROLLED_BACK = "rolled_back"


@dataclass
class CompromisedHost:
    """Compromised host information."""
    
    id: str
    address: str
    privileges: str  # user, admin, root, system
    os_type: str
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Action:
    """Post-exploitation action."""
    
    id: str
    action_type: PostExploitAction
    source_host: str
    target_host: Optional[str]
    method: str
    status: ActionStatus
    reward: float = 0.0
    result: Optional[Dict[str, Any]] = None
    created_at: datetime = field(default_factory=datetime.now)


@dataclass
class PostExploitMission:
    """Post-exploitation mission."""
    
    id: str
    compromised_hosts: List[CompromisedHost]
    objectives: List[str]
    constraints: Dict[str, Any]
    status: str
    created_at: datetime
    actions: List[Action] = field(default_factory=list)
    requires_approval: bool = True


class RLPolicy:
    """Reinforcement Learning policy for action selection."""
    
    def __init__(self) -> None:
        """Initialize RL policy."""
        self.q_table: Dict[str, Dict[str, float]] = {}
        self.learning_rate: float = 0.1
        self.discount_factor: float = 0.9
        self.epsilon: float = 0.1  # Exploration rate
    
    def get_state_key(self, host: CompromisedHost, objective: str) -> str:
        """
        Get state key for Q-table.
        
        Args:
            host: Current compromised host
            objective: Current objective
            
        Returns:
            State key
        """
        return f"{host.privileges}_{host.os_type}_{objective}"
    
    def select_action(
        self,
        state_key: str,
        available_actions: List[PostExploitAction]
    ) -> PostExploitAction:
        """
        Select action using epsilon-greedy policy.
        
        Args:
            state_key: Current state key
            available_actions: Available actions
            
        Returns:
            Selected action
        """
        import random
        
        # Initialize state if not exists
        if state_key not in self.q_table:
            self.q_table[state_key] = {
                action.value: 0.0 for action in PostExploitAction
            }
        
        # Epsilon-greedy selection
        if random.random() < self.epsilon:
            # Explore: random action
            return random.choice(available_actions)
        else:
            # Exploit: best action
            state_values = self.q_table[state_key]
            best_action = max(
                available_actions,
                key=lambda a: state_values.get(a.value, 0.0)
            )
            return best_action
    
    def update_q_value(
        self,
        state_key: str,
        action: PostExploitAction,
        reward: float,
        next_state_key: str
    ) -> None:
        """
        Update Q-value using Q-learning.
        
        Args:
            state_key: Current state
            action: Action taken
            reward: Reward received
            next_state_key: Next state
        """
        if state_key not in self.q_table:
            self.q_table[state_key] = {a.value: 0.0 for a in PostExploitAction}
        
        if next_state_key not in self.q_table:
            self.q_table[next_state_key] = {a.value: 0.0 for a in PostExploitAction}
        
        current_q = self.q_table[state_key][action.value]
        max_next_q = max(self.q_table[next_state_key].values())
        
        # Q-learning update
        new_q = current_q + self.learning_rate * (
            reward + self.discount_factor * max_next_q - current_q
        )
        
        self.q_table[state_key][action.value] = new_q


class PostExploitAgent:
    """
    Post-Exploitation Agent with RL.
    
    Features:
    - Privilege escalation
    - Lateral movement
    - Persistence mechanisms
    - Credential harvesting
    - Data exfiltration
    - RL-based action selection
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:
        """
        Initialize post-exploitation agent.
        
        Args:
            config: Agent configuration
        """
        self.logger = logging.getLogger(__name__)
        self.config = config or {}
        self.active_missions: Dict[str, PostExploitMission] = {}
        self.rl_policy = RLPolicy()
    
    async def execute_mission(
        self,
        mission: PostExploitMission,
        approved: bool = False
    ) -> Dict[str, Any]:
        """
        Execute post-exploitation mission.
        
        Args:
            mission: Mission to execute
            approved: Whether mission is pre-approved
            
        Returns:
            Mission results
        """
        if mission.requires_approval and not approved:
            return {
                "mission_id": mission.id,
                "status": "pending_approval",
                "message": "Mission requires HOTL approval"
            }
        
        self.logger.info(f"Executing post-exploit mission: {mission.id}")
        self.active_missions[mission.id] = mission
        
        mission.status = "running"
        
        try:
            # Execute actions for each objective
            for objective in mission.objectives:
                for host in mission.compromised_hosts:
                    action = await self._plan_action(
                        host,
                        objective,
                        mission.constraints
                    )
                    
                    success = await self._execute_action(action, mission.constraints)
                    
                    # Update RL policy
                    reward = 1.0 if success else -1.0
                    action.reward = reward
                    
                    state_key = self.rl_policy.get_state_key(host, objective)
                    next_state_key = state_key  # Simplified
                    
                    self.rl_policy.update_q_value(
                        state_key,
                        action.action_type,
                        reward,
                        next_state_key
                    )
                    
                    mission.actions.append(action)
            
            mission.status = "completed"
            
            successful_actions = [a for a in mission.actions if a.status == ActionStatus.SUCCESS]
            
            return {
                "mission_id": mission.id,
                "status": "completed",
                "objectives_count": len(mission.objectives),
                "hosts_count": len(mission.compromised_hosts),
                "actions_executed": len(mission.actions),
                "actions_successful": len(successful_actions),
                "success_rate": len(successful_actions) / len(mission.actions) if mission.actions else 0.0,
                "total_reward": sum(a.reward for a in mission.actions),
                "actions": [self._action_to_dict(a) for a in mission.actions]
            }
            
        except Exception as e:
            self.logger.error(f"Mission {mission.id} failed: {e}")
            mission.status = "failed"
            raise
    
    async def _plan_action(
        self,
        host: CompromisedHost,
        objective: str,
        constraints: Dict[str, Any]
    ) -> Action:
        """
        Plan action using RL policy.
        
        Args:
            host: Compromised host
            objective: Objective to achieve
            constraints: Operational constraints
            
        Returns:
            Planned action
        """
        # Determine available actions based on current state
        available_actions = self._get_available_actions(host, objective)
        
        # Select action using RL policy
        state_key = self.rl_policy.get_state_key(host, objective)
        action_type = self.rl_policy.select_action(state_key, available_actions)
        
        # Create action
        action = Action(
            id=f"action_{int(datetime.now().timestamp())}",
            action_type=action_type,
            source_host=host.id,
            target_host=None,
            method=self._get_method_for_action(action_type, host),
            status=ActionStatus.PLANNED
        )
        
        return action
    
    def _get_available_actions(
        self,
        host: CompromisedHost,
        objective: str
    ) -> List[PostExploitAction]:
        """
        Get available actions based on state.
        
        Args:
            host: Compromised host
            objective: Objective
            
        Returns:
            List of available actions
        """
        actions = []
        
        # Privilege escalation available if not root/system
        if host.privileges not in ["root", "system"]:
            actions.append(PostExploitAction.PRIVILEGE_ESCALATION)
        
        # Always available
        actions.append(PostExploitAction.LATERAL_MOVEMENT)
        actions.append(PostExploitAction.PERSISTENCE)
        actions.append(PostExploitAction.CREDENTIAL_HARVESTING)
        
        # Data exfiltration if objective requires it
        if "data" in objective.lower():
            actions.append(PostExploitAction.DATA_EXFILTRATION)
        
        actions.append(PostExploitAction.CLEANUP)
        
        return actions
    
    def _get_method_for_action(
        self,
        action_type: PostExploitAction,
        host: CompromisedHost
    ) -> str:
        """
        Get method for action based on OS and privileges.
        
        Args:
            action_type: Action type
            host: Compromised host
            
        Returns:
            Method name
        """
        methods = {
            PostExploitAction.PRIVILEGE_ESCALATION: {
                "linux": "sudo_exploit",
                "windows": "uac_bypass"
            },
            PostExploitAction.LATERAL_MOVEMENT: {
                "linux": "ssh_key",
                "windows": "psexec"
            },
            PostExploitAction.PERSISTENCE: {
                "linux": "cron_job",
                "windows": "scheduled_task"
            },
            PostExploitAction.CREDENTIAL_HARVESTING: {
                "linux": "dump_shadow",
                "windows": "mimikatz"
            },
            PostExploitAction.DATA_EXFILTRATION: {
                "linux": "scp",
                "windows": "smb"
            },
            PostExploitAction.CLEANUP: {
                "linux": "clear_logs",
                "windows": "clear_events"
            }
        }
        
        os_type = host.os_type.lower()
        if os_type not in ["linux", "windows"]:
            os_type = "linux"  # Default
        
        return methods.get(action_type, {}).get(os_type, "generic_method")
    
    async def _execute_action(
        self,
        action: Action,
        constraints: Dict[str, Any]
    ) -> bool:
        """
        Execute post-exploitation action.
        
        Args:
            action: Action to execute
            constraints: Operational constraints
            
        Returns:
            True if successful
        """
        self.logger.info(f"Executing action: {action.id} ({action.action_type.value})")
        
        action.status = ActionStatus.EXECUTING
        
        # Simulate action execution
        # In production: actual post-exploitation
        # For testing: always succeeds unless overridden
        success = constraints.get("force_failure", False) is False
        
        if success:
            action.status = ActionStatus.SUCCESS
            action.result = {
                "success": True,
                "method": action.method,
                "output": f"Action {action.action_type.value} completed",
                "timestamp": datetime.now().isoformat()
            }
        else:
            action.status = ActionStatus.FAILED
            action.result = {
                "success": False,
                "error": "Simulated failure"
            }
        
        return success
    
    def _action_to_dict(self, action: Action) -> Dict[str, Any]:
        """
        Convert action to dictionary.
        
        Args:
            action: Action object
            
        Returns:
            Dictionary representation
        """
        return {
            "id": action.id,
            "type": action.action_type.value,
            "source_host": action.source_host,
            "target_host": action.target_host,
            "method": action.method,
            "status": action.status.value,
            "reward": action.reward,
            "result": action.result,
            "created_at": action.created_at.isoformat()
        }
    
    def get_mission_status(self, mission_id: str) -> Optional[Dict[str, Any]]:
        """
        Get mission status.
        
        Args:
            mission_id: Mission identifier
            
        Returns:
            Mission status or None
        """
        mission = self.active_missions.get(mission_id)
        if not mission:
            return None
        
        return {
            "mission_id": mission.id,
            "status": mission.status,
            "hosts_count": len(mission.compromised_hosts),
            "objectives_count": len(mission.objectives),
            "actions_count": len(mission.actions),
            "requires_approval": mission.requires_approval,
            "created_at": mission.created_at.isoformat()
        }
    
    def get_rl_stats(self) -> Dict[str, Any]:
        """
        Get RL policy statistics.
        
        Returns:
            RL statistics
        """
        return {
            "states_learned": len(self.rl_policy.q_table),
            "learning_rate": self.rl_policy.learning_rate,
            "discount_factor": self.rl_policy.discount_factor,
            "epsilon": self.rl_policy.epsilon
        }
