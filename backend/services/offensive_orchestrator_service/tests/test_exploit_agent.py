"""Complete tests for Exploitation Agent - 100% coverage."""

import pytest
from datetime import datetime
from typing import Any
from agents.exploit.agent import (
    ExploitAgent,
    ExploitMission,
    Exploit,
    ExploitType,
    ExploitStatus,
    Vulnerability
)


@pytest.fixture
def exploit_agent() -> ExploitAgent:
    """Create exploit agent instance."""
    return ExploitAgent()


@pytest.fixture
def sample_vulnerabilities() -> list[Vulnerability]:
    """Create sample vulnerabilities."""
    return [
        Vulnerability(
            id="vuln_001",
            target="192.168.1.100",
            vuln_type="sql_injection",
            severity="high",
            confidence=0.95,
            metadata={"port": 3306}
        ),
        Vulnerability(
            id="vuln_002",
            target="example.com",
            vuln_type="xss",
            severity="medium",
            confidence=0.85,
            metadata={"endpoint": "/search"}
        )
    ]


@pytest.fixture
def sample_mission(sample_vulnerabilities: list[Vulnerability]) -> ExploitMission:
    """Create sample mission."""
    return ExploitMission(
        id="exploit_mission_001",
        vulnerabilities=sample_vulnerabilities,
        constraints={"safe_mode": True},
        status="pending",
        created_at=datetime.now(),
        requires_approval=True
    )


@pytest.mark.asyncio
async def test_execute_mission_without_approval(
    exploit_agent: ExploitAgent,
    sample_mission: ExploitMission
) -> None:
    """Test mission execution without approval."""
    result = await exploit_agent.execute_mission(sample_mission, approved=False)
    
    assert result["status"] == "pending_approval"
    assert "requires HOTL approval" in result["message"]


@pytest.mark.asyncio
async def test_execute_mission_with_approval(
    exploit_agent: ExploitAgent,
    sample_mission: ExploitMission
) -> None:
    """Test mission execution with approval."""
    result = await exploit_agent.execute_mission(sample_mission, approved=True)
    
    assert result["status"] == "completed"
    assert result["mission_id"] == "exploit_mission_001"
    assert result["total_vulnerabilities"] == 2
    assert result["exploits_generated"] > 0
    assert "success_rate" in result


@pytest.mark.asyncio
async def test_execute_mission_no_approval_required(
    exploit_agent: ExploitAgent,
    sample_vulnerabilities: list[Vulnerability]
) -> None:
    """Test mission that doesn't require approval."""
    mission = ExploitMission(
        id="mission_002",
        vulnerabilities=sample_vulnerabilities,
        constraints={},
        status="pending",
        created_at=datetime.now(),
        requires_approval=False
    )
    
    result = await exploit_agent.execute_mission(mission, approved=False)
    
    assert result["status"] == "completed"


@pytest.mark.asyncio
async def test_generate_exploit_sql_injection(exploit_agent: ExploitAgent) -> None:
    """Test exploit generation for SQL injection."""
    vuln = Vulnerability(
        id="vuln_sql",
        target="test.com",
        vuln_type="sql_injection",
        severity="high",
        confidence=0.9,
        metadata={}
    )
    
    exploit = await exploit_agent._generate_exploit(vuln, {})
    
    assert exploit.exploit_type == ExploitType.SQL_INJECTION
    assert exploit.status == ExploitStatus.GENERATED
    assert "OR" in exploit.payload or "'" in exploit.payload
    assert exploit.vulnerability_id == "vuln_sql"


@pytest.mark.asyncio
async def test_generate_exploit_all_types(exploit_agent: ExploitAgent) -> None:
    """Test exploit generation for all vulnerability types."""
    vuln_types = [
        "sql_injection", "xss", "command_injection", "file_upload",
        "path_traversal", "authentication_bypass", "buffer_overflow", "rce"
    ]
    
    for vuln_type in vuln_types:
        vuln = Vulnerability(
            id=f"vuln_{vuln_type}",
            target="test.com",
            vuln_type=vuln_type,
            severity="high",
            confidence=0.9,
            metadata={}
        )
        
        exploit = await exploit_agent._generate_exploit(vuln, {})
        assert exploit.status == ExploitStatus.GENERATED
        assert len(exploit.payload) > 0


@pytest.mark.asyncio
async def test_generate_exploit_unknown_type(exploit_agent: ExploitAgent) -> None:
    """Test exploit generation for unknown vulnerability type."""
    vuln = Vulnerability(
        id="vuln_unknown",
        target="test.com",
        vuln_type="unknown_vuln_type",
        severity="medium",
        confidence=0.7,
        metadata={}
    )
    
    exploit = await exploit_agent._generate_exploit(vuln, {})
    
    assert exploit.exploit_type == ExploitType.RCE
    assert exploit.payload == "$(whoami)"  # Default RCE payload


def test_generate_payload_all_types(exploit_agent: ExploitAgent) -> None:
    """Test payload generation for all exploit types."""
    vuln = Vulnerability(
        id="test",
        target="test.com",
        vuln_type="test",
        severity="high",
        confidence=0.9,
        metadata={}
    )
    
    for exploit_type in ExploitType:
        payload = exploit_agent._generate_payload(exploit_type, vuln)
        assert isinstance(payload, str)
        assert len(payload) > 0


@pytest.mark.asyncio
async def test_validate_exploit_safe(exploit_agent: ExploitAgent) -> None:
    """Test exploit validation with safe payload."""
    exploit = Exploit(
        id="exp_001",
        vulnerability_id="vuln_001",
        exploit_type=ExploitType.SQL_INJECTION,
        payload="' OR '1'='1' --",
        status=ExploitStatus.GENERATED
    )
    
    is_valid = await exploit_agent._validate_exploit(exploit, {})
    
    assert is_valid is True
    assert exploit.validation_result is not None
    assert exploit.validation_result["valid"] is True


@pytest.mark.asyncio
async def test_validate_exploit_dangerous_pattern(exploit_agent: ExploitAgent) -> None:
    """Test exploit validation with dangerous pattern."""
    exploit = Exploit(
        id="exp_002",
        vulnerability_id="vuln_002",
        exploit_type=ExploitType.COMMAND_INJECTION,
        payload="rm -rf /",
        status=ExploitStatus.GENERATED
    )
    
    is_valid = await exploit_agent._validate_exploit(exploit, {})
    
    assert is_valid is False
    assert exploit.validation_result is not None
    assert exploit.validation_result["valid"] is False
    assert "rm -rf" in exploit.validation_result["reason"]


@pytest.mark.asyncio
async def test_validate_exploit_drop_table(exploit_agent: ExploitAgent) -> None:
    """Test validation detects DROP TABLE."""
    exploit = Exploit(
        id="exp_003",
        vulnerability_id="vuln_003",
        exploit_type=ExploitType.SQL_INJECTION,
        payload="DROP TABLE users",
        status=ExploitStatus.GENERATED
    )
    
    is_valid = await exploit_agent._validate_exploit(exploit, {})
    
    assert is_valid is False
    assert "DROP TABLE" in exploit.validation_result["reason"]


@pytest.mark.asyncio
async def test_validate_exploit_delete_from(exploit_agent: ExploitAgent) -> None:
    """Test validation detects DELETE FROM."""
    exploit = Exploit(
        id="exp_004",
        vulnerability_id="vuln_004",
        exploit_type=ExploitType.SQL_INJECTION,
        payload="DELETE FROM users WHERE 1=1",
        status=ExploitStatus.GENERATED
    )
    
    is_valid = await exploit_agent._validate_exploit(exploit, {})
    
    assert is_valid is False
    assert "DELETE FROM" in exploit.validation_result["reason"]


@pytest.mark.asyncio
async def test_validate_exploit_safe_mode_read_only(exploit_agent: ExploitAgent) -> None:
    """Test safe mode allows read-only exploits."""
    exploit = Exploit(
        id="exp_005",
        vulnerability_id="vuln_005",
        exploit_type=ExploitType.SQL_INJECTION,
        payload="' OR '1'='1",
        status=ExploitStatus.GENERATED
    )
    
    is_valid = await exploit_agent._validate_exploit(
        exploit,
        {"safe_mode": True}
    )
    
    assert is_valid is True


@pytest.mark.asyncio
async def test_validate_exploit_safe_mode_blocks_write(exploit_agent: ExploitAgent) -> None:
    """Test safe mode blocks write operations."""
    exploit = Exploit(
        id="exp_006",
        vulnerability_id="vuln_006",
        exploit_type=ExploitType.XSS,
        payload="<script>alert('test')</script>",
        status=ExploitStatus.GENERATED
    )
    
    is_valid = await exploit_agent._validate_exploit(
        exploit,
        {"safe_mode": True}
    )
    
    assert is_valid is False
    assert "read-only" in exploit.validation_result["reason"]


@pytest.mark.asyncio
async def test_validate_exploit_safe_mode_disabled(exploit_agent: ExploitAgent) -> None:
    """Test validation with safe mode disabled."""
    exploit = Exploit(
        id="exp_007",
        vulnerability_id="vuln_007",
        exploit_type=ExploitType.XSS,
        payload="<script>alert('test')</script>",
        status=ExploitStatus.GENERATED
    )
    
    is_valid = await exploit_agent._validate_exploit(
        exploit,
        {"safe_mode": False}
    )
    
    assert is_valid is True


@pytest.mark.asyncio
async def test_execute_exploit_success(exploit_agent: ExploitAgent) -> None:
    """Test exploit execution."""
    exploit = Exploit(
        id="exp_008",
        vulnerability_id="vuln_008",
        exploit_type=ExploitType.SQL_INJECTION,
        payload="test_payload",
        status=ExploitStatus.VALIDATED
    )
    
    success = await exploit_agent._execute_exploit(exploit, {})
    
    assert success is True
    assert exploit.status == ExploitStatus.EXECUTED
    assert exploit.execution_result is not None
    assert exploit.execution_result["success"] is True


@pytest.mark.asyncio
async def test_rollback_exploit(exploit_agent: ExploitAgent) -> None:
    """Test exploit rollback."""
    exploit = Exploit(
        id="exp_009",
        vulnerability_id="vuln_009",
        exploit_type=ExploitType.FILE_UPLOAD,
        payload="shell.php",
        status=ExploitStatus.SUCCESS
    )
    
    success = await exploit_agent.rollback_exploit(exploit)
    
    assert success is True
    assert exploit.status == ExploitStatus.ROLLBACK


def test_exploit_to_dict(exploit_agent: ExploitAgent) -> None:
    """Test exploit conversion to dictionary."""
    exploit = Exploit(
        id="exp_010",
        vulnerability_id="vuln_010",
        exploit_type=ExploitType.XSS,
        payload="<script>test</script>",
        status=ExploitStatus.SUCCESS
    )
    exploit.validation_result = {"valid": True}
    exploit.execution_result = {"success": True}
    
    result = exploit_agent._exploit_to_dict(exploit)
    
    assert result["id"] == "exp_010"
    assert result["vulnerability_id"] == "vuln_010"
    assert result["type"] == "xss"
    assert result["payload"] == "<script>test</script>"
    assert result["status"] == "success"
    assert result["validation"] == {"valid": True}
    assert result["execution"] == {"success": True}


def test_get_mission_status_exists(
    exploit_agent: ExploitAgent,
    sample_mission: ExploitMission
) -> None:
    """Test mission status retrieval."""
    exploit_agent.active_missions[sample_mission.id] = sample_mission
    
    status = exploit_agent.get_mission_status(sample_mission.id)
    
    assert status is not None
    assert status["mission_id"] == "exploit_mission_001"
    assert status["status"] == "pending"
    assert status["vulnerabilities_count"] == 2
    assert status["requires_approval"] is True


def test_get_mission_status_not_found(exploit_agent: ExploitAgent) -> None:
    """Test mission status for non-existent mission."""
    status = exploit_agent.get_mission_status("invalid_id")
    
    assert status is None


def test_exploit_agent_initialization() -> None:
    """Test agent initialization with config."""
    config = {"timeout": 300, "safe_mode": True}
    agent = ExploitAgent(config=config)
    
    assert agent.config == config
    assert len(agent.active_missions) == 0


def test_exploit_agent_initialization_default() -> None:
    """Test agent initialization with defaults."""
    agent = ExploitAgent()
    
    assert agent.config == {}
    assert isinstance(agent.active_missions, dict)


def test_vulnerability_creation() -> None:
    """Test Vulnerability dataclass."""
    vuln = Vulnerability(
        id="v001",
        target="test.com",
        vuln_type="sql_injection",
        severity="high",
        confidence=0.95,
        metadata={"port": 3306}
    )
    
    assert vuln.id == "v001"
    assert vuln.severity == "high"
    assert vuln.confidence == 0.95


def test_exploit_creation() -> None:
    """Test Exploit dataclass."""
    exploit = Exploit(
        id="e001",
        vulnerability_id="v001",
        exploit_type=ExploitType.SQL_INJECTION,
        payload="test",
        status=ExploitStatus.GENERATED
    )
    
    assert exploit.id == "e001"
    assert exploit.exploit_type == ExploitType.SQL_INJECTION
    assert exploit.status == ExploitStatus.GENERATED


def test_exploit_mission_creation(sample_vulnerabilities: list[Vulnerability]) -> None:
    """Test ExploitMission dataclass."""
    mission = ExploitMission(
        id="m001",
        vulnerabilities=sample_vulnerabilities,
        constraints={"safe_mode": True},
        status="pending",
        created_at=datetime.now(),
        requires_approval=True
    )
    
    assert mission.id == "m001"
    assert len(mission.vulnerabilities) == 2
    assert len(mission.exploits) == 0
    assert mission.requires_approval is True


def test_exploit_type_enum() -> None:
    """Test ExploitType enum."""
    assert ExploitType.SQL_INJECTION.value == "sql_injection"
    assert ExploitType.XSS.value == "xss"
    assert ExploitType.COMMAND_INJECTION.value == "command_injection"
    assert ExploitType.RCE.value == "rce"


def test_exploit_status_enum() -> None:
    """Test ExploitStatus enum."""
    assert ExploitStatus.GENERATED.value == "generated"
    assert ExploitStatus.VALIDATED.value == "validated"
    assert ExploitStatus.EXECUTED.value == "executed"
    assert ExploitStatus.SUCCESS.value == "success"
    assert ExploitStatus.FAILED.value == "failed"
    assert ExploitStatus.ROLLBACK.value == "rollback"


@pytest.mark.asyncio
async def test_mission_failure_handling(exploit_agent: ExploitAgent) -> None:
    """Test mission failure handling."""
    # Patch _generate_exploit to raise exception
    async def mock_generate_exploit(*args: Any, **kwargs: Any) -> Exploit:
        raise ValueError("Exploit generation failed")
    
    original_generate = exploit_agent._generate_exploit
    exploit_agent._generate_exploit = mock_generate_exploit  # type: ignore
    
    mission = ExploitMission(
        id="fail_mission",
        vulnerabilities=[
            Vulnerability(
                id="v001",
                target="test.com",
                vuln_type="sql_injection",
                severity="high",
                confidence=0.9,
                metadata={}
            )
        ],
        constraints={},
        status="pending",
        created_at=datetime.now(),
        requires_approval=False
    )
    
    with pytest.raises(ValueError, match="Exploit generation failed"):
        await exploit_agent.execute_mission(mission, approved=False)
    
    assert mission.status == "failed"
    
    # Restore
    exploit_agent._generate_exploit = original_generate  # type: ignore


@pytest.mark.asyncio
async def test_mission_tracks_active_missions(
    exploit_agent: ExploitAgent,
    sample_mission: ExploitMission
) -> None:
    """Test mission is tracked in active_missions."""
    await exploit_agent.execute_mission(sample_mission, approved=True)
    
    assert sample_mission.id in exploit_agent.active_missions
    assert sample_mission.status == "completed"


@pytest.mark.asyncio
async def test_mission_exploit_counts(
    exploit_agent: ExploitAgent,
    sample_mission: ExploitMission
) -> None:
    """Test mission tracks exploit counts correctly."""
    result = await exploit_agent.execute_mission(sample_mission, approved=True)
    
    assert result["exploits_generated"] == 2
    assert result["exploits_validated"] <= result["exploits_generated"]
    assert result["exploits_successful"] <= result["exploits_validated"]
    assert 0.0 <= result["success_rate"] <= 1.0


@pytest.mark.asyncio
async def test_mission_exploit_validation_failure(
    exploit_agent: ExploitAgent
) -> None:
    """Test mission with exploit that fails validation."""
    # Create vulnerability that generates dangerous payload
    vuln = Vulnerability(
        id="vuln_dangerous",
        target="test.com",
        vuln_type="command_injection",  # Will generate "; cat /etc/passwd"
        severity="high",
        confidence=0.9,
        metadata={}
    )
    
    mission = ExploitMission(
        id="mission_fail_validation",
        vulnerabilities=[vuln],
        constraints={"safe_mode": True},
        status="pending",
        created_at=datetime.now(),
        requires_approval=False
    )
    
    # Patch validation to return False
    async def mock_validate(*args: Any, **kwargs: Any) -> bool:
        exploit = args[0]
        exploit.status = ExploitStatus.FAILED
        exploit.validation_result = {"valid": False, "reason": "Test failure"}
        return False
    
    original_validate = exploit_agent._validate_exploit
    exploit_agent._validate_exploit = mock_validate  # type: ignore
    
    result = await exploit_agent.execute_mission(mission, approved=False)
    
    assert result["exploits_validated"] == 0
    assert result["exploits_successful"] == 0
    
    # Restore
    exploit_agent._validate_exploit = original_validate  # type: ignore


@pytest.mark.asyncio
async def test_mission_exploit_execution_failure(
    exploit_agent: ExploitAgent
) -> None:
    """Test mission with exploit that fails execution."""
    vuln = Vulnerability(
        id="vuln_exec_fail",
        target="test.com",
        vuln_type="sql_injection",
        severity="high",
        confidence=0.9,
        metadata={}
    )
    
    mission = ExploitMission(
        id="mission_exec_fail",
        vulnerabilities=[vuln],
        constraints={},
        status="pending",
        created_at=datetime.now(),
        requires_approval=False
    )
    
    # Patch execute to return False
    async def mock_execute(*args: Any, **kwargs: Any) -> bool:
        exploit = args[0]
        exploit.status = ExploitStatus.FAILED
        return False
    
    original_execute = exploit_agent._execute_exploit
    exploit_agent._execute_exploit = mock_execute  # type: ignore
    
    result = await exploit_agent.execute_mission(mission, approved=False)
    
    assert result["exploits_successful"] == 0
    assert result["success_rate"] == 0.0
    
    # Restore
    exploit_agent._execute_exploit = original_execute  # type: ignore
