"""Complete tests for Post-Exploitation Agent - 100% coverage."""

import pytest
from datetime import datetime
from typing import Any
from agents.postexploit.agent import (
    PostExploitAgent,
    PostExploitMission,
    Action,
    PostExploitAction,
    ActionStatus,
    CompromisedHost,
    RLPolicy
)


@pytest.fixture
def postexploit_agent() -> PostExploitAgent:
    """Create post-exploit agent instance."""
    return PostExploitAgent()


@pytest.fixture
def sample_hosts() -> list[CompromisedHost]:
    """Create sample compromised hosts."""
    return [
        CompromisedHost(
            id="host_001",
            address="192.168.1.100",
            privileges="user",
            os_type="linux",
            metadata={}
        ),
        CompromisedHost(
            id="host_002",
            address="192.168.1.101",
            privileges="admin",
            os_type="windows",
            metadata={}
        )
    ]


@pytest.fixture
def sample_mission(sample_hosts: list[CompromisedHost]) -> PostExploitMission:
    """Create sample mission."""
    return PostExploitMission(
        id="postexploit_001",
        compromised_hosts=sample_hosts,
        objectives=["escalate_privileges", "establish_persistence"],
        constraints={"stealth": True},
        status="pending",
        created_at=datetime.now(),
        requires_approval=True
    )


@pytest.mark.asyncio
async def test_execute_mission_without_approval(
    postexploit_agent: PostExploitAgent,
    sample_mission: PostExploitMission
) -> None:
    """Test mission execution without approval."""
    result = await postexploit_agent.execute_mission(sample_mission, approved=False)
    
    assert result["status"] == "pending_approval"
    assert "requires HOTL approval" in result["message"]


@pytest.mark.asyncio
async def test_execute_mission_with_approval(
    postexploit_agent: PostExploitAgent,
    sample_mission: PostExploitMission
) -> None:
    """Test mission execution with approval."""
    result = await postexploit_agent.execute_mission(sample_mission, approved=True)
    
    assert result["status"] == "completed"
    assert result["mission_id"] == "postexploit_001"
    assert result["objectives_count"] == 2
    assert result["hosts_count"] == 2
    assert result["actions_executed"] == 4  # 2 hosts * 2 objectives
    assert "success_rate" in result


@pytest.mark.asyncio
async def test_execute_mission_no_approval_required(
    postexploit_agent: PostExploitAgent,
    sample_hosts: list[CompromisedHost]
) -> None:
    """Test mission that doesn't require approval."""
    mission = PostExploitMission(
        id="mission_002",
        compromised_hosts=sample_hosts,
        objectives=["recon"],
        constraints={},
        status="pending",
        created_at=datetime.now(),
        requires_approval=False
    )
    
    result = await postexploit_agent.execute_mission(mission, approved=False)
    
    assert result["status"] == "completed"


@pytest.mark.asyncio
async def test_plan_action_user_privileges(postexploit_agent: PostExploitAgent) -> None:
    """Test action planning with user privileges."""
    host = CompromisedHost(
        id="h001",
        address="test.com",
        privileges="user",
        os_type="linux",
        metadata={}
    )
    
    action = await postexploit_agent._plan_action(host, "escalate", {})
    
    assert action.action_type in PostExploitAction
    assert action.status == ActionStatus.PLANNED
    assert action.source_host == "h001"


@pytest.mark.asyncio
async def test_plan_action_root_privileges(postexploit_agent: PostExploitAgent) -> None:
    """Test action planning with root privileges."""
    host = CompromisedHost(
        id="h002",
        address="test.com",
        privileges="root",
        os_type="linux",
        metadata={}
    )
    
    action = await postexploit_agent._plan_action(host, "persist", {})
    
    assert action.status == ActionStatus.PLANNED


def test_get_available_actions_user(postexploit_agent: PostExploitAgent) -> None:
    """Test available actions for user privilege."""
    host = CompromisedHost(
        id="h003",
        address="test.com",
        privileges="user",
        os_type="linux",
        metadata={}
    )
    
    actions = postexploit_agent._get_available_actions(host, "test")
    
    assert PostExploitAction.PRIVILEGE_ESCALATION in actions
    assert PostExploitAction.LATERAL_MOVEMENT in actions
    assert PostExploitAction.PERSISTENCE in actions


def test_get_available_actions_root(postexploit_agent: PostExploitAgent) -> None:
    """Test available actions for root privilege."""
    host = CompromisedHost(
        id="h004",
        address="test.com",
        privileges="root",
        os_type="linux",
        metadata={}
    )
    
    actions = postexploit_agent._get_available_actions(host, "test")
    
    assert PostExploitAction.PRIVILEGE_ESCALATION not in actions
    assert PostExploitAction.LATERAL_MOVEMENT in actions


def test_get_available_actions_system(postexploit_agent: PostExploitAgent) -> None:
    """Test available actions for system privilege."""
    host = CompromisedHost(
        id="h005",
        address="test.com",
        privileges="system",
        os_type="windows",
        metadata={}
    )
    
    actions = postexploit_agent._get_available_actions(host, "test")
    
    assert PostExploitAction.PRIVILEGE_ESCALATION not in actions


def test_get_available_actions_data_objective(postexploit_agent: PostExploitAgent) -> None:
    """Test available actions with data objective."""
    host = CompromisedHost(
        id="h006",
        address="test.com",
        privileges="admin",
        os_type="windows",
        metadata={}
    )
    
    actions = postexploit_agent._get_available_actions(host, "exfiltrate_data")
    
    assert PostExploitAction.DATA_EXFILTRATION in actions


def test_get_available_actions_no_data_objective(postexploit_agent: PostExploitAgent) -> None:
    """Test available actions without data objective."""
    host = CompromisedHost(
        id="h007",
        address="test.com",
        privileges="user",
        os_type="linux",
        metadata={}
    )
    
    actions = postexploit_agent._get_available_actions(host, "escalate")
    
    # DATA_EXFILTRATION should not be included
    assert PostExploitAction.DATA_EXFILTRATION not in actions


def test_get_method_for_action_linux(postexploit_agent: PostExploitAgent) -> None:
    """Test method selection for Linux."""
    host = CompromisedHost(
        id="h008",
        address="test.com",
        privileges="user",
        os_type="linux",
        metadata={}
    )
    
    method = postexploit_agent._get_method_for_action(
        PostExploitAction.PRIVILEGE_ESCALATION,
        host
    )
    
    assert method == "sudo_exploit"


def test_get_method_for_action_windows(postexploit_agent: PostExploitAgent) -> None:
    """Test method selection for Windows."""
    host = CompromisedHost(
        id="h009",
        address="test.com",
        privileges="admin",
        os_type="windows",
        metadata={}
    )
    
    method = postexploit_agent._get_method_for_action(
        PostExploitAction.LATERAL_MOVEMENT,
        host
    )
    
    assert method == "psexec"


def test_get_method_for_action_unknown_os(postexploit_agent: PostExploitAgent) -> None:
    """Test method selection for unknown OS."""
    host = CompromisedHost(
        id="h010",
        address="test.com",
        privileges="user",
        os_type="macos",
        metadata={}
    )
    
    method = postexploit_agent._get_method_for_action(
        PostExploitAction.PERSISTENCE,
        host
    )
    
    assert method == "cron_job"  # Defaults to linux


def test_get_method_all_actions_linux(postexploit_agent: PostExploitAgent) -> None:
    """Test method selection for all actions on Linux."""
    host = CompromisedHost(
        id="h011",
        address="test.com",
        privileges="user",
        os_type="linux",
        metadata={}
    )
    
    for action_type in PostExploitAction:
        method = postexploit_agent._get_method_for_action(action_type, host)
        assert isinstance(method, str)
        assert len(method) > 0


def test_get_method_all_actions_windows(postexploit_agent: PostExploitAgent) -> None:
    """Test method selection for all actions on Windows."""
    host = CompromisedHost(
        id="h012",
        address="test.com",
        privileges="admin",
        os_type="windows",
        metadata={}
    )
    
    for action_type in PostExploitAction:
        method = postexploit_agent._get_method_for_action(action_type, host)
        assert isinstance(method, str)
        assert len(method) > 0


@pytest.mark.asyncio
async def test_execute_action_success(postexploit_agent: PostExploitAgent) -> None:
    """Test action execution."""
    action = Action(
        id="act_001",
        action_type=PostExploitAction.PRIVILEGE_ESCALATION,
        source_host="h001",
        target_host=None,
        method="sudo_exploit",
        status=ActionStatus.PLANNED
    )
    
    success = await postexploit_agent._execute_action(action, {})
    
    assert success is True
    assert action.status == ActionStatus.SUCCESS  # Final status after execution
    assert action.result is not None
    assert action.result["success"] is True


def test_action_to_dict(postexploit_agent: PostExploitAgent) -> None:
    """Test action conversion to dictionary."""
    action = Action(
        id="act_002",
        action_type=PostExploitAction.LATERAL_MOVEMENT,
        source_host="h001",
        target_host="h002",
        method="ssh_key",
        status=ActionStatus.SUCCESS,
        reward=1.0
    )
    action.result = {"success": True}
    
    result = postexploit_agent._action_to_dict(action)
    
    assert result["id"] == "act_002"
    assert result["type"] == "lateral_movement"
    assert result["source_host"] == "h001"
    assert result["target_host"] == "h002"
    assert result["reward"] == 1.0


def test_get_mission_status_exists(
    postexploit_agent: PostExploitAgent,
    sample_mission: PostExploitMission
) -> None:
    """Test mission status retrieval."""
    postexploit_agent.active_missions[sample_mission.id] = sample_mission
    
    status = postexploit_agent.get_mission_status(sample_mission.id)
    
    assert status is not None
    assert status["mission_id"] == "postexploit_001"
    assert status["status"] == "pending"
    assert status["hosts_count"] == 2


def test_get_mission_status_not_found(postexploit_agent: PostExploitAgent) -> None:
    """Test mission status for non-existent mission."""
    status = postexploit_agent.get_mission_status("invalid_id")
    
    assert status is None


def test_get_rl_stats(postexploit_agent: PostExploitAgent) -> None:
    """Test RL statistics retrieval."""
    stats = postexploit_agent.get_rl_stats()
    
    assert "states_learned" in stats
    assert "learning_rate" in stats
    assert "discount_factor" in stats
    assert "epsilon" in stats
    assert stats["learning_rate"] == 0.1
    assert stats["discount_factor"] == 0.9


def test_rl_policy_initialization() -> None:
    """Test RL policy initialization."""
    policy = RLPolicy()
    
    assert policy.learning_rate == 0.1
    assert policy.discount_factor == 0.9
    assert policy.epsilon == 0.1
    assert len(policy.q_table) == 0


def test_rl_policy_get_state_key() -> None:
    """Test state key generation."""
    policy = RLPolicy()
    host = CompromisedHost(
        id="h001",
        address="test.com",
        privileges="user",
        os_type="linux",
        metadata={}
    )
    
    state_key = policy.get_state_key(host, "escalate")
    
    assert state_key == "user_linux_escalate"


def test_rl_policy_select_action_exploration() -> None:
    """Test action selection with exploration."""
    policy = RLPolicy()
    policy.epsilon = 1.0  # Always explore
    
    actions = [PostExploitAction.PRIVILEGE_ESCALATION, PostExploitAction.LATERAL_MOVEMENT]
    
    selected = policy.select_action("test_state", actions)
    
    assert selected in actions


def test_rl_policy_select_action_exploitation() -> None:
    """Test action selection with exploitation."""
    policy = RLPolicy()
    policy.epsilon = 0.0  # Never explore
    
    # Set up Q-table
    state_key = "test_state"
    policy.q_table[state_key] = {
        PostExploitAction.PRIVILEGE_ESCALATION.value: 10.0,
        PostExploitAction.LATERAL_MOVEMENT.value: 5.0,
        PostExploitAction.PERSISTENCE.value: 3.0,
        PostExploitAction.CREDENTIAL_HARVESTING.value: 0.0,
        PostExploitAction.DATA_EXFILTRATION.value: 0.0,
        PostExploitAction.CLEANUP.value: 0.0
    }
    
    actions = [
        PostExploitAction.PRIVILEGE_ESCALATION,
        PostExploitAction.LATERAL_MOVEMENT,
        PostExploitAction.PERSISTENCE
    ]
    
    selected = policy.select_action(state_key, actions)
    
    assert selected == PostExploitAction.PRIVILEGE_ESCALATION


def test_rl_policy_update_q_value() -> None:
    """Test Q-value update."""
    policy = RLPolicy()
    
    state_key = "state1"
    next_state_key = "state2"
    action = PostExploitAction.PRIVILEGE_ESCALATION
    reward = 1.0
    
    policy.update_q_value(state_key, action, reward, next_state_key)
    
    assert state_key in policy.q_table
    assert action.value in policy.q_table[state_key]
    assert policy.q_table[state_key][action.value] != 0.0


def test_postexploit_agent_initialization() -> None:
    """Test agent initialization with config."""
    config = {"stealth": True, "timeout": 300}
    agent = PostExploitAgent(config=config)
    
    assert agent.config == config
    assert len(agent.active_missions) == 0
    assert isinstance(agent.rl_policy, RLPolicy)


def test_postexploit_agent_initialization_default() -> None:
    """Test agent initialization with defaults."""
    agent = PostExploitAgent()
    
    assert agent.config == {}
    assert isinstance(agent.active_missions, dict)
    assert isinstance(agent.rl_policy, RLPolicy)


def test_compromised_host_creation() -> None:
    """Test CompromisedHost dataclass."""
    host = CompromisedHost(
        id="h001",
        address="192.168.1.100",
        privileges="admin",
        os_type="windows",
        metadata={"domain": "test.local"}
    )
    
    assert host.id == "h001"
    assert host.privileges == "admin"
    assert host.metadata["domain"] == "test.local"


def test_action_creation() -> None:
    """Test Action dataclass."""
    action = Action(
        id="a001",
        action_type=PostExploitAction.LATERAL_MOVEMENT,
        source_host="h001",
        target_host="h002",
        method="psexec",
        status=ActionStatus.PLANNED
    )
    
    assert action.id == "a001"
    assert action.action_type == PostExploitAction.LATERAL_MOVEMENT
    assert action.reward == 0.0


def test_postexploit_mission_creation(sample_hosts: list[CompromisedHost]) -> None:
    """Test PostExploitMission dataclass."""
    mission = PostExploitMission(
        id="m001",
        compromised_hosts=sample_hosts,
        objectives=["escalate", "persist"],
        constraints={},
        status="pending",
        created_at=datetime.now()
    )
    
    assert mission.id == "m001"
    assert len(mission.compromised_hosts) == 2
    assert len(mission.actions) == 0


def test_postexploit_action_enum() -> None:
    """Test PostExploitAction enum."""
    assert PostExploitAction.PRIVILEGE_ESCALATION.value == "privilege_escalation"
    assert PostExploitAction.LATERAL_MOVEMENT.value == "lateral_movement"
    assert PostExploitAction.PERSISTENCE.value == "persistence"
    assert PostExploitAction.CLEANUP.value == "cleanup"


def test_action_status_enum() -> None:
    """Test ActionStatus enum."""
    assert ActionStatus.PLANNED.value == "planned"
    assert ActionStatus.EXECUTING.value == "executing"
    assert ActionStatus.SUCCESS.value == "success"
    assert ActionStatus.FAILED.value == "failed"
    assert ActionStatus.ROLLED_BACK.value == "rolled_back"


@pytest.mark.asyncio
async def test_mission_failure_handling(postexploit_agent: PostExploitAgent) -> None:
    """Test mission failure handling."""
    # Patch _plan_action to raise exception
    async def mock_plan_action(*args: Any, **kwargs: Any) -> Action:
        raise ValueError("Planning failed")
    
    original_plan = postexploit_agent._plan_action
    postexploit_agent._plan_action = mock_plan_action  # type: ignore
    
    mission = PostExploitMission(
        id="fail_mission",
        compromised_hosts=[
            CompromisedHost(
                id="h001",
                address="test.com",
                privileges="user",
                os_type="linux",
                metadata={}
            )
        ],
        objectives=["test"],
        constraints={},
        status="pending",
        created_at=datetime.now(),
        requires_approval=False
    )
    
    with pytest.raises(ValueError, match="Planning failed"):
        await postexploit_agent.execute_mission(mission, approved=False)
    
    assert mission.status == "failed"
    
    # Restore
    postexploit_agent._plan_action = original_plan  # type: ignore


@pytest.mark.asyncio
async def test_mission_tracks_active_missions(
    postexploit_agent: PostExploitAgent,
    sample_mission: PostExploitMission
) -> None:
    """Test mission is tracked in active_missions."""
    await postexploit_agent.execute_mission(sample_mission, approved=True)
    
    assert sample_mission.id in postexploit_agent.active_missions
    assert sample_mission.status == "completed"


@pytest.mark.asyncio
async def test_mission_rl_learning(
    postexploit_agent: PostExploitAgent,
    sample_mission: PostExploitMission
) -> None:
    """Test RL policy learns from mission."""
    initial_states = len(postexploit_agent.rl_policy.q_table)
    
    await postexploit_agent.execute_mission(sample_mission, approved=True)
    
    # Q-table should have learned new states
    assert len(postexploit_agent.rl_policy.q_table) >= initial_states


@pytest.mark.asyncio
async def test_execute_action_failure(postexploit_agent: PostExploitAgent) -> None:
    """Test action execution failure."""
    action = Action(
        id="act_fail",
        action_type=PostExploitAction.LATERAL_MOVEMENT,
        source_host="h001",
        target_host="h002",
        method="ssh_key",
        status=ActionStatus.PLANNED
    )
    
    # Use force_failure constraint
    success = await postexploit_agent._execute_action(action, {"force_failure": True})
    
    assert success is False
    assert action.status == ActionStatus.FAILED
    assert action.result["success"] is False
    assert "error" in action.result
