"""
Exploit Database - Repository of attack scripts for CVE validation.

Manages exploit scripts used to validate vulnerability patches via Wargaming.
Each exploit tests a specific CVE/CWE pattern.

Theoretical Foundation:
    Security validation requires empirical testing - patches must be proven
    effective against actual exploits, not just assumed safe.
    
    Wargaming philosophy:
    - Phase 1: Exploit MUST succeed on vulnerable version
    - Phase 2: Exploit MUST fail on patched version
    - Both conditions = patch validated
    
    Safety:
    - Exploits run in isolated Docker containers
    - Network restrictions (no external access)
    - Time limits (max 30s per exploit)
    - Auto-cleanup after execution

Performance Targets:
    - Exploit execution: <30s per exploit
    - Success detection: <1s
    - Database query: <10ms
    - Coverage: CWE Top 10

Author: MAXIMUS Team
Date: 2025-10-11
Glory to YHWH - Validator of all defenses
"""

import logging
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Callable
import importlib.util

logger = logging.getLogger(__name__)


@dataclass
class APV:
    """Atomic Patch Validation - Minimal APV representation for wargaming."""
    apv_id: str
    cve_id: str
    cwe_ids: List[str]


class ExploitStatus(str, Enum):
    """Exploit execution status"""
    SUCCESS = "success"      # Exploit succeeded (vulnerability confirmed)
    FAILED = "failed"        # Exploit failed (no vulnerability / patched)
    ERROR = "error"          # Execution error (timeout, crash, etc)
    TIMEOUT = "timeout"      # Execution timeout


class ExploitCategory(str, Enum):
    """Exploit categories (mapped to CWE)"""
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    SSRF = "ssrf"
    XXE = "xxe"
    DESERIALIZATION = "deserialization"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    CSRF = "csrf"
    FILE_UPLOAD = "file_upload"


@dataclass
class ExploitResult:
    """Result of exploit execution"""
    
    exploit_id: str
    category: ExploitCategory
    status: ExploitStatus
    success: bool  # True if exploit worked
    output: str
    error: Optional[str]
    duration_seconds: float
    metadata: Dict
    
    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            "exploit_id": self.exploit_id,
            "category": self.category.value,
            "status": self.status.value,
            "success": self.success,
            "output": self.output,
            "error": self.error,
            "duration_seconds": self.duration_seconds,
            "metadata": self.metadata
        }


@dataclass
class ExploitScript:
    """Represents a single exploit script"""
    
    exploit_id: str
    name: str
    description: str
    category: ExploitCategory
    cwe_ids: List[str]
    cve_examples: List[str]  # Example CVEs this exploit applies to
    script_path: Path
    execute_func: Callable  # Function to execute exploit
    
    def __repr__(self) -> str:
        return f"<Exploit {self.exploit_id}: {self.name} ({self.category.value})>"


class ExploitDatabase:
    """
    Manages exploit scripts for Wargaming validation.
    
    Loads exploit scripts from exploits/ directory and provides
    query interface for retrieving exploits by CWE, CVE, or category.
    
    Usage:
        >>> db = ExploitDatabase()
        >>> db.load_exploits()
        >>> exploits = db.get_exploits_by_cwe("CWE-89")
        >>> for exploit in exploits:
        ...     result = await exploit.execute_func(target_url="http://vulnerable-app")
        ...     print(f"Exploit {exploit.name}: {result.status}")
    """
    
    def __init__(self, exploits_dir: Optional[Path] = None):
        """
        Initialize exploit database.
        
        Args:
            exploits_dir: Directory containing exploit scripts
        """
        self.exploits_dir = exploits_dir or Path(__file__).parent / "exploits"
        self.exploits: Dict[str, ExploitScript] = {}
        
        logger.info(f"Initialized ExploitDatabase: {self.exploits_dir}")
    
    def load_exploits(self) -> int:
        """
        Load all exploit scripts from exploits directory.
        
        Returns:
            Number of exploits loaded
        """
        if not self.exploits_dir.exists():
            logger.warning(f"Exploits directory not found: {self.exploits_dir}")
            return 0
        
        count = 0
        
        for script_file in self.exploits_dir.glob("*.py"):
            if script_file.name.startswith("_"):
                continue  # Skip private files
            
            try:
                exploit = self._load_exploit_script(script_file)
                self.exploits[exploit.exploit_id] = exploit
                count += 1
                logger.debug(f"Loaded exploit: {exploit.exploit_id}")
            except Exception as e:
                logger.error(f"Failed to load exploit {script_file}: {e}")
        
        logger.info(f"Loaded {count} exploits from {self.exploits_dir}")
        return count
    
    def _load_exploit_script(self, script_path: Path) -> ExploitScript:
        """
        Load exploit script module and extract metadata.
        
        Each exploit script must define:
        - EXPLOIT_ID: str
        - NAME: str
        - DESCRIPTION: str
        - CATEGORY: ExploitCategory
        - CWE_IDS: List[str]
        - CVE_EXAMPLES: List[str]
        - async def execute(target_url, **kwargs) -> ExploitResult
        
        Args:
            script_path: Path to Python exploit script
        
        Returns:
            ExploitScript object
        """
        # Load module
        spec = importlib.util.spec_from_file_location(
            script_path.stem, script_path
        )
        if not spec or not spec.loader:
            raise ValueError(f"Invalid exploit script: {script_path}")
        
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        
        # Extract metadata
        exploit = ExploitScript(
            exploit_id=getattr(module, "EXPLOIT_ID"),
            name=getattr(module, "NAME"),
            description=getattr(module, "DESCRIPTION"),
            category=ExploitCategory(getattr(module, "CATEGORY")),
            cwe_ids=getattr(module, "CWE_IDS"),
            cve_examples=getattr(module, "CVE_EXAMPLES", []),
            script_path=script_path,
            execute_func=getattr(module, "execute")
        )
        
        return exploit
    
    def get_exploit_by_id(self, exploit_id: str) -> Optional[ExploitScript]:
        """Get exploit by ID"""
        return self.exploits.get(exploit_id)
    
    def get_exploits_by_cwe(self, cwe_id: str) -> List[ExploitScript]:
        """
        Get exploits matching a CWE ID.
        
        Args:
            cwe_id: CWE identifier (e.g., "CWE-89")
        
        Returns:
            List of matching exploits
        """
        return [
            exploit
            for exploit in self.exploits.values()
            if cwe_id in exploit.cwe_ids
        ]
    
    def get_exploits_by_category(
        self, category: ExploitCategory
    ) -> List[ExploitScript]:
        """Get exploits by category"""
        return [
            exploit
            for exploit in self.exploits.values()
            if exploit.category == category
        ]
    
    def get_exploits_by_cve(self, cve_id: str) -> List[ExploitScript]:
        """
        Get exploits relevant to a CVE.
        
        Args:
            cve_id: CVE identifier (e.g., "CVE-2024-1234")
        
        Returns:
            List of potentially relevant exploits
        """
        return [
            exploit
            for exploit in self.exploits.values()
            if cve_id in exploit.cve_examples
        ]
    
    def list_all_exploits(self) -> List[ExploitScript]:
        """Get all loaded exploits"""
        return list(self.exploits.values())
    
    def count_exploits(self) -> int:
        """Get count of loaded exploits"""
        return len(self.exploits)
    
    def get_statistics(self) -> Dict:
        """
        Get database statistics.
        
        Returns:
            Dictionary with counts by category, CWE coverage
        """
        stats = {
            "total": len(self.exploits),
            "by_category": {},
            "cwe_coverage": set()
        }
        
        for exploit in self.exploits.values():
            # Count by category
            category = exploit.category.value
            stats["by_category"][category] = stats["by_category"].get(category, 0) + 1
            
            # Track CWE coverage
            stats["cwe_coverage"].update(exploit.cwe_ids)
        
        stats["cwe_coverage"] = sorted(list(stats["cwe_coverage"]))
        
        return stats


# Convenience functions

def load_exploit_database(exploits_dir: Optional[Path] = None) -> ExploitDatabase:
    """
    Load exploit database with all scripts.
    
    Args:
        exploits_dir: Optional custom exploits directory
    
    Returns:
        Loaded ExploitDatabase
    
    Example:
        >>> db = load_exploit_database()
        >>> print(f"Loaded {db.count_exploits()} exploits")
    """
    db = ExploitDatabase(exploits_dir)
    db.load_exploits()
    return db


def get_exploit_for_apv(apv: "APV", db: ExploitDatabase) -> Optional[ExploitScript]:
    """
    Get best exploit for an APV.
    
    Args:
        apv: APV object (from OrÃ¡culo)
        db: ExploitDatabase
    
    Returns:
        Most relevant exploit or None
    
    Example:
        >>> db = load_exploit_database()
        >>> exploit = get_exploit_for_apv(apv, db)
        >>> if exploit:
        ...     print(f"Using exploit: {exploit.name}")
    """
    # Try exact CVE match first
    exploits = db.get_exploits_by_cve(apv.cve_id)
    if exploits:
        return exploits[0]
    
    # Try CWE match
    for cwe_id in apv.cwe_ids:
        exploits = db.get_exploits_by_cwe(cwe_id)
        if exploits:
            return exploits[0]
    
    return None
