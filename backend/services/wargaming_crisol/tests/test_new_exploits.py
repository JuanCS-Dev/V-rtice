"""
Unit tests for new exploits - Phase 4.2 Expansion.

Tests CSRF, File Upload, and XXE exploits.

Author: MAXIMUS Team
Date: 2025-10-11
"""

import pytest
from unittest.mock import Mock, AsyncMock, patch
import httpx

# Import exploits
import sys
from pathlib import Path

exploits_dir = Path(__file__).parent.parent / "exploits"
sys.path.insert(0, str(exploits_dir))

import cwe_352_csrf as csrf
import cwe_434_file_upload as file_upload
import cwe_611_xxe as xxe

from exploit_database import ExploitStatus, ExploitCategory


# Tests: CSRF Exploit (CWE-352)

@pytest.mark.asyncio
async def test_csrf_exploit_success():
    """Test CSRF exploit detects missing CSRF protection"""
    
    # Mock successful state change without CSRF token
    mock_response = Mock()
    mock_response.status_code = 200
    mock_response.text = '{"status": "success", "message": "Transfer complete"}'
    mock_response.headers = {}
    
    with patch("httpx.AsyncClient") as mock_client:
        mock_client.return_value.__aenter__.return_value.post = AsyncMock(
            return_value=mock_response
        )
        
        result = await csrf.execute("http://localhost:8080/api/transfer")
        
        assert result.success is True
        assert result.status == ExploitStatus.SUCCESS
        assert result.category == ExploitCategory.CSRF
        assert "CSRF VULNERABILITY CONFIRMED" in result.output


@pytest.mark.asyncio
async def test_csrf_exploit_protected():
    """Test CSRF exploit fails when protection is present"""
    
    # Mock blocked request (CSRF protection active)
    mock_response = Mock()
    mock_response.status_code = 403
    mock_response.text = '{"error": "CSRF token missing"}'
    mock_response.headers = {"X-CSRF-Token": "required"}
    
    with patch("httpx.AsyncClient") as mock_client:
        mock_client.return_value.__aenter__.return_value.post = AsyncMock(
            return_value=mock_response
        )
        
        result = await csrf.execute("http://localhost:8080/api/transfer")
        
        assert result.success is False
        assert result.status == ExploitStatus.FAILED
        assert "CSRF protection likely present" in result.output


@pytest.mark.asyncio
async def test_csrf_convenience_function():
    """Test CSRF convenience function"""
    
    mock_response = Mock()
    mock_response.status_code = 200
    mock_response.headers = {}
    
    with patch("httpx.AsyncClient") as mock_client:
        mock_client.return_value.__aenter__.return_value.post = AsyncMock(
            return_value=mock_response
        )
        
        vulnerable = await csrf.test_csrf("http://localhost:8080/api/test")
        
        assert isinstance(vulnerable, bool)


# Tests: File Upload Exploit (CWE-434)

@pytest.mark.asyncio
async def test_file_upload_exploit_success():
    """Test file upload exploit detects unrestricted upload"""
    
    # Mock successful malicious file upload
    mock_response = Mock()
    mock_response.status_code = 200
    mock_response.text = '{"status": "success", "filename": "shell.php", "uploaded": true}'
    
    with patch("httpx.AsyncClient") as mock_client:
        mock_client.return_value.__aenter__.return_value.post = AsyncMock(
            return_value=mock_response
        )
        
        result = await file_upload.execute("http://localhost:8080/api/upload")
        
        assert result.success is True
        assert result.status == ExploitStatus.SUCCESS
        assert result.category == ExploitCategory.FILE_UPLOAD
        assert "FILE UPLOAD VULNERABILITY CONFIRMED" in result.output


@pytest.mark.asyncio
async def test_file_upload_exploit_blocked():
    """Test file upload exploit fails when validation present"""
    
    # Mock blocked uploads (file type validation active)
    mock_response = Mock()
    mock_response.status_code = 415
    mock_response.text = '{"error": "File type not allowed"}'
    
    with patch("httpx.AsyncClient") as mock_client:
        # All payloads blocked
        mock_client.return_value.__aenter__.return_value.post = AsyncMock(
            return_value=mock_response
        )
        
        result = await file_upload.execute("http://localhost:8080/api/upload")
        
        assert result.success is False
        assert result.status == ExploitStatus.FAILED
        assert "All malicious upload attempts blocked" in result.output


@pytest.mark.asyncio
async def test_file_upload_convenience_function():
    """Test file upload convenience function"""
    
    mock_response = Mock()
    mock_response.status_code = 415  # Blocked
    
    with patch("httpx.AsyncClient") as mock_client:
        mock_client.return_value.__aenter__.return_value.post = AsyncMock(
            return_value=mock_response
        )
        
        vulnerable = await file_upload.test_file_upload("http://localhost:8080/api/upload")
        
        assert isinstance(vulnerable, bool)
        assert vulnerable is False


# Tests: XXE Exploit (CWE-611)

@pytest.mark.asyncio
async def test_xxe_exploit_success():
    """Test XXE exploit detects vulnerable XML parser"""
    
    # Mock successful XXE (file disclosure)
    mock_response = Mock()
    mock_response.status_code = 200
    mock_response.text = '<result>root:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</result>'
    
    with patch("httpx.AsyncClient") as mock_client:
        mock_client.return_value.__aenter__.return_value.post = AsyncMock(
            return_value=mock_response
        )
        
        result = await xxe.execute("http://localhost:8080/api/xml")
        
        assert result.success is True
        assert result.status == ExploitStatus.SUCCESS
        assert result.category == ExploitCategory.XXE
        assert "XXE VULNERABILITY CONFIRMED" in result.output


@pytest.mark.asyncio
async def test_xxe_exploit_protected():
    """Test XXE exploit fails when parser is hardened"""
    
    # Mock hardened parser (external entities disabled)
    mock_response = Mock()
    mock_response.status_code = 400
    mock_response.text = '{"error": "External entities not allowed"}'
    
    with patch("httpx.AsyncClient") as mock_client:
        # All payloads blocked
        mock_client.return_value.__aenter__.return_value.post = AsyncMock(
            return_value=mock_response
        )
        
        result = await xxe.execute("http://localhost:8080/api/xml")
        
        assert result.success is False
        assert result.status == ExploitStatus.FAILED
        assert "All XXE attempts blocked" in result.output


@pytest.mark.asyncio
async def test_xxe_billion_laughs():
    """Test XXE Billion Laughs DoS detection"""
    
    # Mock billion laughs expansion
    mock_response = Mock()
    mock_response.status_code = 200
    mock_response.text = "lol" * 1000  # Expanded entities
    
    with patch("httpx.AsyncClient") as mock_client:
        mock_client.return_value.__aenter__.return_value.post = AsyncMock(
            return_value=mock_response
        )
        
        result = await xxe.execute("http://localhost:8080/api/xml")
        
        assert result.success is True
        assert "lollollol" in result.output or result.success


@pytest.mark.asyncio
async def test_xxe_convenience_function():
    """Test XXE convenience function"""
    
    mock_response = Mock()
    mock_response.status_code = 400  # Blocked
    
    with patch("httpx.AsyncClient") as mock_client:
        mock_client.return_value.__aenter__.return_value.post = AsyncMock(
            return_value=mock_response
        )
        
        vulnerable = await xxe.test_xxe("http://localhost:8080/api/xml")
        
        assert isinstance(vulnerable, bool)
        assert vulnerable is False


# Tests: Exploit Metadata

def test_csrf_metadata():
    """Test CSRF exploit metadata"""
    assert csrf.EXPLOIT_ID == "cwe_352_csrf"
    assert csrf.NAME == "Cross-Site Request Forgery (CSRF)"
    assert "CWE-352" in csrf.CWE_IDS
    assert csrf.CATEGORY == "csrf"


def test_file_upload_metadata():
    """Test file upload exploit metadata"""
    assert file_upload.EXPLOIT_ID == "cwe_434_file_upload"
    assert file_upload.NAME == "Unrestricted File Upload"
    assert "CWE-434" in file_upload.CWE_IDS
    assert file_upload.CATEGORY == "file_upload"


def test_xxe_metadata():
    """Test XXE exploit metadata"""
    assert xxe.EXPLOIT_ID == "cwe_611_xxe"
    assert xxe.NAME == "XML External Entity (XXE) Injection"
    assert "CWE-611" in xxe.CWE_IDS
    assert xxe.CATEGORY == "xxe"


# Tests: Payload Coverage

def test_file_upload_payloads():
    """Test file upload exploit has diverse payloads"""
    payloads = file_upload.MALICIOUS_PAYLOADS
    
    assert "php_shell" in payloads
    assert "jsp_shell" in payloads
    assert "aspx_shell" in payloads
    assert "double_extension" in payloads
    assert "null_byte" in payloads
    
    assert len(payloads) >= 5


def test_xxe_payloads():
    """Test XXE exploit has diverse payloads"""
    payloads = xxe.XXE_PAYLOADS
    
    assert "file_read" in payloads
    assert "blind_oob" in payloads
    assert "parameter_entity" in payloads
    assert "billion_laughs" in payloads
    assert "php_wrapper" in payloads
    
    assert len(payloads) >= 5


# Integration Tests

@pytest.mark.asyncio
async def test_all_new_exploits_executable():
    """Test that all new exploits can be executed"""
    
    exploits = [
        (csrf, "http://test/api/csrf"),
        (file_upload, "http://test/api/upload"),
        (xxe, "http://test/api/xml"),
    ]
    
    mock_response = Mock()
    mock_response.status_code = 404  # Endpoint not found
    mock_response.text = "Not found"
    
    for exploit_module, url in exploits:
        with patch("httpx.AsyncClient") as mock_client:
            mock_client.return_value.__aenter__.return_value.post = AsyncMock(
                return_value=mock_response
            )
            mock_client.return_value.__aenter__.return_value.request = AsyncMock(
                return_value=mock_response
            )
            
            # Should not crash
            result = await exploit_module.execute(url)
            
            assert result is not None
            assert hasattr(result, 'success')
            assert hasattr(result, 'status')
            assert hasattr(result, 'output')
