"""
Dependency Vulnerability Scanner - MAXIMUS Security Arsenal

Automated scanning of Python dependencies against known CVE databases.
Integrates with safety, pip-audit, and NIST NVD for comprehensive coverage.

Part of MAXIMUS proactive security posture - identifies vulnerabilities before exploitation.
"""

import asyncio
import json
import subprocess
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional

from pydantic import BaseModel, Field


class VulnerabilitySeverity(str, Enum):
    """CVSSv3 severity classification"""
    CRITICAL = "critical"  # 9.0-10.0
    HIGH = "high"  # 7.0-8.9
    MEDIUM = "medium"  # 4.0-6.9
    LOW = "low"  # 0.1-3.9
    UNKNOWN = "unknown"


class VulnerabilityRecord(BaseModel):
    """Individual vulnerability finding"""
    package: str = Field(..., description="Vulnerable package name")
    version: str = Field(..., description="Installed version")
    vulnerability_id: str = Field(..., description="CVE-ID or advisory ID")
    severity: VulnerabilitySeverity
    cvss_score: Optional[float] = Field(None, ge=0.0, le=10.0)
    description: str
    fix_available: bool = Field(default=False)
    fixed_in: Optional[str] = Field(None, description="First fixed version")
    scanner: str = Field(..., description="Scanner that detected this")


class ScanResult(BaseModel):
    """Complete vulnerability scan result"""
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    total_packages: int = Field(..., ge=0)
    vulnerable_packages: int = Field(..., ge=0)
    vulnerabilities: List[VulnerabilityRecord] = Field(default_factory=list)
    severity_breakdown: Dict[VulnerabilitySeverity, int] = Field(default_factory=dict)
    scan_duration_seconds: float = Field(..., ge=0.0)
    scanners_used: List[str] = Field(default_factory=list)
    scan_passed: bool = Field(..., description="No critical/high vulnerabilities found")


@dataclass
class VulnerabilityScanner:
    """
    Multi-scanner vulnerability detection system.
    
    Orchestrates safety, pip-audit, and potentially Trivy for comprehensive
    dependency vulnerability detection across Python ecosystem.
    
    Attributes:
        requirements_path: Path to requirements.txt
        ignore_ids: CVE IDs to ignore (false positives, accepted risks)
        fail_on_severity: Minimum severity to fail the scan
    """
    
    requirements_path: Path = field(default_factory=lambda: Path("requirements.txt"))
    ignore_ids: List[str] = field(default_factory=list)
    fail_on_severity: VulnerabilitySeverity = VulnerabilitySeverity.HIGH
    
    async def scan_with_safety(self) -> List[VulnerabilityRecord]:
        """
        Scan using safety (pyup.io database).
        
        Returns:
            List of vulnerabilities found by safety
            
        Raises:
            RuntimeError: If safety not installed or scan fails
        """
        try:
            result = await asyncio.create_subprocess_exec(
                "safety", "check", 
                "--json",
                "--file", str(self.requirements_path),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            
            if result.returncode not in (0, 64):  # 64 = vulnerabilities found
                raise RuntimeError(f"Safety scan failed: {stderr.decode()}")
            
            if not stdout:
                return []
            
            data = json.loads(stdout.decode())
            vulnerabilities = []
            
            for vuln in data:
                severity = self._classify_severity(vuln.get("cvss_score"))
                
                vulnerabilities.append(VulnerabilityRecord(
                    package=vuln["package"],
                    version=vuln["installed_version"],
                    vulnerability_id=vuln.get("vulnerability_id", "UNKNOWN"),
                    severity=severity,
                    cvss_score=vuln.get("cvss_score"),
                    description=vuln.get("advisory", "No description"),
                    fix_available=bool(vuln.get("vulnerable_spec")),
                    fixed_in=vuln.get("vulnerable_spec"),
                    scanner="safety"
                ))
            
            return vulnerabilities
            
        except FileNotFoundError:
            raise RuntimeError("safety not installed. Run: pip install safety")
    
    async def scan_with_pip_audit(self) -> List[VulnerabilityRecord]:
        """
        Scan using pip-audit (OSV + PyPI Advisories).
        
        Returns:
            List of vulnerabilities found by pip-audit
            
        Raises:
            RuntimeError: If pip-audit not installed or scan fails
        """
        try:
            result = await asyncio.create_subprocess_exec(
                "pip-audit",
                "--format", "json",
                "--requirement", str(self.requirements_path),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await result.communicate()
            
            if result.returncode not in (0, 1):  # 1 = vulnerabilities found
                raise RuntimeError(f"pip-audit failed: {stderr.decode()}")
            
            if not stdout:
                return []
            
            data = json.loads(stdout.decode())
            vulnerabilities = []
            
            for pkg_name, pkg_data in data.get("dependencies", {}).items():
                for vuln in pkg_data.get("vulns", []):
                    vulnerabilities.append(VulnerabilityRecord(
                        package=pkg_name,
                        version=pkg_data["version"],
                        vulnerability_id=vuln["id"],
                        severity=self._classify_severity_from_aliases(vuln),
                        cvss_score=None,  # pip-audit doesn't always provide
                        description=vuln.get("description", "No description"),
                        fix_available=bool(vuln.get("fix_versions")),
                        fixed_in=", ".join(vuln.get("fix_versions", [])),
                        scanner="pip-audit"
                    ))
            
            return vulnerabilities
            
        except FileNotFoundError:
            raise RuntimeError("pip-audit not installed. Run: pip install pip-audit")
    
    async def run_full_scan(self) -> ScanResult:
        """
        Execute comprehensive vulnerability scan using all available scanners.
        
        Returns:
            Complete scan result with deduplicated findings
        """
        start_time = datetime.utcnow()
        all_vulnerabilities: List[VulnerabilityRecord] = []
        scanners_used: List[str] = []
        
        # Run scanners in parallel
        tasks = []
        
        try:
            tasks.append(self.scan_with_safety())
            scanners_used.append("safety")
        except RuntimeError as e:
            print(f"⚠️  Skipping safety: {e}")
        
        try:
            tasks.append(self.scan_with_pip_audit())
            scanners_used.append("pip-audit")
        except RuntimeError as e:
            print(f"⚠️  Skipping pip-audit: {e}")
        
        if not tasks:
            raise RuntimeError("No vulnerability scanners available!")
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for result in results:
            if isinstance(result, Exception):
                print(f"⚠️  Scanner error: {result}")
            else:
                all_vulnerabilities.extend(result)
        
        # Deduplicate by (package, vulnerability_id)
        seen = set()
        deduplicated = []
        for vuln in all_vulnerabilities:
            key = (vuln.package, vuln.vulnerability_id)
            if key not in seen and vuln.vulnerability_id not in self.ignore_ids:
                seen.add(key)
                deduplicated.append(vuln)
        
        # Calculate severity breakdown
        severity_breakdown = {
            VulnerabilitySeverity.CRITICAL: 0,
            VulnerabilitySeverity.HIGH: 0,
            VulnerabilitySeverity.MEDIUM: 0,
            VulnerabilitySeverity.LOW: 0,
            VulnerabilitySeverity.UNKNOWN: 0,
        }
        
        for vuln in deduplicated:
            severity_breakdown[vuln.severity] += 1
        
        # Count total packages
        total_packages = self._count_packages()
        
        # Determine if scan passed
        fail_severities = self._get_fail_severities()
        scan_passed = all(
            severity_breakdown.get(sev, 0) == 0 
            for sev in fail_severities
        )
        
        duration = (datetime.utcnow() - start_time).total_seconds()
        
        return ScanResult(
            timestamp=start_time,
            total_packages=total_packages,
            vulnerable_packages=len(set(v.package for v in deduplicated)),
            vulnerabilities=deduplicated,
            severity_breakdown=severity_breakdown,
            scan_duration_seconds=duration,
            scanners_used=scanners_used,
            scan_passed=scan_passed
        )
    
    def _classify_severity(self, cvss_score: Optional[float]) -> VulnerabilitySeverity:
        """Classify CVSSv3 score into severity level"""
        if cvss_score is None:
            return VulnerabilitySeverity.UNKNOWN
        
        if cvss_score >= 9.0:
            return VulnerabilitySeverity.CRITICAL
        elif cvss_score >= 7.0:
            return VulnerabilitySeverity.HIGH
        elif cvss_score >= 4.0:
            return VulnerabilitySeverity.MEDIUM
        else:
            return VulnerabilitySeverity.LOW
    
    def _classify_severity_from_aliases(self, vuln: Dict) -> VulnerabilitySeverity:
        """Extract severity from pip-audit aliases (CVE IDs)"""
        # pip-audit provides severity in aliases sometimes
        aliases = vuln.get("aliases", [])
        
        # Heuristic: check if CVE mentions severity in description
        description = vuln.get("description", "").lower()
        
        if "critical" in description:
            return VulnerabilitySeverity.CRITICAL
        elif "high" in description:
            return VulnerabilitySeverity.HIGH
        elif "medium" in description or "moderate" in description:
            return VulnerabilitySeverity.MEDIUM
        elif "low" in description:
            return VulnerabilitySeverity.LOW
        
        return VulnerabilitySeverity.UNKNOWN
    
    def _count_packages(self) -> int:
        """Count packages in requirements.txt"""
        try:
            with open(self.requirements_path) as f:
                lines = [
                    line.strip() 
                    for line in f 
                    if line.strip() and not line.startswith("#")
                ]
                return len(lines)
        except FileNotFoundError:
            return 0
    
    def _get_fail_severities(self) -> List[VulnerabilitySeverity]:
        """Get list of severities that should fail the scan"""
        severity_order = [
            VulnerabilitySeverity.CRITICAL,
            VulnerabilitySeverity.HIGH,
            VulnerabilitySeverity.MEDIUM,
            VulnerabilitySeverity.LOW,
        ]
        
        fail_index = severity_order.index(self.fail_on_severity)
        return severity_order[:fail_index + 1]


async def scan_dependencies(
    requirements_path: Optional[Path] = None,
    fail_on_high: bool = True
) -> ScanResult:
    """
    Convenience function to run vulnerability scan.
    
    Args:
        requirements_path: Path to requirements.txt (default: ./requirements.txt)
        fail_on_high: Fail if HIGH or CRITICAL vulnerabilities found
    
    Returns:
        Complete scan result
        
    Example:
        >>> result = await scan_dependencies()
        >>> if not result.scan_passed:
        ...     print(f"Found {result.vulnerable_packages} vulnerable packages!")
    """
    scanner = VulnerabilityScanner(
        requirements_path=requirements_path or Path("requirements.txt"),
        fail_on_severity=VulnerabilitySeverity.HIGH if fail_on_high else VulnerabilitySeverity.CRITICAL
    )
    
    return await scanner.run_full_scan()


if __name__ == "__main__":
    # CLI execution
    async def main():
        print("🔍 MAXIMUS Dependency Vulnerability Scanner")
        print("=" * 50)
        
        result = await scan_dependencies()
        
        print(f"\n📦 Scanned {result.total_packages} packages")
        print(f"⏱️  Duration: {result.scan_duration_seconds:.2f}s")
        print(f"🔧 Scanners: {', '.join(result.scanners_used)}")
        print(f"\n🚨 Found {result.vulnerable_packages} vulnerable packages")
        print(f"   Total vulnerabilities: {len(result.vulnerabilities)}")
        print(f"\n📊 Severity Breakdown:")
        for severity, count in result.severity_breakdown.items():
            if count > 0:
                emoji = {
                    VulnerabilitySeverity.CRITICAL: "🔴",
                    VulnerabilitySeverity.HIGH: "🟠",
                    VulnerabilitySeverity.MEDIUM: "🟡",
                    VulnerabilitySeverity.LOW: "🟢",
                    VulnerabilitySeverity.UNKNOWN: "⚪",
                }[severity]
                print(f"   {emoji} {severity.value.upper()}: {count}")
        
        if result.vulnerabilities:
            print(f"\n📋 Vulnerabilities:")
            for vuln in sorted(result.vulnerabilities, key=lambda v: v.severity.value):
                fix_info = f" (Fix: {vuln.fixed_in})" if vuln.fix_available else " (No fix)"
                print(f"   • {vuln.package} {vuln.version}: {vuln.vulnerability_id} [{vuln.severity.value}]{fix_info}")
        
        print(f"\n{'✅ SCAN PASSED' if result.scan_passed else '❌ SCAN FAILED'}")
        
        return 0 if result.scan_passed else 1
    
    exit(asyncio.run(main()))
