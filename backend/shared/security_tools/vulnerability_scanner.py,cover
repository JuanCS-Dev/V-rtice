> """
> Dependency Vulnerability Scanner - MAXIMUS Security Arsenal
  
> Automated scanning of Python dependencies against known CVE databases.
> Integrates with safety, pip-audit, and NIST NVD for comprehensive coverage.
  
> Part of MAXIMUS proactive security posture - identifies vulnerabilities before exploitation.
> """
  
> import asyncio
> import json
> from dataclasses import dataclass, field
> from datetime import datetime
> from enum import Enum
> from pathlib import Path
  
> from pydantic import BaseModel, Field
  
  
> class VulnerabilitySeverity(str, Enum):
>     """CVSSv3 severity classification"""
>     CRITICAL = "critical"  # 9.0-10.0
>     HIGH = "high"  # 7.0-8.9
>     MEDIUM = "medium"  # 4.0-6.9
>     LOW = "low"  # 0.1-3.9
>     UNKNOWN = "unknown"
  
  
> class VulnerabilityRecord(BaseModel):
>     """Individual vulnerability finding"""
>     package: str = Field(..., description="Vulnerable package name")
>     version: str = Field(..., description="Installed version")
>     vulnerability_id: str = Field(..., description="CVE-ID or advisory ID")
>     severity: VulnerabilitySeverity
>     cvss_score: float | None = Field(None, ge=0.0, le=10.0)
>     description: str
>     fix_available: bool = Field(default=False)
>     fixed_in: str | None = Field(None, description="First fixed version")
>     scanner: str = Field(..., description="Scanner that detected this")
  
  
> class ScanResult(BaseModel):
>     """Complete vulnerability scan result"""
>     timestamp: datetime = Field(default_factory=datetime.utcnow)
>     total_packages: int = Field(..., ge=0)
>     vulnerable_packages: int = Field(..., ge=0)
>     vulnerabilities: list[VulnerabilityRecord] = Field(default_factory=list)
>     severity_breakdown: dict[VulnerabilitySeverity, int] = Field(default_factory=dict)
>     scan_duration_seconds: float = Field(..., ge=0.0)
>     scanners_used: list[str] = Field(default_factory=list)
>     scan_passed: bool = Field(..., description="No critical/high vulnerabilities found")
  
  
> @dataclass
> class VulnerabilityScanner:
>     """
>     Multi-scanner vulnerability detection system.
  
>     Orchestrates safety, pip-audit, and potentially Trivy for comprehensive
>     dependency vulnerability detection across Python ecosystem.
  
>     Attributes:
>         requirements_path: Path to requirements.txt
>         ignore_ids: CVE IDs to ignore (false positives, accepted risks)
>         fail_on_severity: Minimum severity to fail the scan
>     """
  
>     requirements_path: Path = field(default_factory=lambda: Path("requirements.txt"))
>     ignore_ids: list[str] = field(default_factory=list)
>     fail_on_severity: VulnerabilitySeverity = VulnerabilitySeverity.HIGH
  
>     async def scan_with_safety(self) -> list[VulnerabilityRecord]:
>         """
>         Scan using safety (pyup.io database).
  
>         Returns:
>             List of vulnerabilities found by safety
  
>         Raises:
>             RuntimeError: If safety not installed or scan fails
>         """
>         try:
>             result = await asyncio.create_subprocess_exec(
>                 "safety", "check",
>                 "--json",
>                 "--file", str(self.requirements_path),
>                 stdout=asyncio.subprocess.PIPE,
>                 stderr=asyncio.subprocess.PIPE
>             )
  
>             stdout, stderr = await result.communicate()
  
>             if result.returncode not in (0, 64):  # 64 = vulnerabilities found
>                 raise RuntimeError(f"Safety scan failed: {stderr.decode()}")
  
>             if not stdout:
>                 return []
  
>             data = json.loads(stdout.decode())
>             vulnerabilities = []
  
              # Safety can return two formats:
              # 1. Modern dict format: [{"package": ..., "vulnerability_id": ..., ...}, ...]
              # 2. Legacy array format: [[package, spec, installed, vuln_id, advisory], ...]
              
>             for vuln_data in data:
                  # Modern dict format (safety >=2.0)
>                 if isinstance(vuln_data, dict):
>                     cvss_score = vuln_data.get("cvss_score")
>                     vulnerabilities.append(VulnerabilityRecord(
>                         package=vuln_data.get("package", "unknown"),
>                         version=vuln_data.get("installed_version", "unknown"),
>                         vulnerability_id=vuln_data.get("vulnerability_id", "UNKNOWN"),
>                         severity=self._classify_severity(cvss_score) if cvss_score else VulnerabilitySeverity.UNKNOWN,
>                         cvss_score=cvss_score,
>                         description=vuln_data.get("advisory", "No description"),
>                         fix_available=bool(vuln_data.get("vulnerable_spec")),
>                         fixed_in=vuln_data.get("vulnerable_spec"),
>                         scanner="safety"
>                     ))
                  
                  # Legacy array format (safety <2.0)
>                 elif isinstance(vuln_data, list) and len(vuln_data) >= 5:
>                     package, spec, installed, vuln_id, advisory = vuln_data[0], vuln_data[1], vuln_data[2], vuln_data[3], vuln_data[4]
                      
>                     vulnerabilities.append(VulnerabilityRecord(
>                         package=package,
>                         version=installed,
>                         vulnerability_id=vuln_id,
>                         severity=VulnerabilitySeverity.UNKNOWN,
>                         cvss_score=None,
>                         description=advisory,
>                         fix_available=bool(spec),
>                         fixed_in=spec,
>                         scanner="safety"
>                     ))
  
>             return vulnerabilities
  
>         except FileNotFoundError as e:
>             raise RuntimeError("safety not installed. Run: pip install safety") from e
  
>     async def scan_with_pip_audit(self) -> list[VulnerabilityRecord]:
>         """
>         Scan using pip-audit (OSV + PyPI Advisories).
  
>         Returns:
>             List of vulnerabilities found by pip-audit
  
>         Raises:
>             RuntimeError: If pip-audit not installed or scan fails
>         """
>         try:
>             result = await asyncio.create_subprocess_exec(
>                 "pip-audit",
>                 "--format", "json",
>                 "--requirement", str(self.requirements_path),
>                 stdout=asyncio.subprocess.PIPE,
>                 stderr=asyncio.subprocess.PIPE
>             )
  
>             stdout, stderr = await result.communicate()
  
              # pip-audit returns:
              # - 0: no vulns
              # - 1: vulns found OR tool error
              # Check for tool installation errors first
>             if result.returncode == 1 and not stdout:
>                 raise RuntimeError(f"pip-audit scan failed: {stderr.decode()}")
  
>             if result.returncode not in (0, 1):
>                 raise RuntimeError(f"pip-audit scan failed: {stderr.decode()}")
  
>             if not stdout:
>                 return []
  
>             data = json.loads(stdout.decode())
>             vulnerabilities = []
  
              # pip-audit can return either dict or empty array
>             if isinstance(data, list):
                  # Empty result
>                 return []
  
              # pip-audit format: {"dependencies": {"pkg_name": {"version": "...", "vulns": [...]}}}
>             dependencies = data.get("dependencies", {})
              
              # Handle both dict (real format) and list (legacy format) for compatibility
>             if isinstance(dependencies, dict):
                  # Real pip-audit format: dict of package_name -> package_data
>                 for pkg_name, pkg_data in dependencies.items():
>                     pkg_version = pkg_data.get("version")
                      
>                     for vuln in pkg_data.get("vulns", []):
>                         vulnerabilities.append(VulnerabilityRecord(
>                             package=pkg_name,
>                             version=pkg_version,
>                             vulnerability_id=vuln["id"],
>                             severity=self._classify_severity_from_aliases(vuln),
>                             cvss_score=None,  # pip-audit doesn't always provide
>                             description=vuln.get("description", "No description"),
>                             fix_available=bool(vuln.get("fix_versions")),
>                             fixed_in=", ".join(vuln.get("fix_versions", [])),
>                             scanner="pip-audit"
>                         ))
>             elif isinstance(dependencies, list):
                  # Legacy format (if ever used): list of package dicts
>                 for pkg_data in dependencies:
>                     pkg_name = pkg_data.get("name")
>                     pkg_version = pkg_data.get("version")
                      
>                     for vuln in pkg_data.get("vulns", []):
>                         vulnerabilities.append(VulnerabilityRecord(
>                             package=pkg_name,
>                             version=pkg_version,
>                             vulnerability_id=vuln["id"],
>                             severity=self._classify_severity_from_aliases(vuln),
>                             cvss_score=None,
>                             description=vuln.get("description", "No description"),
>                             fix_available=bool(vuln.get("fix_versions")),
>                             fixed_in=", ".join(vuln.get("fix_versions", [])),
>                             scanner="pip-audit"
>                         ))
  
>             return vulnerabilities
  
>         except FileNotFoundError as e:
>             raise RuntimeError("pip-audit not installed. Run: pip install pip-audit") from e
  
>     async def run_full_scan(self) -> ScanResult:
>         """
>         Execute comprehensive vulnerability scan using all available scanners.
  
>         Returns:
>             Complete scan result with deduplicated findings
>         """
>         start_time = datetime.utcnow()
>         all_vulnerabilities: list[VulnerabilityRecord] = []
>         scanners_used: list[str] = []
  
          # Run scanners in parallel
>         tasks = []
  
>         try:
>             tasks.append(self.scan_with_safety())
>             scanners_used.append("safety")
>         except RuntimeError as e:
>             print(f"âš ï¸  Skipping safety: {e}")
  
>         try:
>             tasks.append(self.scan_with_pip_audit())
>             scanners_used.append("pip-audit")
>         except RuntimeError as e:
>             print(f"âš ï¸  Skipping pip-audit: {e}")
  
>         if not tasks:
>             raise RuntimeError("No vulnerability scanners available!")
  
>         results = await asyncio.gather(*tasks, return_exceptions=True)
  
>         for result in results:
>             if isinstance(result, Exception):
>                 print(f"âš ï¸  Scanner error: {result}")
>             else:
>                 all_vulnerabilities.extend(result)
  
          # Deduplicate by (package, vulnerability_id)
>         seen = set()
>         deduplicated = []
>         for vuln in all_vulnerabilities:
>             key = (vuln.package, vuln.vulnerability_id)
>             if key not in seen and vuln.vulnerability_id not in self.ignore_ids:
>                 seen.add(key)
>                 deduplicated.append(vuln)
  
          # Calculate severity breakdown
>         severity_breakdown = {
>             VulnerabilitySeverity.CRITICAL: 0,
>             VulnerabilitySeverity.HIGH: 0,
>             VulnerabilitySeverity.MEDIUM: 0,
>             VulnerabilitySeverity.LOW: 0,
>             VulnerabilitySeverity.UNKNOWN: 0,
>         }
  
>         for vuln in deduplicated:
>             severity_breakdown[vuln.severity] += 1
  
          # Count total packages
>         total_packages = self._count_packages()
  
          # Determine if scan passed
>         fail_severities = self._get_fail_severities()
>         scan_passed = all(
>             severity_breakdown.get(sev, 0) == 0
>             for sev in fail_severities
>         )
  
>         duration = (datetime.utcnow() - start_time).total_seconds()
  
>         return ScanResult(
>             timestamp=start_time,
>             total_packages=total_packages,
>             vulnerable_packages=len({v.package for v in deduplicated}),
>             vulnerabilities=deduplicated,
>             severity_breakdown=severity_breakdown,
>             scan_duration_seconds=duration,
>             scanners_used=scanners_used,
>             scan_passed=scan_passed
>         )
  
>     def _classify_severity(self, cvss_score: float | None) -> VulnerabilitySeverity:
>         """Classify CVSSv3 score into severity level"""
>         if cvss_score is None:
>             return VulnerabilitySeverity.UNKNOWN
  
>         if cvss_score >= 9.0:
>             return VulnerabilitySeverity.CRITICAL
>         elif cvss_score >= 7.0:
>             return VulnerabilitySeverity.HIGH
>         elif cvss_score >= 4.0:
>             return VulnerabilitySeverity.MEDIUM
>         else:
>             return VulnerabilitySeverity.LOW
  
>     def _classify_severity_from_aliases(self, vuln: dict) -> VulnerabilitySeverity:
>         """Extract severity from pip-audit aliases (CVE IDs)"""
          # pip-audit provides severity in aliases sometimes
>         vuln.get("aliases", [])
  
          # Heuristic: check if CVE mentions severity in description
>         description = vuln.get("description", "").lower()
  
>         if "critical" in description:
>             return VulnerabilitySeverity.CRITICAL
>         elif "high" in description:
>             return VulnerabilitySeverity.HIGH
>         elif "medium" in description or "moderate" in description:
>             return VulnerabilitySeverity.MEDIUM
>         elif "low" in description:
>             return VulnerabilitySeverity.LOW
  
>         return VulnerabilitySeverity.UNKNOWN
  
>     def _count_packages(self) -> int:
>         """Count packages in requirements.txt"""
>         try:
>             with open(self.requirements_path) as f:
>                 lines = [
>                     line.strip()
>                     for line in f
>                     if line.strip() and not line.startswith("#")
>                 ]
>                 return len(lines)
>         except FileNotFoundError:
>             return 0
  
>     def _get_fail_severities(self) -> list[VulnerabilitySeverity]:
>         """Get list of severities that should fail the scan"""
>         severity_order = [
>             VulnerabilitySeverity.CRITICAL,
>             VulnerabilitySeverity.HIGH,
>             VulnerabilitySeverity.MEDIUM,
>             VulnerabilitySeverity.LOW,
>         ]
  
>         fail_index = severity_order.index(self.fail_on_severity)
>         return severity_order[:fail_index + 1]
  
  
> async def scan_dependencies(
>     requirements_path: Path | None = None,
>     fail_on_high: bool = True
> ) -> ScanResult:
>     """
>     Convenience function to run vulnerability scan.
  
>     Args:
>         requirements_path: Path to requirements.txt (default: ./requirements.txt)
>         fail_on_high: Fail if HIGH or CRITICAL vulnerabilities found
  
>     Returns:
>         Complete scan result
  
>     Example:
>         >>> result = await scan_dependencies()
>         >>> if not result.scan_passed:
>         ...     print(f"Found {result.vulnerable_packages} vulnerable packages!")
>     """
>     scanner = VulnerabilityScanner(
>         requirements_path=requirements_path or Path("requirements.txt"),
>         fail_on_severity=VulnerabilitySeverity.HIGH if fail_on_high else VulnerabilitySeverity.CRITICAL
>     )
  
>     return await scanner.run_full_scan()
  
  
- if __name__ == "__main__":
      # CLI execution
-     async def main():
-         print("ğŸ” MAXIMUS Dependency Vulnerability Scanner")
-         print("=" * 50)
  
-         result = await scan_dependencies()
  
-         print(f"\nğŸ“¦ Scanned {result.total_packages} packages")
-         print(f"â±ï¸  Duration: {result.scan_duration_seconds:.2f}s")
-         print(f"ğŸ”§ Scanners: {', '.join(result.scanners_used)}")
-         print(f"\nğŸš¨ Found {result.vulnerable_packages} vulnerable packages")
-         print(f"   Total vulnerabilities: {len(result.vulnerabilities)}")
-         print("\nğŸ“Š Severity Breakdown:")
-         for severity, count in result.severity_breakdown.items():
-             if count > 0:
-                 emoji = {
-                     VulnerabilitySeverity.CRITICAL: "ğŸ”´",
-                     VulnerabilitySeverity.HIGH: "ğŸŸ ",
-                     VulnerabilitySeverity.MEDIUM: "ğŸŸ¡",
-                     VulnerabilitySeverity.LOW: "ğŸŸ¢",
-                     VulnerabilitySeverity.UNKNOWN: "âšª",
-                 }[severity]
-                 print(f"   {emoji} {severity.value.upper()}: {count}")
  
-         if result.vulnerabilities:
-             print("\nğŸ“‹ Vulnerabilities:")
-             for vuln in sorted(result.vulnerabilities, key=lambda v: v.severity.value):
-                 fix_info = f" (Fix: {vuln.fixed_in})" if vuln.fix_available else " (No fix)"
-                 print(f"   â€¢ {vuln.package} {vuln.version}: {vuln.vulnerability_id} [{vuln.severity.value}]{fix_info}")
  
-         print(f"\n{'âœ… SCAN PASSED' if result.scan_passed else 'âŒ SCAN FAILED'}")
  
-         return 0 if result.scan_passed else 1
  
-     exit(asyncio.run(main()))
