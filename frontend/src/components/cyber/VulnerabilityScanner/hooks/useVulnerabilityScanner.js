import { useState, useEffect, useCallback, useContext } from 'react';
import logger from '@/utils/logger';
import { AuthContext } from '../../../../contexts/AuthContext';

const API_BASE = 'http://localhost:8000/api/vuln-scanner';

export const useVulnerabilityScanner = () => {
  const { user, getAuthToken } = useContext(AuthContext);

  const [scanData, setScanData] = useState({
    activeScan: null,
    scanHistory: [],
    exploits: []
  });

  const [loading, setLoading] = useState({
    scan: false,
    exploit: false,
    exploits: false
  });

  // Verifica permissão ofensiva
  const hasOffensivePermission =
    user?.permissions?.includes('offensive') ||
    user?.email === 'juan.brainfarma@gmail.com';

  // Headers com autenticação
  const getHeaders = useCallback(() => {
    const token = getAuthToken();
    return {
      'Content-Type': 'application/json',
      'Authorization': token ? `Bearer ${token}` : ''
    };
  }, [getAuthToken]);

  /**
   * Carrega lista de exploits disponíveis
   */
  const loadExploits = useCallback(async () => {
    if (!hasOffensivePermission) return;

    setLoading(prev => ({ ...prev, exploits: true }));
    try {
      const response = await fetch(`${API_BASE}/exploits`, {
        headers: getHeaders()
      });
      const data = await response.json();

      if (response.ok) {
        setScanData(prev => ({ ...prev, exploits: data.exploits || [] }));
      } else {
        logger.error('Erro ao carregar exploits:', data.detail);
      }
    } catch (error) {
      logger.error('Erro ao carregar exploits:', error);
    } finally {
      setLoading(prev => ({ ...prev, exploits: false }));
    }
  }, [hasOffensivePermission, getHeaders]);

  /**
   * Polling para atualizar status do scan
   */
  const pollScanStatus = useCallback((scanId) => {
    const interval = setInterval(async () => {
      try {
        const response = await fetch(`${API_BASE}/scan/${scanId}`, {
          headers: getHeaders()
        });
        const data = await response.json();

        if (response.ok) {
          setScanData(prev => ({ ...prev, activeScan: data }));

          // Para polling quando scan completar
          if (data.status === 'completed' || data.status === 'failed') {
            clearInterval(interval);
          }
        }
      } catch (error) {
        logger.error('Erro ao verificar status do scan:', error);
        clearInterval(interval);
      }
    }, 3000);
  }, [getHeaders]);

  /**
   * Inicia um novo scan de vulnerabilidades
   */
  const startScan = useCallback(async (formData) => {
    if (!hasOffensivePermission) {
      alert('Permissão ofensiva necessária para realizar scans');
      return false;
    }

    setLoading(prev => ({ ...prev, scan: true }));
    try {
      const response = await fetch(`${API_BASE}/scan`, {
        method: 'POST',
        headers: getHeaders(),
        body: JSON.stringify(formData)
      });
      const data = await response.json();

      if (response.ok) {
        setScanData(prev => ({ ...prev, activeScan: data }));
        // Inicia polling para atualizar status
        pollScanStatus(data.scan_id);
        return true;
      } else {
        alert(`Erro ao iniciar scan: ${data.detail}`);
        return false;
      }
    } catch (error) {
      logger.error('Erro ao iniciar scan:', error);
      alert('Erro ao iniciar scan');
      return false;
    } finally {
      setLoading(prev => ({ ...prev, scan: false }));
    }
  }, [hasOffensivePermission, getHeaders, pollScanStatus]);

  /**
   * Executa um exploit
   */
  const executeExploit = useCallback(async (formData) => {
    if (!hasOffensivePermission) {
      alert('Permissão ofensiva necessária para executar exploits');
      return false;
    }

    setLoading(prev => ({ ...prev, exploit: true }));
    try {
      const response = await fetch(`${API_BASE}/exploit`, {
        method: 'POST',
        headers: getHeaders(),
        body: JSON.stringify(formData)
      });
      const data = await response.json();

      if (response.ok) {
        alert(`Exploit executado: ${data.message}`);
        return true;
      } else {
        alert(`Erro ao executar exploit: ${data.detail}`);
        return false;
      }
    } catch (error) {
      logger.error('Erro ao executar exploit:', error);
      alert('Erro ao executar exploit');
      return false;
    } finally {
      setLoading(prev => ({ ...prev, exploit: false }));
    }
  }, [hasOffensivePermission, getHeaders]);

  // Carrega exploits ao montar
  useEffect(() => {
    if (hasOffensivePermission) {
      loadExploits();
    }
  }, [hasOffensivePermission, loadExploits]);

  return {
    scanData,
    loading,
    hasOffensivePermission,
    startScan,
    executeExploit
  };
};

export default useVulnerabilityScanner;
