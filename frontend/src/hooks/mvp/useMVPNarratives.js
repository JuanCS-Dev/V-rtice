/**
 * useMVPNarratives - MVP Narratives Hook
 *
 * Fetches and manages system narratives generated by MVP.
 * Supports filtering by tone, NQS score, and pagination.
 *
 * Port: 8153
 * Created: 2025-10-31
 * Governed by: Constituição Vértice v3.0
 *
 * @param {Object} filters - Query filters (tone, min_nqs, limit)
 * @param {Object} options - Hook options (pollingInterval, enabled)
 * @returns {Object} { narratives, isLoading, error, generateNarrative, refetch }
 */

import { useState, useEffect, useCallback } from 'react';
import { mvpService } from '../../services/mvp/mvpService';
import logger from '../../utils/logger';

const DEFAULT_POLLING_INTERVAL = 60000; // 60s
const DEFAULT_LIMIT = 20;

export const useMVPNarratives = (filters = {}, options = {}) => {
  const {
    pollingInterval = DEFAULT_POLLING_INTERVAL,
    enabled = true,
  } = options;

  const [narratives, setNarratives] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  const queryParams = {
    limit: filters.limit || DEFAULT_LIMIT,
    ...filters,
  };

  const fetchNarratives = useCallback(async () => {
    if (!enabled) return;

    try {
      setError(null);
      const response = await mvpService.listNarratives(queryParams);
      setNarratives(response);
      setIsLoading(false);
      logger.debug(`[useMVPNarratives] Fetched ${response.length} narratives`);
    } catch (err) {
      logger.error('[useMVPNarratives] Failed to fetch narratives:', err);
      setError(err.message);
      setIsLoading(false);
    }
  }, [enabled, JSON.stringify(queryParams)]);

  useEffect(() => {
    if (!enabled) return;

    // Initial fetch
    fetchNarratives();

    // Periodic polling
    const interval = setInterval(fetchNarratives, pollingInterval);

    return () => clearInterval(interval);
  }, [enabled, pollingInterval, fetchNarratives]);

  // Generate new narrative
  const generateNarrative = useCallback(async (params = {}) => {
    try {
      const newNarrative = await mvpService.generateNarrative(params);
      logger.info('[useMVPNarratives] Narrative generated:', newNarrative.narrative_id);

      // Refresh narratives list
      await fetchNarratives();

      return newNarrative;
    } catch (err) {
      logger.error('[useMVPNarratives] Failed to generate narrative:', err);
      throw err;
    }
  }, [fetchNarratives]);

  // Calculate statistics
  const stats = narratives.length > 0 ? {
    total: narratives.length,
    byTone: {
      reflective: narratives.filter(n => n.tone === 'reflective').length,
      urgent: narratives.filter(n => n.tone === 'urgent').length,
      informative: narratives.filter(n => n.tone === 'informative').length,
    },
    avgNQS: Math.round(
      narratives.reduce((sum, n) => sum + (n.nqs || 0), 0) / narratives.length
    ),
    avgWordCount: Math.round(
      narratives.reduce((sum, n) => sum + (n.word_count || 0), 0) / narratives.length
    ),
  } : null;

  return {
    narratives,
    isLoading,
    error,
    stats,
    generateNarrative,
    refetch: fetchNarratives,
  };
};

export default useMVPNarratives;
