#!/usr/bin/env python3
"""
Coverage Hunter 100% - Automated Backend Coverage Scanner & Fixer
Doctrine: Artigo II (Padrão Pagani) + Artigo VI (Silêncio Operacional)
"""
import json
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Tuple

class CoverageHunter:
    def __init__(self, backend_root: Path):
        self.backend_root = backend_root
        self.report_dir = backend_root.parent / "docs" / "backend_100"
        self.report_dir.mkdir(parents=True, exist_ok=True)
        
    def scan_coverage(self) -> Dict:
        """Executa pytest com coverage em TODO o backend"""
        print("🔍 Scanning backend coverage...")
        
        cmd = [
            "pytest",
            str(self.backend_root),
            f"--cov={self.backend_root}",
            "--cov-report=json:coverage_backend_scan_auto.json",
            "--cov-report=term-missing",
            "-v",
            "--tb=short"
        ]
        
        result = subprocess.run(cmd, cwd=self.backend_root.parent, capture_output=True, text=True)
        
        # Load coverage data
        cov_file = self.backend_root.parent / "coverage_backend_scan_auto.json"
        if not cov_file.exists():
            print(f"❌ Coverage file not found: {cov_file}")
            return {}
            
        with open(cov_file) as f:
            return json.load(f)
    
    def analyze_gaps(self, coverage_data: Dict) -> List[Tuple[str, float, List[int]]]:
        """Analisa gaps de cobertura e retorna lista ordenada por prioridade"""
        gaps = []
        
        files = coverage_data.get("files", {})
        for filepath, data in files.items():
            # Ignora __init__, conftest, migrations, tests
            if any(x in filepath for x in ["__init__", "conftest", "migrations/", "tests/", "test_"]):
                continue
                
            # Ignora consciousness (projeto separado)
            if "consciousness/" in filepath:
                continue
            
            coverage = data.get("summary", {}).get("percent_covered", 100)
            missing_lines = data.get("missing_lines", [])
            
            if coverage < 100:
                gaps.append((filepath, coverage, missing_lines))
        
        # Ordena por menor cobertura (mais crítico primeiro)
        gaps.sort(key=lambda x: x[1])
        return gaps
    
    def generate_test_template(self, filepath: str, missing_lines: List[int]) -> str:
        """Gera template de teste para cobrir linhas faltantes"""
        module_name = Path(filepath).stem
        test_content = f'''"""
Tests for {module_name} - 100% Coverage Target
Generated by Coverage Hunter
"""
import pytest
from unittest.mock import Mock, patch, AsyncMock

# TODO: Import target module
# from backend.{filepath.replace("/", ".")} import TargetClass

class Test{module_name.title().replace("_", "")}Coverage:
    """Tests targeting missing lines: {missing_lines}"""
    
    @pytest.fixture
    def mock_dependencies(self):
        """Mock all external dependencies"""
        return {{}
    
    # Edge case tests for lines: {missing_lines[:5]}
    def test_edge_case_1(self, mock_dependencies):
        """Cover edge case scenario"""
        # TODO: Implement test targeting line {missing_lines[0] if missing_lines else "X"}
        pass
    
    def test_error_handling(self, mock_dependencies):
        """Cover error branches"""
        # TODO: Force error conditions to cover exception handlers
        pass
    
    @pytest.mark.asyncio
    async def test_async_edge_cases(self, mock_dependencies):
        """Cover async edge cases"""
        # TODO: Test async error paths
        pass
'''
        return test_content
    
    def generate_fix_script(self, filepath: str, missing_lines: List[int]) -> str:
        """Gera script Python para adicionar testes inline"""
        return f'''
# Fix script for {filepath}
# Missing lines: {missing_lines}

def add_coverage_tests():
    """Add tests to cover missing lines"""
    
    # Strategy 1: Add unit tests for uncovered branches
    # Strategy 2: Add integration tests for error paths
    # Strategy 3: Add parametrized tests for edge cases
    
    print("✅ Tests added for {filepath}")

if __name__ == "__main__":
    add_coverage_tests()
'''
    
    def create_battle_plan(self, gaps: List[Tuple[str, float, List[int]]]) -> str:
        """Cria plano de ataque estruturado"""
        total_files = len(gaps)
        total_missing = sum(len(lines) for _, _, lines in gaps)
        
        plan = f"""
# BACKEND 100% ABSOLUTE COVERAGE - BATTLE PLAN
Generated: {subprocess.check_output(['date'], text=True).strip()}
Total Files: {total_files}
Total Missing Lines: {total_missing}

## PRIORITY QUEUE (Lowest coverage first):

"""
        for i, (filepath, cov, lines) in enumerate(gaps, 1):
            rel_path = filepath.replace(str(self.backend_root), "backend")
            plan += f"{i}. **{rel_path}**: {cov:.2f}% (-{len(lines)} lines)\n"
            plan += f"   Missing: {lines[:10]}{' ...' if len(lines) > 10 else ''}\n\n"
        
        plan += f"""
## EXECUTION STRATEGY:

1. **Batch Processing**: Group files by module
2. **Parallel Testing**: Run tests in parallel where possible
3. **Incremental Commits**: Commit after each 5% global improvement
4. **Documentation**: Update docs/backend_100/ after each commit

## ESTIMATED TIME:
- Files < 80%: ~15min each
- Files 80-95%: ~5min each  
- Files 95-99%: ~2min each

Total ETA: ~{total_files * 5} minutes

## START COMMAND:
```bash
python scripts/coverage_hunter_100.py --execute
```
"""
        return plan
    
    def execute_fixes(self, gaps: List[Tuple[str, float, List[int]]]):
        """Executa correções automatizadas"""
        print(f"\n🎯 Executing fixes for {len(gaps)} files...\n")
        
        for i, (filepath, cov, lines) in enumerate(gaps, 1):
            rel_path = filepath.replace(str(self.backend_root) + "/", "")
            print(f"[{i}/{len(gaps)}] {rel_path}: {cov:.2f}%")
            
            # Cria test file se não existir
            test_file = self.backend_root / "tests" / f"test_{Path(filepath).stem}_coverage.py"
            if not test_file.exists():
                test_content = self.generate_test_template(filepath, lines)
                test_file.write_text(test_content)
                print(f"  ✅ Created: {test_file.relative_to(self.backend_root.parent)}")
            
            # Executa testes para este módulo específico
            result = subprocess.run(
                ["pytest", str(test_file), "-v"],
                cwd=self.backend_root.parent,
                capture_output=True
            )
            
            if result.returncode == 0:
                print(f"  ✅ Tests passing")
            else:
                print(f"  ⚠️  Tests need implementation")
    
    def save_report(self, gaps: List[Tuple[str, float, List[int]]], plan: str):
        """Salva relatório em docs/backend_100/"""
        timestamp = subprocess.check_output(["date", "+%Y%m%d_%H%M%S"], text=True).strip()
        
        report_file = self.report_dir / f"coverage_scan_{timestamp}.md"
        report_file.write_text(plan)
        
        print(f"\n📄 Report saved: {report_file}")

def main():
    backend_root = Path(__file__).parent.parent / "backend"
    hunter = CoverageHunter(backend_root)
    
    # Scan
    print("=" * 60)
    print("COVERAGE HUNTER 100% - AUTOMATED SCANNER")
    print("=" * 60)
    
    coverage_data = hunter.scan_coverage()
    if not coverage_data:
        print("❌ Failed to generate coverage data")
        return 1
    
    # Analyze
    gaps = hunter.analyze_gaps(coverage_data)
    print(f"\n📊 Found {len(gaps)} files below 100%")
    
    # Plan
    plan = hunter.create_battle_plan(gaps)
    print(plan)
    
    # Save
    hunter.save_report(gaps, plan)
    
    # Execute?
    if "--execute" in sys.argv:
        hunter.execute_fixes(gaps)
        print("\n🎯 Execution complete. Re-run scan to verify.")
    else:
        print("\n💡 Run with --execute to auto-generate test templates")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
