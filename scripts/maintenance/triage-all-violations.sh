#!/bin/bash
set -euo pipefail

# ============================================================
# TRIAGE_ALL_VIOLATIONS.sh
# DOUTRINA VÉRTICE - FASE B: DIA 1
# Categorização automatizada de 413 violações
# ============================================================

REPO_ROOT="/home/juan/vertice-dev"
BACKEND_DIR="$REPO_ROOT/backend/services"
REPORTS_DIR="$REPO_ROOT/violation_reports"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}============================================================${NC}"
echo -e "${BLUE}  DOUTRINA VÉRTICE - TRIAGE AUTOMATIZADO${NC}"
echo -e "${BLUE}  Target: 413 violações → 8 categorias${NC}"
echo -e "${BLUE}============================================================${NC}"
echo ""

# Clean reports directory
rm -rf "$REPORTS_DIR"/*
mkdir -p "$REPORTS_DIR"

# ============================================================
# CATEGORIA 1: Abstract Methods (ABC)
# Status: ✅ ACCEPTABLE (design pattern)
# ============================================================
echo -e "${YELLOW}[1/8]${NC} Scanning: Abstract Methods (ABC)..."
{
    echo "# CATEGORIA 1: Abstract Methods (ABC)"
    echo "# Status: ✅ ACCEPTABLE"
    echo "# Justificativa: Pattern de design Python - ABC com @abstractmethod"
    echo ""

    # Find pass in abstract methods
    find "$BACKEND_DIR" -name "*.py" -type f -exec grep -Hn "pass" {} \; | while IFS=: read -r file line content; do
        # Check if file contains ABC imports and abstractmethod
        if grep -q "from abc import" "$file" && grep -q "@abstractmethod" "$file"; then
            # Check context around the pass
            context=$(sed -n "$((line-5)),$((line+2))p" "$file")
            if echo "$context" | grep -q "@abstractmethod"; then
                echo "$file:$line:$content"
            fi
        fi
    done
} > "$REPORTS_DIR/1_abstract_methods.txt"

COUNT_1=$(grep "^/" "$REPORTS_DIR/1_abstract_methods.txt" 2>/dev/null | wc -l)
echo -e "  Found: ${GREEN}$COUNT_1${NC} abstract methods"

# ============================================================
# CATEGORIA 2: Auto-generated Code (gRPC, Protobuf)
# Status: ✅ ACCEPTABLE (generated by tooling)
# ============================================================
echo -e "${YELLOW}[2/8]${NC} Scanning: Auto-generated Code..."
{
    echo "# CATEGORIA 2: Auto-generated Code"
    echo "# Status: ✅ ACCEPTABLE"
    echo "# Justificativa: Código gerado por protoc, gRPC, etc."
    echo ""

    find "$BACKEND_DIR" -name "*_pb2.py" -o -name "*_pb2_grpc.py" -o -name "*.g.py" | while read -r file; do
        grep -Hn "pass\|TODO\|NotImplementedError" "$file" 2>/dev/null || true
    done
} > "$REPORTS_DIR/2_autogenerated.txt"

COUNT_2=$(grep "^/" "$REPORTS_DIR/2_autogenerated.txt" 2>/dev/null | wc -l)
echo -e "  Found: ${GREEN}$COUNT_2${NC} auto-generated violations"

# ============================================================
# CATEGORIA 3: Pydantic/Config Classes
# Status: ✅ ACCEPTABLE (configuration pattern)
# ============================================================
echo -e "${YELLOW}[3/8]${NC} Scanning: Pydantic/Config Classes..."
{
    echo "# CATEGORIA 3: Pydantic/Config Classes"
    echo "# Status: ✅ ACCEPTABLE"
    echo "# Justificativa: Config nested classes (Pydantic, Tortoise ORM)"
    echo ""

    find "$BACKEND_DIR" -name "*.py" -type f -exec grep -Hn "class.*Config:" {} \; | while IFS=: read -r file line content; do
        # Check if next 5 lines contain only pass
        next_lines=$(sed -n "$((line+1)),$((line+5))p" "$file")
        if echo "$next_lines" | grep -q "^\s*pass\s*$"; then
            echo "$file:$line:$content"
        fi
    done
} > "$REPORTS_DIR/3_config_classes.txt"

COUNT_3=$(grep "^/" "$REPORTS_DIR/3_config_classes.txt" 2>/dev/null | wc -l)
echo -e "  Found: ${GREEN}$COUNT_3${NC} config class patterns"

# ============================================================
# CATEGORIA 4: Test Fixtures
# Status: ✅ ACCEPTABLE (test infrastructure)
# ============================================================
echo -e "${YELLOW}[4/8]${NC} Scanning: Test Fixtures..."
{
    echo "# CATEGORIA 4: Test Fixtures"
    echo "# Status: ✅ ACCEPTABLE"
    echo "# Justificativa: Fixtures pytest, setup/teardown vazios por design"
    echo ""

    find "$BACKEND_DIR" -path "*/tests/*.py" -o -path "*/test_*.py" | while read -r file; do
        grep -Hn "pass" "$file" | while IFS=: read -r f line content; do
            # Check if in fixture or setup/teardown
            context=$(sed -n "$((line-3)),$((line))p" "$f")
            if echo "$context" | grep -Eq "@pytest.fixture|def setUp|def tearDown|def setUpClass"; then
                echo "$f:$line:$content"
            fi
        done
    done
} > "$REPORTS_DIR/4_test_fixtures.txt"

COUNT_4=$(grep "^/" "$REPORTS_DIR/4_test_fixtures.txt" 2>/dev/null | wc -l)
echo -e "  Found: ${GREEN}$COUNT_4${NC} test fixtures"

# ============================================================
# CATEGORIA 5: Silent Exception Handlers
# Status: 🔴 CRITICAL (suppresses errors)
# ============================================================
echo -e "${YELLOW}[5/8]${NC} Scanning: Silent Exception Handlers..."
{
    echo "# CATEGORIA 5: Silent Exception Handlers"
    echo "# Status: 🔴 CRITICAL"
    echo "# Ação: Adicionar logging obrigatório"
    echo ""

    find "$BACKEND_DIR" -name "*.py" -type f ! -path "*/tests/*" -exec grep -Hn "except.*:" {} \; | while IFS=: read -r file line content; do
        # Check if next line is pass
        next_line=$(sed -n "$((line+1))p" "$file")
        if echo "$next_line" | grep -Eq "^\s*pass\s*$"; then
            echo "$file:$line:SILENT_EXCEPTION: $content"
        fi
    done
} > "$REPORTS_DIR/5_silent_exceptions.txt"

COUNT_5=$(grep "^/" "$REPORTS_DIR/5_silent_exceptions.txt" 2>/dev/null | wc -l)
echo -e "  Found: ${RED}$COUNT_5${NC} silent exception handlers (CRITICAL)"

# ============================================================
# CATEGORIA 6: Production TODOs
# Status: 🟠 HIGH (incomplete work)
# ============================================================
echo -e "${YELLOW}[6/8]${NC} Scanning: Production TODOs..."
{
    echo "# CATEGORIA 6: Production TODOs"
    echo "# Status: 🟠 HIGH"
    echo "# Ação: Implementar ou converter em GitHub Issues"
    echo ""

    find "$BACKEND_DIR" -name "*.py" -type f ! -path "*/tests/*" -exec grep -Hn "TODO\|FIXME\|HACK" {} \; 2>/dev/null || true
} > "$REPORTS_DIR/6_production_todos.txt"

COUNT_6=$(grep "^/" "$REPORTS_DIR/6_production_todos.txt" 2>/dev/null | wc -l)
echo -e "  Found: ${YELLOW}$COUNT_6${NC} production TODOs/FIXMEs (HIGH)"

# ============================================================
# CATEGORIA 7: Empty Implementations
# Status: 🔴 CRITICAL (non-functional code)
# ============================================================
echo -e "${YELLOW}[7/8]${NC} Scanning: Empty Implementations..."
{
    echo "# CATEGORIA 7: Empty Implementations"
    echo "# Status: 🔴 CRITICAL"
    echo "# Ação: Implementar funcionalidade real ou remover"
    echo ""

    find "$BACKEND_DIR" -name "*.py" -type f ! -path "*/tests/*" -exec grep -Hn "def " {} \; | while IFS=: read -r file line content; do
        # Skip abstract methods
        if grep -q "from abc import" "$file" 2>/dev/null; then
            context=$(sed -n "$((line-3)),$((line))p" "$file")
            if echo "$context" | grep -q "@abstractmethod"; then
                continue
            fi
        fi

        # Check if function body is only pass
        next_lines=$(sed -n "$((line+1)),$((line+3))p" "$file")
        if echo "$next_lines" | grep -Eq "^\s*pass\s*$" && ! echo "$next_lines" | grep -Eq "^\s*[^p]"; then
            echo "$file:$line:EMPTY_IMPL: $content"
        fi
    done
} > "$REPORTS_DIR/7_empty_implementations.txt"

COUNT_7=$(grep "^/" "$REPORTS_DIR/7_empty_implementations.txt" 2>/dev/null | wc -l)
echo -e "  Found: ${RED}$COUNT_7${NC} empty implementations (CRITICAL)"

# ============================================================
# CATEGORIA 8: NotImplementedError
# Status: 🔴 CRITICAL (broken functionality)
# ============================================================
echo -e "${YELLOW}[8/8]${NC} Scanning: NotImplementedError..."
{
    echo "# CATEGORIA 8: NotImplementedError"
    echo "# Status: 🔴 CRITICAL"
    echo "# Ação: Implementar funcionalidade completa"
    echo ""

    find "$BACKEND_DIR" -name "*.py" -type f ! -path "*/tests/*" -exec grep -Hn "NotImplementedError\|raise NotImplementedError" {} \; 2>/dev/null || true
} > "$REPORTS_DIR/8_not_implemented.txt"

COUNT_8=$(grep "^/" "$REPORTS_DIR/8_not_implemented.txt" 2>/dev/null | wc -l)
echo -e "  Found: ${RED}$COUNT_8${NC} NotImplementedError (CRITICAL)"

# ============================================================
# Generate Summary
# ============================================================
echo ""
echo -e "${BLUE}============================================================${NC}"
echo -e "${BLUE}  TRIAGE SUMMARY${NC}"
echo -e "${BLUE}============================================================${NC}"

TOTAL_ACCEPTABLE=$((COUNT_1 + COUNT_2 + COUNT_3 + COUNT_4))
TOTAL_CRITICAL=$((COUNT_5 + COUNT_7 + COUNT_8))
TOTAL_HIGH=$COUNT_6
TOTAL_ALL=$((TOTAL_ACCEPTABLE + TOTAL_CRITICAL + TOTAL_HIGH))

{
    echo "# TRIAGE SUMMARY - DOUTRINA VÉRTICE"
    echo "# Generated: $(date '+%Y-%m-%d %H:%M:%S')"
    echo ""
    echo "## Overview"
    echo "- **Total Violations Scanned**: $TOTAL_ALL"
    echo "- **✅ Acceptable**: $TOTAL_ACCEPTABLE (abstract methods, generated code, configs, fixtures)"
    echo "- **🔴 Critical**: $TOTAL_CRITICAL (silent exceptions, empty implementations, NotImplementedError)"
    echo "- **🟠 High**: $TOTAL_HIGH (production TODOs)"
    echo ""
    echo "## Breakdown by Category"
    echo ""
    echo "### ✅ ACCEPTABLE ($TOTAL_ACCEPTABLE)"
    echo "1. Abstract Methods (ABC): $COUNT_1"
    echo "2. Auto-generated Code: $COUNT_2"
    echo "3. Pydantic/Config Classes: $COUNT_3"
    echo "4. Test Fixtures: $COUNT_4"
    echo ""
    echo "### 🔴 CRITICAL ($TOTAL_CRITICAL) - MUST FIX"
    echo "5. Silent Exception Handlers: $COUNT_5"
    echo "7. Empty Implementations: $COUNT_7"
    echo "8. NotImplementedError: $COUNT_8"
    echo ""
    echo "### 🟠 HIGH ($TOTAL_HIGH) - SHOULD FIX"
    echo "6. Production TODOs/FIXMEs: $COUNT_6"
    echo ""
    echo "## Action Items"
    echo ""
    echo "### Immediate (DIA 2)"
    echo "- [ ] Review and fix $COUNT_5 silent exception handlers"
    echo "- [ ] Add logging to all except blocks"
    echo ""
    echo "### DIA 3"
    echo "- [ ] Review $COUNT_7 empty implementations"
    echo "- [ ] Implement or remove dead code"
    echo ""
    echo "### DIA 4"
    echo "- [ ] Fix $COUNT_8 NotImplementedError"
    echo "- [ ] Resolve $COUNT_6 production TODOs"
    echo ""
    echo "### DIA 5"
    echo "- [ ] Document $TOTAL_ACCEPTABLE acceptable exceptions in TECHNICAL_DEBT_EXCEPTIONS.md"
    echo "- [ ] Final validation: confirm 0 critical violations"
    echo ""
    echo "## Files Generated"
    echo "- \`violation_reports/1_abstract_methods.txt\` - $COUNT_1 items"
    echo "- \`violation_reports/2_autogenerated.txt\` - $COUNT_2 items"
    echo "- \`violation_reports/3_config_classes.txt\` - $COUNT_3 items"
    echo "- \`violation_reports/4_test_fixtures.txt\` - $COUNT_4 items"
    echo "- \`violation_reports/5_silent_exceptions.txt\` - $COUNT_5 items ⚠️"
    echo "- \`violation_reports/6_production_todos.txt\` - $COUNT_6 items ⚠️"
    echo "- \`violation_reports/7_empty_implementations.txt\` - $COUNT_7 items ⚠️"
    echo "- \`violation_reports/8_not_implemented.txt\` - $COUNT_8 items ⚠️"
    echo ""
    echo "## Next Steps"
    echo "1. Manual review of acceptable violations → create TECHNICAL_DEBT_EXCEPTIONS.md"
    echo "2. Create fix tickets for critical violations"
    echo "3. Execute automated fixes (DIA 2-4)"
    echo "4. Final validation (DIA 5)"
    echo ""
} > "$REPORTS_DIR/TRIAGE_SUMMARY.md"

# Print summary to console
cat "$REPORTS_DIR/TRIAGE_SUMMARY.md"

echo ""
echo -e "${GREEN}✅ Triage complete!${NC}"
echo -e "Reports generated in: ${BLUE}$REPORTS_DIR/${NC}"
echo ""
echo -e "${YELLOW}Next: Manual review → create TECHNICAL_DEBT_EXCEPTIONS.md${NC}"
