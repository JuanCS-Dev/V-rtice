"""
Tests for backend/shared/security_tools/vulnerability_scanner.py
Target: 100% coverage - World-class vulnerability detection testing
"""

import asyncio
import json
from datetime import datetime
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, Mock, patch
from typing import Dict, List

import pytest

from backend.shared.security_tools.vulnerability_scanner import (
    VulnerabilityRecord,
    VulnerabilitySeverity,
    VulnerabilityScanner,
    ScanResult,
    scan_dependencies,
)


# ============================================================================
# FIXTURES
# ============================================================================


@pytest.fixture
def mock_requirements_file(tmp_path):
    """Create temporary requirements.txt for testing."""
    req_file = tmp_path / "requirements.txt"
    req_file.write_text("""
# Test requirements
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.5.0
httpx==0.25.1
# Old vulnerable package
requests==2.25.0
""".strip())
    return req_file


@pytest.fixture
def mock_empty_requirements(tmp_path):
    """Create empty requirements.txt."""
    req_file = tmp_path / "empty_requirements.txt"
    req_file.write_text("")
    return req_file


@pytest.fixture
def scanner(mock_requirements_file):
    """Create VulnerabilityScanner instance."""
    return VulnerabilityScanner(
        requirements_path=mock_requirements_file,
        ignore_ids=[],
        fail_on_severity=VulnerabilitySeverity.HIGH
    )


@pytest.fixture
def sample_vulnerability_record():
    """Create sample vulnerability record."""
    return VulnerabilityRecord(
        package="requests",
        version="2.25.0",
        vulnerability_id="CVE-2023-32681",
        severity=VulnerabilitySeverity.HIGH,
        cvss_score=8.5,
        description="Unintended leak of Proxy-Authorization header",
        fix_available=True,
        fixed_in="2.31.0",
        scanner="safety"
    )


# ============================================================================
# ENUM TESTS
# ============================================================================


class TestVulnerabilitySeverity:
    """Test VulnerabilitySeverity enum."""
    
    def test_severity_levels_exist(self):
        """Test all severity levels are defined."""
        assert VulnerabilitySeverity.CRITICAL == "critical"
        assert VulnerabilitySeverity.HIGH == "high"
        assert VulnerabilitySeverity.MEDIUM == "medium"
        assert VulnerabilitySeverity.LOW == "low"
        assert VulnerabilitySeverity.UNKNOWN == "unknown"
    
    def test_severity_enum_values(self):
        """Test severity enum string values."""
        severities = [
            VulnerabilitySeverity.CRITICAL,
            VulnerabilitySeverity.HIGH,
            VulnerabilitySeverity.MEDIUM,
            VulnerabilitySeverity.LOW,
            VulnerabilitySeverity.UNKNOWN,
        ]
        
        for severity in severities:
            assert isinstance(severity.value, str)
            assert severity.value in ["critical", "high", "medium", "low", "unknown"]


# ============================================================================
# MODEL TESTS
# ============================================================================


class TestVulnerabilityRecord:
    """Test VulnerabilityRecord model."""
    
    def test_vulnerability_record_creation(self):
        """Test creating vulnerability record."""
        record = VulnerabilityRecord(
            package="test-package",
            version="1.0.0",
            vulnerability_id="CVE-2023-12345",
            severity=VulnerabilitySeverity.CRITICAL,
            cvss_score=9.8,
            description="Critical vulnerability",
            fix_available=True,
            fixed_in="1.0.1",
            scanner="safety"
        )
        
        assert record.package == "test-package"
        assert record.version == "1.0.0"
        assert record.vulnerability_id == "CVE-2023-12345"
        assert record.severity == VulnerabilitySeverity.CRITICAL
        assert record.cvss_score == 9.8
        assert record.description == "Critical vulnerability"
        assert record.fix_available is True
        assert record.fixed_in == "1.0.1"
        assert record.scanner == "safety"
    
    def test_vulnerability_record_optional_fields(self):
        """Test vulnerability record with optional fields."""
        record = VulnerabilityRecord(
            package="test-package",
            version="1.0.0",
            vulnerability_id="TEST-001",
            severity=VulnerabilitySeverity.LOW,
            description="Low severity issue",
            scanner="pip-audit"
        )
        
        assert record.cvss_score is None
        assert record.fixed_in is None
        assert record.fix_available is False
    
    def test_cvss_score_validation(self):
        """Test CVSS score must be between 0.0 and 10.0."""
        # Valid scores
        for score in [0.0, 5.0, 10.0]:
            record = VulnerabilityRecord(
                package="test",
                version="1.0.0",
                vulnerability_id="TEST-001",
                severity=VulnerabilitySeverity.MEDIUM,
                cvss_score=score,
                description="Test",
                scanner="test"
            )
            assert record.cvss_score == score
        
        # Invalid scores should fail validation
        from pydantic import ValidationError
        
        with pytest.raises(ValidationError):
            VulnerabilityRecord(
                package="test",
                version="1.0.0",
                vulnerability_id="TEST-001",
                severity=VulnerabilitySeverity.HIGH,
                cvss_score=11.0,  # Invalid: > 10.0
                description="Test",
                scanner="test"
            )
        
        with pytest.raises(ValidationError):
            VulnerabilityRecord(
                package="test",
                version="1.0.0",
                vulnerability_id="TEST-001",
                severity=VulnerabilitySeverity.HIGH,
                cvss_score=-1.0,  # Invalid: < 0.0
                description="Test",
                scanner="test"
            )


class TestScanResult:
    """Test ScanResult model."""
    
    def test_scan_result_creation(self):
        """Test creating scan result."""
        vulnerabilities = [
            VulnerabilityRecord(
                package="pkg1",
                version="1.0.0",
                vulnerability_id="CVE-001",
                severity=VulnerabilitySeverity.HIGH,
                description="Issue 1",
                scanner="safety"
            ),
            VulnerabilityRecord(
                package="pkg2",
                version="2.0.0",
                vulnerability_id="CVE-002",
                severity=VulnerabilitySeverity.MEDIUM,
                description="Issue 2",
                scanner="pip-audit"
            ),
        ]
        
        result = ScanResult(
            total_packages=10,
            vulnerable_packages=2,
            vulnerabilities=vulnerabilities,
            severity_breakdown={
                VulnerabilitySeverity.CRITICAL: 0,
                VulnerabilitySeverity.HIGH: 1,
                VulnerabilitySeverity.MEDIUM: 1,
                VulnerabilitySeverity.LOW: 0,
                VulnerabilitySeverity.UNKNOWN: 0,
            },
            scan_duration_seconds=5.2,
            scanners_used=["safety", "pip-audit"],
            scan_passed=False
        )
        
        assert result.total_packages == 10
        assert result.vulnerable_packages == 2
        assert len(result.vulnerabilities) == 2
        assert result.severity_breakdown[VulnerabilitySeverity.HIGH] == 1
        assert result.scan_duration_seconds == 5.2
        assert "safety" in result.scanners_used
        assert result.scan_passed is False
    
    def test_scan_result_timestamp(self):
        """Test scan result has timestamp."""
        result = ScanResult(
            total_packages=5,
            vulnerable_packages=0,
            scan_duration_seconds=1.0,
            scan_passed=True
        )
        
        assert isinstance(result.timestamp, datetime)
        assert result.timestamp <= datetime.utcnow()


# ============================================================================
# SCANNER INITIALIZATION TESTS
# ============================================================================


class TestVulnerabilityScannerInit:
    """Test VulnerabilityScanner initialization."""
    
    def test_scanner_default_initialization(self):
        """Test scanner with default values."""
        scanner = VulnerabilityScanner()
        
        assert scanner.requirements_path == Path("requirements.txt")
        assert scanner.ignore_ids == []
        assert scanner.fail_on_severity == VulnerabilitySeverity.HIGH
    
    def test_scanner_custom_initialization(self, mock_requirements_file):
        """Test scanner with custom values."""
        scanner = VulnerabilityScanner(
            requirements_path=mock_requirements_file,
            ignore_ids=["CVE-2023-12345", "CVE-2023-67890"],
            fail_on_severity=VulnerabilitySeverity.CRITICAL
        )
        
        assert scanner.requirements_path == mock_requirements_file
        assert len(scanner.ignore_ids) == 2
        assert "CVE-2023-12345" in scanner.ignore_ids
        assert scanner.fail_on_severity == VulnerabilitySeverity.CRITICAL
    
    def test_scanner_accepts_pathlib(self, tmp_path):
        """Test scanner accepts pathlib.Path."""
        req_path = tmp_path / "reqs.txt"
        req_path.write_text("fastapi==0.104.1")
        
        scanner = VulnerabilityScanner(requirements_path=req_path)
        assert scanner.requirements_path == req_path


# ============================================================================
# SEVERITY CLASSIFICATION TESTS
# ============================================================================


class TestSeverityClassification:
    """Test CVSS score to severity classification."""
    
    def test_classify_severity_critical(self, scanner):
        """Test critical severity classification (9.0-10.0)."""
        assert scanner._classify_severity(10.0) == VulnerabilitySeverity.CRITICAL
        assert scanner._classify_severity(9.8) == VulnerabilitySeverity.CRITICAL
        assert scanner._classify_severity(9.0) == VulnerabilitySeverity.CRITICAL
    
    def test_classify_severity_high(self, scanner):
        """Test high severity classification (7.0-8.9)."""
        assert scanner._classify_severity(8.9) == VulnerabilitySeverity.HIGH
        assert scanner._classify_severity(8.0) == VulnerabilitySeverity.HIGH
        assert scanner._classify_severity(7.0) == VulnerabilitySeverity.HIGH
    
    def test_classify_severity_medium(self, scanner):
        """Test medium severity classification (4.0-6.9)."""
        assert scanner._classify_severity(6.9) == VulnerabilitySeverity.MEDIUM
        assert scanner._classify_severity(5.0) == VulnerabilitySeverity.MEDIUM
        assert scanner._classify_severity(4.0) == VulnerabilitySeverity.MEDIUM
    
    def test_classify_severity_low(self, scanner):
        """Test low severity classification (0.1-3.9)."""
        assert scanner._classify_severity(3.9) == VulnerabilitySeverity.LOW
        assert scanner._classify_severity(2.0) == VulnerabilitySeverity.LOW
        assert scanner._classify_severity(0.1) == VulnerabilitySeverity.LOW
    
    def test_classify_severity_none(self, scanner):
        """Test None CVSS score returns UNKNOWN."""
        assert scanner._classify_severity(None) == VulnerabilitySeverity.UNKNOWN
    
    def test_classify_severity_boundaries(self, scanner):
        """Test exact boundary values."""
        # Boundary tests
        assert scanner._classify_severity(8.99) == VulnerabilitySeverity.HIGH
        assert scanner._classify_severity(9.00) == VulnerabilitySeverity.CRITICAL
        assert scanner._classify_severity(6.99) == VulnerabilitySeverity.MEDIUM
        assert scanner._classify_severity(7.00) == VulnerabilitySeverity.HIGH
        assert scanner._classify_severity(3.99) == VulnerabilitySeverity.LOW
        assert scanner._classify_severity(4.00) == VulnerabilitySeverity.MEDIUM


class TestSeverityFromDescription:
    """Test severity classification from description text."""
    
    def test_classify_from_aliases_critical(self, scanner):
        """Test critical severity detection in description."""
        vuln = {"description": "This is a CRITICAL vulnerability"}
        assert scanner._classify_severity_from_aliases(vuln) == VulnerabilitySeverity.CRITICAL
    
    def test_classify_from_aliases_high(self, scanner):
        """Test high severity detection in description."""
        vuln = {"description": "High severity security issue"}
        assert scanner._classify_severity_from_aliases(vuln) == VulnerabilitySeverity.HIGH
    
    def test_classify_from_aliases_medium(self, scanner):
        """Test medium severity detection in description."""
        vuln_medium = {"description": "Medium risk vulnerability"}
        assert scanner._classify_severity_from_aliases(vuln_medium) == VulnerabilitySeverity.MEDIUM
        
        vuln_moderate = {"description": "Moderate severity issue"}
        assert scanner._classify_severity_from_aliases(vuln_moderate) == VulnerabilitySeverity.MEDIUM
    
    def test_classify_from_aliases_low(self, scanner):
        """Test low severity detection in description."""
        vuln = {"description": "Low priority security bug"}
        assert scanner._classify_severity_from_aliases(vuln) == VulnerabilitySeverity.LOW
    
    def test_classify_from_aliases_unknown(self, scanner):
        """Test unknown severity when no keywords found."""
        vuln = {"description": "Some vulnerability without severity keyword"}
        assert scanner._classify_severity_from_aliases(vuln) == VulnerabilitySeverity.UNKNOWN
    
    def test_classify_from_aliases_case_insensitive(self, scanner):
        """Test severity detection is case-insensitive."""
        vuln_upper = {"description": "CRITICAL VULNERABILITY"}
        assert scanner._classify_severity_from_aliases(vuln_upper) == VulnerabilitySeverity.CRITICAL
        
        vuln_mixed = {"description": "HiGh SeVeRiTy"}
        assert scanner._classify_severity_from_aliases(vuln_mixed) == VulnerabilitySeverity.HIGH


# ============================================================================
# PACKAGE COUNTING TESTS
# ============================================================================


class TestPackageCounting:
    """Test package counting from requirements.txt."""
    
    def test_count_packages_normal(self, scanner):
        """Test counting packages in normal requirements file."""
        count = scanner._count_packages()
        assert count == 5  # fastapi, uvicorn, pydantic, httpx, requests
    
    def test_count_packages_empty_file(self, mock_empty_requirements):
        """Test counting packages in empty file."""
        scanner = VulnerabilityScanner(requirements_path=mock_empty_requirements)
        count = scanner._count_packages()
        assert count == 0
    
    def test_count_packages_nonexistent_file(self):
        """Test counting packages when file doesn't exist."""
        scanner = VulnerabilityScanner(requirements_path=Path("/nonexistent/requirements.txt"))
        count = scanner._count_packages()
        assert count == 0
    
    def test_count_packages_ignores_comments(self, tmp_path):
        """Test package counting ignores comment lines."""
        req_file = tmp_path / "commented_requirements.txt"
        req_file.write_text("""
# This is a comment
fastapi==0.104.1
# Another comment
uvicorn==0.24.0
### Multiple # symbols
pydantic==2.5.0
""".strip())
        
        scanner = VulnerabilityScanner(requirements_path=req_file)
        count = scanner._count_packages()
        assert count == 3
    
    def test_count_packages_ignores_blank_lines(self, tmp_path):
        """Test package counting ignores blank lines."""
        req_file = tmp_path / "blank_requirements.txt"
        req_file.write_text("""
fastapi==0.104.1

uvicorn==0.24.0


pydantic==2.5.0
""")
        
        scanner = VulnerabilityScanner(requirements_path=req_file)
        count = scanner._count_packages()
        assert count == 3


# ============================================================================
# FAIL SEVERITY TESTS
# ============================================================================


class TestFailSeverities:
    """Test fail severity calculation."""
    
    def test_get_fail_severities_high(self):
        """Test fail severities when failing on HIGH."""
        scanner = VulnerabilityScanner(fail_on_severity=VulnerabilitySeverity.HIGH)
        fail_sev = scanner._get_fail_severities()
        
        assert VulnerabilitySeverity.CRITICAL in fail_sev
        assert VulnerabilitySeverity.HIGH in fail_sev
        assert VulnerabilitySeverity.MEDIUM not in fail_sev
        assert VulnerabilitySeverity.LOW not in fail_sev
    
    def test_get_fail_severities_critical(self):
        """Test fail severities when failing on CRITICAL only."""
        scanner = VulnerabilityScanner(fail_on_severity=VulnerabilitySeverity.CRITICAL)
        fail_sev = scanner._get_fail_severities()
        
        assert fail_sev == [VulnerabilitySeverity.CRITICAL]
        assert VulnerabilitySeverity.HIGH not in fail_sev
    
    def test_get_fail_severities_medium(self):
        """Test fail severities when failing on MEDIUM."""
        scanner = VulnerabilityScanner(fail_on_severity=VulnerabilitySeverity.MEDIUM)
        fail_sev = scanner._get_fail_severities()
        
        assert VulnerabilitySeverity.CRITICAL in fail_sev
        assert VulnerabilitySeverity.HIGH in fail_sev
        assert VulnerabilitySeverity.MEDIUM in fail_sev
        assert VulnerabilitySeverity.LOW not in fail_sev
    
    def test_get_fail_severities_low(self):
        """Test fail severities when failing on LOW (all severities)."""
        scanner = VulnerabilityScanner(fail_on_severity=VulnerabilitySeverity.LOW)
        fail_sev = scanner._get_fail_severities()
        
        assert len(fail_sev) == 4
        assert VulnerabilitySeverity.CRITICAL in fail_sev
        assert VulnerabilitySeverity.HIGH in fail_sev
        assert VulnerabilitySeverity.MEDIUM in fail_sev
        assert VulnerabilitySeverity.LOW in fail_sev


# ============================================================================
# SAFETY SCANNER TESTS
# ============================================================================


class TestSafetyScan:
    """Test safety scanner integration."""
    
    @pytest.mark.asyncio
    async def test_scan_with_safety_success(self, scanner):
        """Test successful safety scan."""
        mock_safety_output = json.dumps([
            {
                "package": "requests",
                "installed_version": "2.25.0",
                "vulnerability_id": "CVE-2023-32681",
                "cvss_score": 8.5,
                "advisory": "Proxy-Authorization header leak",
                "vulnerable_spec": ">=2.3.0,<2.31.0"
            }
        ])
        
        with patch("asyncio.create_subprocess_exec") as mock_exec:
            mock_process = AsyncMock()
            mock_process.communicate = AsyncMock(return_value=(mock_safety_output.encode(), b""))
            mock_process.returncode = 64  # Vulnerabilities found
            mock_exec.return_value = mock_process
            
            vulnerabilities = await scanner.scan_with_safety()
            
            assert len(vulnerabilities) == 1
            assert vulnerabilities[0].package == "requests"
            assert vulnerabilities[0].version == "2.25.0"
            assert vulnerabilities[0].vulnerability_id == "CVE-2023-32681"
            assert vulnerabilities[0].severity == VulnerabilitySeverity.HIGH
            assert vulnerabilities[0].scanner == "safety"
    
    @pytest.mark.asyncio
    async def test_scan_with_safety_no_vulnerabilities(self, scanner):
        """Test safety scan with no vulnerabilities found."""
        with patch("asyncio.create_subprocess_exec") as mock_exec:
            mock_process = AsyncMock()
            mock_process.communicate = AsyncMock(return_value=(b"", b""))
            mock_process.returncode = 0  # No vulnerabilities
            mock_exec.return_value = mock_process
            
            vulnerabilities = await scanner.scan_with_safety()
            
            assert vulnerabilities == []
    
    @pytest.mark.asyncio
    async def test_scan_with_safety_not_installed(self, scanner):
        """Test safety scan when safety not installed."""
        with patch("asyncio.create_subprocess_exec", side_effect=FileNotFoundError):
            with pytest.raises(RuntimeError, match="safety not installed"):
                await scanner.scan_with_safety()
    
    @pytest.mark.asyncio
    async def test_scan_with_safety_failure(self, scanner):
        """Test safety scan failure."""
        with patch("asyncio.create_subprocess_exec") as mock_exec:
            mock_process = AsyncMock()
            mock_process.communicate = AsyncMock(return_value=(b"", b"Error occurred"))
            mock_process.returncode = 1  # Unexpected error
            mock_exec.return_value = mock_process
            
            with pytest.raises(RuntimeError, match="Safety scan failed"):
                await scanner.scan_with_safety()
    
    @pytest.mark.asyncio
    async def test_scan_with_safety_multiple_vulnerabilities(self, scanner):
        """Test safety scan with multiple vulnerabilities."""
        mock_safety_output = json.dumps([
            {
                "package": "requests",
                "installed_version": "2.25.0",
                "vulnerability_id": "CVE-2023-32681",
                "cvss_score": 8.5,
                "advisory": "Issue 1",
                "vulnerable_spec": ">=2.3.0,<2.31.0"
            },
            {
                "package": "urllib3",
                "installed_version": "1.26.0",
                "vulnerability_id": "CVE-2023-45803",
                "cvss_score": 4.5,
                "advisory": "Issue 2",
                "vulnerable_spec": ">=1.0.0,<1.26.18"
            }
        ])
        
        with patch("asyncio.create_subprocess_exec") as mock_exec:
            mock_process = AsyncMock()
            mock_process.communicate = AsyncMock(return_value=(mock_safety_output.encode(), b""))
            mock_process.returncode = 64
            mock_exec.return_value = mock_process
            
            vulnerabilities = await scanner.scan_with_safety()
            
            assert len(vulnerabilities) == 2
            assert vulnerabilities[0].severity == VulnerabilitySeverity.HIGH
            assert vulnerabilities[1].severity == VulnerabilitySeverity.MEDIUM


# ============================================================================
# PIP-AUDIT SCANNER TESTS
# ============================================================================


class TestPipAuditScan:
    """Test pip-audit scanner integration."""
    
    @pytest.mark.asyncio
    async def test_scan_with_pip_audit_success(self, scanner):
        """Test successful pip-audit scan."""
        mock_pip_audit_output = json.dumps({
            "dependencies": {
                "requests": {
                    "version": "2.25.0",
                    "vulns": [
                        {
                            "id": "PYSEC-2023-74",
                            "description": "High severity vulnerability in requests",
                            "fix_versions": ["2.31.0"]
                        }
                    ]
                }
            }
        })
        
        with patch("asyncio.create_subprocess_exec") as mock_exec:
            mock_process = AsyncMock()
            mock_process.communicate = AsyncMock(return_value=(mock_pip_audit_output.encode(), b""))
            mock_process.returncode = 1  # Vulnerabilities found
            mock_exec.return_value = mock_process
            
            vulnerabilities = await scanner.scan_with_pip_audit()
            
            assert len(vulnerabilities) == 1
            assert vulnerabilities[0].package == "requests"
            assert vulnerabilities[0].vulnerability_id == "PYSEC-2023-74"
            assert vulnerabilities[0].severity == VulnerabilitySeverity.HIGH
            assert vulnerabilities[0].scanner == "pip-audit"
    
    @pytest.mark.asyncio
    async def test_scan_with_pip_audit_no_vulnerabilities(self, scanner):
        """Test pip-audit scan with no vulnerabilities."""
        with patch("asyncio.create_subprocess_exec") as mock_exec:
            mock_process = AsyncMock()
            mock_process.communicate = AsyncMock(return_value=(b"", b""))
            mock_process.returncode = 0
            mock_exec.return_value = mock_process
            
            vulnerabilities = await scanner.scan_with_pip_audit()
            
            assert vulnerabilities == []
    
    @pytest.mark.asyncio
    async def test_scan_with_pip_audit_not_installed(self, scanner):
        """Test pip-audit scan when pip-audit not installed."""
        with patch("asyncio.create_subprocess_exec", side_effect=FileNotFoundError):
            with pytest.raises(RuntimeError, match="pip-audit not installed"):
                await scanner.scan_with_pip_audit()
    
    @pytest.mark.asyncio
    async def test_scan_with_pip_audit_failure(self, scanner):
        """Test pip-audit scan failure."""
        with patch("asyncio.create_subprocess_exec") as mock_exec:
            mock_process = AsyncMock()
            mock_process.communicate = AsyncMock(return_value=(b"", b"Critical error"))
            mock_process.returncode = 2  # Unexpected error
            mock_exec.return_value = mock_process
            
            with pytest.raises(RuntimeError, match="pip-audit scan failed"):
                await scanner.scan_with_pip_audit()

    @pytest.mark.asyncio
    async def test_scan_with_pip_audit_legacy_list_format(self, scanner):
        """Test pip-audit scan with legacy list format (lines 206-213)."""
        mock_pip_audit_output = json.dumps({
            "dependencies": [
                {
                    "name": "urllib3",
                    "version": "1.26.0",
                    "vulns": [
                        {
                            "id": "PYSEC-2023-45",
                            "description": "Medium severity issue",
                            "fix_versions": ["1.26.18"]
                        }
                    ]
                }
            ]
        })
        
        with patch("asyncio.create_subprocess_exec") as mock_exec:
            mock_process = AsyncMock()
            mock_process.communicate = AsyncMock(return_value=(mock_pip_audit_output.encode(), b""))
            mock_process.returncode = 1
            mock_exec.return_value = mock_process
            
            vulnerabilities = await scanner.scan_with_pip_audit()
            
            assert len(vulnerabilities) == 1
            assert vulnerabilities[0].package == "urllib3"
            assert vulnerabilities[0].version == "1.26.0"
            assert vulnerabilities[0].scanner == "pip-audit"

    @pytest.mark.asyncio
    async def test_scan_with_pip_audit_empty_list_response(self, scanner):
        """Test pip-audit scan with empty list response (line 169)."""
        mock_pip_audit_output = json.dumps([])  # Empty array format
        
        with patch("asyncio.create_subprocess_exec") as mock_exec:
            mock_process = AsyncMock()
            mock_process.communicate = AsyncMock(return_value=(mock_pip_audit_output.encode(), b""))
            mock_process.returncode = 0
            mock_exec.return_value = mock_process
            
            vulnerabilities = await scanner.scan_with_pip_audit()
            
            assert vulnerabilities == []


# ============================================================================
# FULL SCAN TESTS
# ============================================================================


class TestFullScan:
    """Test complete vulnerability scan with multiple scanners."""
    
    @pytest.mark.asyncio
    async def test_run_full_scan_success(self, scanner):
        """Test successful full scan with both scanners."""
        # Mock both scanners
        mock_safety_vulns = [
            VulnerabilityRecord(
                package="requests",
                version="2.25.0",
                vulnerability_id="CVE-2023-32681",
                severity=VulnerabilitySeverity.HIGH,
                description="Safety finding",
                scanner="safety"
            )
        ]
        
        mock_pip_audit_vulns = [
            VulnerabilityRecord(
                package="urllib3",
                version="1.26.0",
                vulnerability_id="PYSEC-2023-100",
                severity=VulnerabilitySeverity.MEDIUM,
                description="Pip-audit finding",
                scanner="pip-audit"
            )
        ]
        
        with patch.object(scanner, 'scan_with_safety', return_value=mock_safety_vulns):
            with patch.object(scanner, 'scan_with_pip_audit', return_value=mock_pip_audit_vulns):
                result = await scanner.run_full_scan()
                
                assert result.total_packages == 5
                assert result.vulnerable_packages == 2
                assert len(result.vulnerabilities) == 2
                assert result.severity_breakdown[VulnerabilitySeverity.HIGH] == 1
                assert result.severity_breakdown[VulnerabilitySeverity.MEDIUM] == 1
                assert result.scan_passed is False
                assert "safety" in result.scanners_used
                assert "pip-audit" in result.scanners_used
    
    @pytest.mark.asyncio
    async def test_run_full_scan_deduplication(self, scanner):
        """Test full scan deduplicates same vulnerability from multiple scanners."""
        # Same vulnerability reported by both scanners
        duplicate_vuln = VulnerabilityRecord(
            package="requests",
            version="2.25.0",
            vulnerability_id="CVE-2023-32681",
            severity=VulnerabilitySeverity.HIGH,
            description="Same issue",
            scanner="safety"
        )
        
        mock_safety_vulns = [duplicate_vuln]
        mock_pip_audit_vulns = [duplicate_vuln]
        
        with patch.object(scanner, 'scan_with_safety', return_value=mock_safety_vulns):
            with patch.object(scanner, 'scan_with_pip_audit', return_value=mock_pip_audit_vulns):
                result = await scanner.run_full_scan()
                
                # Should only include one instance
                assert len(result.vulnerabilities) == 1
                assert result.vulnerable_packages == 1
    
    @pytest.mark.asyncio
    async def test_run_full_scan_respects_ignore_list(self, mock_requirements_file):
        """Test full scan ignores CVEs in ignore list."""
        scanner = VulnerabilityScanner(
            requirements_path=mock_requirements_file,
            ignore_ids=["CVE-2023-32681"],
            fail_on_severity=VulnerabilitySeverity.HIGH
        )
        
        mock_safety_vulns = [
            VulnerabilityRecord(
                package="requests",
                version="2.25.0",
                vulnerability_id="CVE-2023-32681",  # Should be ignored
                severity=VulnerabilitySeverity.HIGH,
                description="Ignored vulnerability",
                scanner="safety"
            ),
            VulnerabilityRecord(
                package="urllib3",
                version="1.26.0",
                vulnerability_id="CVE-2023-99999",  # Should be included
                severity=VulnerabilitySeverity.MEDIUM,
                description="Not ignored",
                scanner="safety"
            )
        ]
        
        with patch.object(scanner, 'scan_with_safety', return_value=mock_safety_vulns):
            with patch.object(scanner, 'scan_with_pip_audit', return_value=[]):
                result = await scanner.run_full_scan()
                
                # Only non-ignored vulnerability should be in results
                assert len(result.vulnerabilities) == 1
                assert result.vulnerabilities[0].vulnerability_id == "CVE-2023-99999"
    
    @pytest.mark.asyncio
    async def test_run_full_scan_no_scanners_available(self, scanner):
        """Test full scan when no scanners are available."""
        # The scanners fail during gather, not during task creation
        # So we need to make scan methods raise exceptions that will be caught by gather
        async def failing_safety():
            raise RuntimeError("safety not installed")
        
        async def failing_pip_audit():
            raise RuntimeError("pip-audit not installed")
        
        with patch.object(scanner, 'scan_with_safety', side_effect=failing_safety):
            with patch.object(scanner, 'scan_with_pip_audit', side_effect=failing_pip_audit):
                # Scanners will add tasks, but both will fail during gather
                # Result: all_vulnerabilities will be empty, scan continues
                result = await scanner.run_full_scan()
                
                # Should complete with empty results (errors caught by gather)
                assert len(result.vulnerabilities) == 0
                assert result.scan_passed is True
    
    @pytest.mark.asyncio
    async def test_run_full_scan_one_scanner_fails(self, scanner):
        """Test full scan continues if one scanner fails."""
        mock_pip_audit_vulns = [
            VulnerabilityRecord(
                package="urllib3",
                version="1.26.0",
                vulnerability_id="PYSEC-2023-100",
                severity=VulnerabilitySeverity.MEDIUM,
                description="Pip-audit finding",
                scanner="pip-audit"
            )
        ]
        
        with patch.object(scanner, 'scan_with_safety', side_effect=RuntimeError("Safety failed")):
            with patch.object(scanner, 'scan_with_pip_audit', return_value=mock_pip_audit_vulns):
                result = await scanner.run_full_scan()
                
                # Should still have results from pip-audit
                assert len(result.vulnerabilities) == 1
                assert result.vulnerabilities[0].scanner == "pip-audit"
    
    @pytest.mark.asyncio
    async def test_run_full_scan_passed_no_vulnerabilities(self, scanner):
        """Test full scan passes when no vulnerabilities found."""
        with patch.object(scanner, 'scan_with_safety', return_value=[]):
            with patch.object(scanner, 'scan_with_pip_audit', return_value=[]):
                result = await scanner.run_full_scan()
                
                assert result.scan_passed is True
                assert result.vulnerable_packages == 0
                assert len(result.vulnerabilities) == 0
    
    @pytest.mark.asyncio
    async def test_run_full_scan_passed_only_low_severity(self, scanner):
        """Test full scan passes when only low severity found (failing on HIGH)."""
        mock_low_vulns = [
            VulnerabilityRecord(
                package="somelib",
                version="1.0.0",
                vulnerability_id="CVE-2023-LOW",
                severity=VulnerabilitySeverity.LOW,
                description="Low severity issue",
                scanner="safety"
            )
        ]
        
        with patch.object(scanner, 'scan_with_safety', return_value=mock_low_vulns):
            with patch.object(scanner, 'scan_with_pip_audit', return_value=[]):
                result = await scanner.run_full_scan()
                
                # Should pass because scanner fails on HIGH, but only LOW found
                assert result.scan_passed is True
                assert len(result.vulnerabilities) == 1
    
    @pytest.mark.asyncio
    async def test_run_full_scan_timing(self, scanner):
        """Test full scan records duration."""
        with patch.object(scanner, 'scan_with_safety', return_value=[]):
            with patch.object(scanner, 'scan_with_pip_audit', return_value=[]):
                result = await scanner.run_full_scan()
                
                assert result.scan_duration_seconds >= 0
                assert isinstance(result.scan_duration_seconds, float)
    
    @pytest.mark.asyncio
    async def test_run_full_scan_safety_init_error(self, scanner):
        """Test full scan when safety raises error during initialization."""
        # Mock scan_with_safety to raise RuntimeError immediately (not async)
        # This covers lines 190-191
        original_scan_with_safety = scanner.scan_with_safety
        
        def raise_runtime_error():
            raise RuntimeError("safety initialization failed")
        
        scanner.scan_with_safety = raise_runtime_error
        
        mock_pip_audit_vulns = [
            VulnerabilityRecord(
                package="test",
                version="1.0.0",
                vulnerability_id="TEST-001",
                severity=VulnerabilitySeverity.LOW,
                description="Test",
                scanner="pip-audit"
            )
        ]
        
        with patch.object(scanner, 'scan_with_pip_audit', return_value=mock_pip_audit_vulns):
            result = await scanner.run_full_scan()
            
            # Should continue with pip-audit only
            assert len(result.vulnerabilities) == 1
            assert "pip-audit" in result.scanners_used
            assert "safety" not in result.scanners_used
    
    @pytest.mark.asyncio
    async def test_run_full_scan_pip_audit_init_error(self, scanner):
        """Test full scan when pip-audit raises error during initialization."""
        # This covers lines 196-197
        mock_safety_vulns = [
            VulnerabilityRecord(
                package="test",
                version="1.0.0",
                vulnerability_id="TEST-002",
                severity=VulnerabilitySeverity.MEDIUM,
                description="Test",
                scanner="safety"
            )
        ]
        
        def raise_runtime_error():
            raise RuntimeError("pip-audit initialization failed")
        
        scanner.scan_with_pip_audit = raise_runtime_error
        
        with patch.object(scanner, 'scan_with_safety', return_value=mock_safety_vulns):
            result = await scanner.run_full_scan()
            
            # Should continue with safety only
            assert len(result.vulnerabilities) == 1
            assert "safety" in result.scanners_used
            assert "pip-audit" not in result.scanners_used
    
    @pytest.mark.asyncio
    async def test_run_full_scan_both_scanners_init_error(self, scanner):
        """Test full scan when both scanners fail during initialization."""
        # This covers line 200
        def raise_safety_error():
            raise RuntimeError("safety not available")
        
        def raise_pip_audit_error():
            raise RuntimeError("pip-audit not available")
        
        scanner.scan_with_safety = raise_safety_error
        scanner.scan_with_pip_audit = raise_pip_audit_error
        
        # Both fail immediately, no tasks created
        with pytest.raises(RuntimeError, match="No vulnerability scanners available"):
            await scanner.run_full_scan()


# ============================================================================
# CONVENIENCE FUNCTION TESTS
# ============================================================================


class TestScanDependencies:
    """Test scan_dependencies convenience function."""
    
    @pytest.mark.asyncio
    async def test_scan_dependencies_default_params(self, mock_requirements_file):
        """Test scan_dependencies with default parameters."""
        with patch("backend.shared.security_tools.vulnerability_scanner.VulnerabilityScanner") as MockScanner:
            mock_scanner_instance = MagicMock()
            mock_result = ScanResult(
                total_packages=5,
                vulnerable_packages=0,
                scan_duration_seconds=1.0,
                scan_passed=True
            )
            mock_scanner_instance.run_full_scan = AsyncMock(return_value=mock_result)
            MockScanner.return_value = mock_scanner_instance
            
            result = await scan_dependencies()
            
            # Verify scanner was created with expected defaults
            MockScanner.assert_called_once()
            assert result == mock_result
    
    @pytest.mark.asyncio
    async def test_scan_dependencies_custom_path(self, mock_requirements_file):
        """Test scan_dependencies with custom requirements path."""
        with patch("backend.shared.security_tools.vulnerability_scanner.VulnerabilityScanner") as MockScanner:
            mock_scanner_instance = MagicMock()
            mock_result = ScanResult(
                total_packages=5,
                vulnerable_packages=0,
                scan_duration_seconds=1.0,
                scan_passed=True
            )
            mock_scanner_instance.run_full_scan = AsyncMock(return_value=mock_result)
            MockScanner.return_value = mock_scanner_instance
            
            result = await scan_dependencies(requirements_path=mock_requirements_file)
            
            # Verify custom path was used
            call_args = MockScanner.call_args
            assert call_args[1]['requirements_path'] == mock_requirements_file
    
    @pytest.mark.asyncio
    async def test_scan_dependencies_fail_on_high_true(self):
        """Test scan_dependencies with fail_on_high=True."""
        with patch("backend.shared.security_tools.vulnerability_scanner.VulnerabilityScanner") as MockScanner:
            mock_scanner_instance = MagicMock()
            mock_result = ScanResult(
                total_packages=5,
                vulnerable_packages=0,
                scan_duration_seconds=1.0,
                scan_passed=True
            )
            mock_scanner_instance.run_full_scan = AsyncMock(return_value=mock_result)
            MockScanner.return_value = mock_scanner_instance
            
            await scan_dependencies(fail_on_high=True)
            
            call_args = MockScanner.call_args
            assert call_args[1]['fail_on_severity'] == VulnerabilitySeverity.HIGH
    
    @pytest.mark.asyncio
    async def test_scan_dependencies_fail_on_high_false(self):
        """Test scan_dependencies with fail_on_high=False (critical only)."""
        with patch("backend.shared.security_tools.vulnerability_scanner.VulnerabilityScanner") as MockScanner:
            mock_scanner_instance = MagicMock()
            mock_result = ScanResult(
                total_packages=5,
                vulnerable_packages=0,
                scan_duration_seconds=1.0,
                scan_passed=True
            )
            mock_scanner_instance.run_full_scan = AsyncMock(return_value=mock_result)
            MockScanner.return_value = mock_scanner_instance
            
            await scan_dependencies(fail_on_high=False)
            
            call_args = MockScanner.call_args
            assert call_args[1]['fail_on_severity'] == VulnerabilitySeverity.CRITICAL


# ============================================================================
# INTEGRATION TESTS
# ============================================================================


class TestVulnerabilityScannerIntegration:
    """Integration tests for complete vulnerability scanning workflow."""
    
    @pytest.mark.asyncio
    async def test_complete_scan_workflow(self, mock_requirements_file):
        """Test complete scan workflow from start to finish."""
        # Create scanner
        scanner = VulnerabilityScanner(
            requirements_path=mock_requirements_file,
            ignore_ids=["CVE-IGNORE-001"],
            fail_on_severity=VulnerabilitySeverity.HIGH
        )
        
        # Mock scanner outputs
        mock_safety_vulns = [
            VulnerabilityRecord(
                package="requests",
                version="2.25.0",
                vulnerability_id="CVE-2023-32681",
                severity=VulnerabilitySeverity.HIGH,
                cvss_score=8.5,
                description="Proxy-Authorization header leak",
                fix_available=True,
                fixed_in="2.31.0",
                scanner="safety"
            )
        ]
        
        mock_pip_audit_vulns = [
            VulnerabilityRecord(
                package="urllib3",
                version="1.26.0",
                vulnerability_id="PYSEC-2023-100",
                severity=VulnerabilitySeverity.MEDIUM,
                description="Connection pool issue",
                fix_available=True,
                fixed_in="1.26.18",
                scanner="pip-audit"
            ),
            VulnerabilityRecord(
                package="some-other-pkg",
                version="1.0.0",
                vulnerability_id="CVE-IGNORE-001",  # Should be ignored
                severity=VulnerabilitySeverity.CRITICAL,
                description="Ignored vulnerability",
                fix_available=False,
                scanner="pip-audit"
            )
        ]
        
        with patch.object(scanner, 'scan_with_safety', return_value=mock_safety_vulns):
            with patch.object(scanner, 'scan_with_pip_audit', return_value=mock_pip_audit_vulns):
                result = await scanner.run_full_scan()
                
                # Verify result structure
                assert isinstance(result, ScanResult)
                assert isinstance(result.timestamp, datetime)
                assert result.total_packages == 5
                
                # Verify vulnerability count (ignored CVE should not be counted)
                assert len(result.vulnerabilities) == 2
                assert result.vulnerable_packages == 2
                
                # Verify vulnerabilities content
                vuln_ids = [v.vulnerability_id for v in result.vulnerabilities]
                assert "CVE-2023-32681" in vuln_ids
                assert "PYSEC-2023-100" in vuln_ids
                assert "CVE-IGNORE-001" not in vuln_ids  # Ignored
                
                # Verify severity breakdown
                assert result.severity_breakdown[VulnerabilitySeverity.CRITICAL] == 0
                assert result.severity_breakdown[VulnerabilitySeverity.HIGH] == 1
                assert result.severity_breakdown[VulnerabilitySeverity.MEDIUM] == 1
                assert result.severity_breakdown[VulnerabilitySeverity.LOW] == 0
                
                # Verify scan failed (HIGH vulnerability found, failing on HIGH)
                assert result.scan_passed is False
                
                # Verify scanners used
                assert len(result.scanners_used) == 2
                assert "safety" in result.scanners_used
                assert "pip-audit" in result.scanners_used
                
                # Verify timing
                assert result.scan_duration_seconds >= 0
    
    @pytest.mark.asyncio
    async def test_severity_breakdown_all_levels(self, mock_requirements_file):
        """Test severity breakdown with vulnerabilities at all levels."""
        scanner = VulnerabilityScanner(requirements_path=mock_requirements_file)
        
        mock_vulns = [
            VulnerabilityRecord(
                package="pkg1",
                version="1.0.0",
                vulnerability_id="CVE-CRITICAL",
                severity=VulnerabilitySeverity.CRITICAL,
                description="Critical",
                scanner="safety"
            ),
            VulnerabilityRecord(
                package="pkg2",
                version="1.0.0",
                vulnerability_id="CVE-HIGH",
                severity=VulnerabilitySeverity.HIGH,
                description="High",
                scanner="safety"
            ),
            VulnerabilityRecord(
                package="pkg3",
                version="1.0.0",
                vulnerability_id="CVE-MEDIUM",
                severity=VulnerabilitySeverity.MEDIUM,
                description="Medium",
                scanner="safety"
            ),
            VulnerabilityRecord(
                package="pkg4",
                version="1.0.0",
                vulnerability_id="CVE-LOW",
                severity=VulnerabilitySeverity.LOW,
                description="Low",
                scanner="safety"
            ),
            VulnerabilityRecord(
                package="pkg5",
                version="1.0.0",
                vulnerability_id="CVE-UNKNOWN",
                severity=VulnerabilitySeverity.UNKNOWN,
                description="Unknown",
                scanner="safety"
            ),
        ]
        
        with patch.object(scanner, 'scan_with_safety', return_value=mock_vulns):
            with patch.object(scanner, 'scan_with_pip_audit', return_value=[]):
                result = await scanner.run_full_scan()
                
                assert result.severity_breakdown[VulnerabilitySeverity.CRITICAL] == 1
                assert result.severity_breakdown[VulnerabilitySeverity.HIGH] == 1
                assert result.severity_breakdown[VulnerabilitySeverity.MEDIUM] == 1
                assert result.severity_breakdown[VulnerabilitySeverity.LOW] == 1
                assert result.severity_breakdown[VulnerabilitySeverity.UNKNOWN] == 1


class TestVulnerabilityScanner100PercentCoverage:
    """Tests to reach 100% coverage - missing edge cases."""

    @pytest.mark.asyncio
    async def test_safety_legacy_array_format(self):
        """Test lines 123-126: legacy Safety array format parsing."""
        from backend.shared.security_tools.vulnerability_scanner import VulnerabilityScanner
        
        scanner = VulnerabilityScanner()
        
        # Mock safety output with legacy array format: [pkg, spec, installed, vuln_id, advisory]
        safety_json = [
            ["django", "<2.2.8", "2.2.7", "CVE-2019-12345", "Security advisory text"],
            ["requests", "<2.25.0", "2.24.0", "CVE-2020-67890", "Another advisory"]
        ]
        
        # Mock asyncio subprocess
        mock_process = Mock()
        mock_process.communicate = AsyncMock(return_value=(
            json.dumps(safety_json).encode(),
            b""
        ))
        mock_process.returncode = 64  # Safety returns 64 when vulns found
        
        with patch("backend.shared.security_tools.vulnerability_scanner.asyncio.create_subprocess_exec", return_value=mock_process):
            result = await scanner.scan_with_safety()
        
        assert len(result) == 2
        assert result[0].package == "django"
        assert result[0].version == "2.2.7"
        assert result[0].vulnerability_id == "CVE-2019-12345"
        assert result[1].package == "requests"

    @pytest.mark.asyncio
    async def test_pip_audit_tool_error_empty_stdout(self):
        """Test line 169: pip-audit returncode 1 with empty stdout (tool error)."""
        from backend.shared.security_tools.vulnerability_scanner import VulnerabilityScanner
        
        scanner = VulnerabilityScanner()
        
        # Mock asyncio subprocess to return code 1 with empty stdout (tool error)
        mock_process = Mock()
        mock_process.communicate = AsyncMock(return_value=(
            b"",  # Empty stdout
            b"Error: pip-audit is not properly configured"
        ))
        mock_process.returncode = 1
        
        with patch("backend.shared.security_tools.vulnerability_scanner.asyncio.create_subprocess_exec", return_value=mock_process):
            with pytest.raises(RuntimeError, match="pip-audit scan failed"):
                await scanner.scan_with_pip_audit()

    @pytest.mark.asyncio
    async def test_pip_audit_legacy_list_format(self):
        """Test lines 206->225: legacy list format for dependencies."""
        from backend.shared.security_tools.vulnerability_scanner import VulnerabilityScanner
        
        scanner = VulnerabilityScanner()
        
        # Mock pip-audit output with legacy list format
        legacy_json = {
            "dependencies": [
                {
                    "name": "flask",
                    "version": "1.0.0",
                    "vulns": [
                        {
                            "id": "CVE-2021-12345",
                            "aliases": ["GHSA-xxxx-yyyy"],
                            "description": "Flask vulnerability",
                            "fix_versions": ["1.1.0", "2.0.0"]
                        }
                    ]
                },
                {
                    "name": "jinja2",
                    "version": "2.8.0",
                    "vulns": [
                        {
                            "id": "CVE-2020-98765",
                            "aliases": [],
                            "description": "Jinja2 XSS",
                            "fix_versions": ["2.11.3"]
                        }
                    ]
                }
            ]
        }
        
        mock_process = Mock()
        mock_process.communicate = AsyncMock(return_value=(
            json.dumps(legacy_json).encode(),
            b""
        ))
        mock_process.returncode = 1  # Vulns found
        
        with patch("backend.shared.security_tools.vulnerability_scanner.asyncio.create_subprocess_exec", return_value=mock_process):
            result = await scanner.scan_with_pip_audit()
            
            assert len(result) == 2
            assert result[0].package == "flask"
            assert result[0].version == "1.0.0"
            assert result[0].vulnerability_id == "CVE-2021-12345"
            assert result[0].fixed_in == "1.1.0, 2.0.0"
            assert result[1].package == "jinja2"
            assert result[1].vulnerability_id == "CVE-2020-98765"

    async def test_safety_mixed_format_skip_invalid(self):
        """Test line 123->106: Safety data with invalid entries (skip and continue loop)."""
        scanner = VulnerabilityScanner()
        
        # Mix of valid dict, valid list, and INVALID data (string, short list)
        mixed_json = [
            # Valid dict
            {
                "package": "flask",
                "installed_version": "1.0.0",
                "vulnerability_id": "CVE-2021-12345",
                "cvss_score": 7.5,
                "advisory": "Flask vulnerability",
                "vulnerable_spec": ">=1.0.0,<1.1.0"
            },
            # Invalid: string (not dict, not list) - should skip
            "invalid_string_data",
            # Valid legacy list (len >= 5)
            ["requests", ">=2.0.0,<2.20.0", "2.18.0", "CVE-2018-11111", "Requests vulnerability"],
            # Invalid: short list (len < 5) - should skip
            ["short", "list"],
            # Invalid: None - should skip
            None,
            # Valid dict
            {
                "package": "jinja2",
                "installed_version": "2.8.0",
                "vulnerability_id": "CVE-2020-98765"
            }
        ]
        
        mock_process = Mock()
        mock_process.communicate = AsyncMock(return_value=(
            json.dumps(mixed_json).encode(),
            b""
        ))
        mock_process.returncode = 64  # Vulns found (valid returncode)
        
        with patch("backend.shared.security_tools.vulnerability_scanner.asyncio.create_subprocess_exec", return_value=mock_process):
            result = await scanner.scan_with_safety()
            
            # Should only process 3 valid entries (2 dicts + 1 list), skip 3 invalid
            assert len(result) == 3
            assert result[0].package == "flask"
            assert result[1].package == "requests"
            assert result[2].package == "jinja2"

    async def test_pip_audit_mixed_dependencies_format(self):
        """Test line 206: pip-audit with dependencies as dict (not list)."""
        scanner = VulnerabilityScanner()
        
        # Dependencies as empty dict (not standard format)
        dict_format = {
            "dependencies": {}  # Empty dict instead of list
        }
        
        mock_process = Mock()
        mock_process.communicate = AsyncMock(return_value=(
            json.dumps(dict_format).encode(),
            b""
        ))
        mock_process.returncode = 0
        
        with patch("backend.shared.security_tools.vulnerability_scanner.asyncio.create_subprocess_exec", return_value=mock_process):
            result = await scanner.scan_with_pip_audit()
            
            # Should handle gracefully and return empty list
            assert len(result) == 0
