package strategies

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/verticedev/vcli-go/internal/agents"
	"github.com/verticedev/vcli-go/internal/agents/language"
	"github.com/verticedev/vcli-go/internal/agents/oraculo"
)

// GoCodeGenStrategy implements code generation for Go
type GoCodeGenStrategy struct {
	oraculoClient *oraculo.Client
	useOraculo    bool
}

// NewGoCodeGenStrategy creates a new Go code generation strategy
func NewGoCodeGenStrategy(oraculoEndpoint, authToken string) *GoCodeGenStrategy {
	strategy := &GoCodeGenStrategy{
		useOraculo: false,
	}

	// Only enable Oraculo if endpoint is provided
	if oraculoEndpoint != "" {
		strategy.oraculoClient = oraculo.NewClient(oraculoEndpoint, authToken)
		strategy.useOraculo = true
	}

	return strategy
}

// Language returns the language this strategy supports
func (s *GoCodeGenStrategy) Language() language.Language {
	return language.LanguageGo
}

// GetCapabilities returns code generation capabilities
func (s *GoCodeGenStrategy) GetCapabilities() []string {
	return []string{
		"Template-based code generation",
		"Go formatting (gofmt/goimports)",
		"Import management",
		"Error handling patterns",
		"Interface implementation",
	}
}

// GenerateCode generates Go code based on task description and context
func (s *GoCodeGenStrategy) GenerateCode(ctx context.Context, task string, contextData map[string]interface{}) ([]agents.CodeChange, error) {
	var code string
	var err error

	// Use Oraculo if available and enabled
	if s.useOraculo && s.oraculoClient != nil {
		code, err = s.generateWithOraculo(ctx, task, contextData)
		if err != nil {
			// Fall back to template on error
			fmt.Fprintf(os.Stderr, "⚠️  Oraculo code generation failed, falling back to templates: %v\n", err)
			code = s.generateTemplateCode(task, s.detectFramework(contextData))
		}
	} else {
		// Use template-based generation
		code = s.generateTemplateCode(task, s.detectFramework(contextData))
	}

	// Format the generated code
	formattedCode, err := s.FormatCode(code)
	if err != nil {
		// If formatting fails, use unformatted code
		formattedCode = code
	}

	// Create a single code change for demonstration
	change := agents.CodeChange{
		FilePath:  s.getOutputFilePath(task, contextData),
		After:     formattedCode,
		Operation: "create",
		Language:  "go",
		Lines:     len(strings.Split(formattedCode, "\n")),
	}

	return []agents.CodeChange{change}, nil
}

// generateWithOraculo generates code using MAXIMUS Oraculo API
func (s *GoCodeGenStrategy) generateWithOraculo(ctx context.Context, task string, contextData map[string]interface{}) (string, error) {
	// Build enriched context with Go-specific information
	enrichedContext := make(map[string]interface{})
	for k, v := range contextData {
		enrichedContext[k] = v
	}

	// Add framework detection
	enrichedContext["framework"] = s.detectFramework(contextData)

	// Add language-specific requirements
	enrichedContext["requirements"] = map[string]interface{}{
		"style":          "idiomatic_go",
		"error_handling": "explicit",
		"comments":       "comprehensive",
		"testing":        "testable_code",
	}

	// Call Oraculo API
	req := oraculo.ImplementationRequest{
		TaskDescription: task,
		Context:         enrichedContext,
		TargetLanguage:  "go",
	}

	resp, err := s.oraculoClient.AutoImplement(ctx, req)
	if err != nil {
		return "", fmt.Errorf("oraculo API call failed: %w", err)
	}

	if resp.Result.Details.Status != "success" {
		return "", fmt.Errorf("oraculo implementation failed: %s", resp.Result.Details.Message)
	}

	return resp.Result.GeneratedCode, nil
}

// generateTemplateCode generates template Go code
func (s *GoCodeGenStrategy) generateTemplateCode(task string, framework string) string {
	// Basic Go template
	template := fmt.Sprintf(`package main

// %s
// Auto-generated by Agent Smith DEV SENIOR
// Framework: %s

import "fmt"

func main() {
	// TODO: Implement %s
	fmt.Println("TODO: %s")
}
`, task, framework, task, task)

	return template
}

// getOutputFilePath determines output file path
func (s *GoCodeGenStrategy) getOutputFilePath(task string, contextData map[string]interface{}) string {
	// Simple file naming based on task
	filename := strings.ReplaceAll(strings.ToLower(task), " ", "_")
	filename = strings.ReplaceAll(filename, "-", "_")
	if !strings.HasSuffix(filename, ".go") {
		filename += ".go"
	}
	return filename
}

// FormatCode formats Go code using gofmt and goimports
func (s *GoCodeGenStrategy) FormatCode(code string) (string, error) {
	// First run gofmt
	cmd := exec.Command("gofmt")
	cmd.Stdin = strings.NewReader(code)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return code, fmt.Errorf("gofmt failed: %w", err)
	}

	formattedCode := string(output)

	// Then run goimports to fix imports
	cmd = exec.Command("goimports")
	cmd.Stdin = strings.NewReader(formattedCode)
	output, err = cmd.CombinedOutput()
	if err == nil && len(output) > 0 {
		formattedCode = string(output)
	}

	return formattedCode, nil
}

// ValidateSyntax validates Go syntax by attempting to parse
func (s *GoCodeGenStrategy) ValidateSyntax(code string) error {
	// Use go/parser to validate syntax
	// For now, just try to format - if it formats, syntax is valid
	_, err := s.FormatCode(code)
	return err
}

// buildPrompt builds a detailed prompt for Oraculo
func (s *GoCodeGenStrategy) buildPrompt(task string, contextData map[string]interface{}) string {
	prompt := fmt.Sprintf("Generate Go code for: %s\n\n", task)

	// Add context if available
	if architecture, ok := contextData["architecture_plan"]; ok {
		prompt += fmt.Sprintf("Architecture: %v\n\n", architecture)
	}

	if existingCode, ok := contextData["existing_code"]; ok {
		prompt += fmt.Sprintf("Existing code to modify:\n%v\n\n", existingCode)
	}

	if dependencies, ok := contextData["dependencies"]; ok {
		prompt += fmt.Sprintf("Available dependencies: %v\n\n", dependencies)
	}

	// Add Go best practices
	prompt += `
Requirements:
- Follow idiomatic Go style
- Handle all errors explicitly
- Use interfaces for abstractions
- Keep functions small and focused
- Add comprehensive comments
- Write testable code
- Use defer for cleanup
`

	return prompt
}

// detectFramework detects Go framework from context
func (s *GoCodeGenStrategy) detectFramework(contextData map[string]interface{}) string {
	if framework, ok := contextData["framework"].(string); ok {
		return framework
	}

	// Try to detect from dependencies
	if deps, ok := contextData["dependencies"].([]string); ok {
		for _, dep := range deps {
			if strings.Contains(dep, "gin") {
				return "gin"
			}
			if strings.Contains(dep, "echo") {
				return "echo"
			}
			if strings.Contains(dep, "fiber") {
				return "fiber"
			}
			if strings.Contains(dep, "cobra") {
				return "cobra"
			}
		}
	}

	return "standard"
}

// determineOperation determines if this is create, modify, or delete
func (s *GoCodeGenStrategy) determineOperation(filePath string, contextData map[string]interface{}) string {
	if existingFiles, ok := contextData["existing_files"].([]string); ok {
		for _, existing := range existingFiles {
			if existing == filePath {
				return "modify"
			}
		}
	}
	return "create"
}
