package strategies

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/verticedev/vcli-go/internal/agents"
	"github.com/verticedev/vcli-go/internal/agents/language"
	"github.com/verticedev/vcli-go/internal/agents/oraculo"
	"github.com/verticedev/vcli-go/internal/tools"
)

// PythonCodeGenStrategy implements code generation for Python
type PythonCodeGenStrategy struct {
	oraculoClient *oraculo.Client
	useOraculo    bool
}

// NewPythonCodeGenStrategy creates a new Python code generation strategy
func NewPythonCodeGenStrategy(oraculoEndpoint, authToken string) *PythonCodeGenStrategy {
	strategy := &PythonCodeGenStrategy{
		useOraculo: false,
	}

	// Only enable Oraculo if endpoint is provided
	if oraculoEndpoint != "" {
		strategy.oraculoClient = oraculo.NewClient(oraculoEndpoint, authToken)
		strategy.useOraculo = true
	}

	return strategy
}

// Language returns the language this strategy supports
func (s *PythonCodeGenStrategy) Language() language.Language {
	return language.LanguagePython
}

// GetCapabilities returns code generation capabilities
func (s *PythonCodeGenStrategy) GetCapabilities() []string {
	return []string{
		"AI-powered code generation via MAXIMUS Oraculo",
		"Python syntax formatting (black/autopep8)",
		"Import management",
		"Docstring generation",
		"Type hints support",
	}
}

// GenerateCode generates Python code based on task description and context
func (s *PythonCodeGenStrategy) GenerateCode(ctx context.Context, task string, contextData map[string]interface{}) ([]agents.CodeChange, error) {
	var code string
	var err error

	// Use Oraculo if available and enabled
	if s.useOraculo && s.oraculoClient != nil {
		code, err = s.generateWithOraculo(ctx, task, contextData)
		if err != nil {
			// Fall back to template on error
			fmt.Fprintf(os.Stderr, "⚠️  Oraculo code generation failed, falling back to templates: %v\n", err)
			code = s.generateTemplateCode(task, s.detectFramework(contextData))
		}
	} else {
		// Use template-based generation
		code = s.generateTemplateCode(task, s.detectFramework(contextData))
	}

	// Format the generated code
	formattedCode, err := s.FormatCode(code)
	if err != nil {
		// If formatting fails, use unformatted code
		formattedCode = code
	}

	// Create a single code change for demonstration
	change := agents.CodeChange{
		FilePath:  s.getOutputFilePath(task, contextData),
		After:     formattedCode,
		Operation: "create",
		Language:  "python",
		Lines:     len(strings.Split(formattedCode, "\n")),
	}

	return []agents.CodeChange{change}, nil
}

// generateWithOraculo generates code using MAXIMUS Oraculo API
func (s *PythonCodeGenStrategy) generateWithOraculo(ctx context.Context, task string, contextData map[string]interface{}) (string, error) {
	// Build enriched context with Python-specific information
	enrichedContext := make(map[string]interface{})
	for k, v := range contextData {
		enrichedContext[k] = v
	}

	// Add framework detection
	enrichedContext["framework"] = s.detectFramework(contextData)

	// Add language-specific requirements
	enrichedContext["requirements"] = map[string]interface{}{
		"style":        "pep8",
		"type_hints":   true,
		"docstrings":   "comprehensive",
		"error_handling": "try_except",
	}

	// Call Oraculo API
	req := oraculo.ImplementationRequest{
		TaskDescription: task,
		Context:         enrichedContext,
		TargetLanguage:  "python",
	}

	resp, err := s.oraculoClient.AutoImplement(ctx, req)
	if err != nil {
		return "", fmt.Errorf("oraculo API call failed: %w", err)
	}

	if resp.Result.Details.Status != "success" {
		return "", fmt.Errorf("oraculo implementation failed: %s", resp.Result.Details.Message)
	}

	return resp.Result.GeneratedCode, nil
}

// generateTemplateCode generates template Python code
func (s *PythonCodeGenStrategy) generateTemplateCode(task string, framework string) string {
	// Basic Python template
	template := fmt.Sprintf(`"""
%s

Auto-generated by Agent Smith DEV SENIOR
Framework: %s
"""

def main():
    """Main function for %s"""
    # TODO: Implement %s
    pass


if __name__ == "__main__":
    main()
`, task, framework, task, task)

	return template
}

// getOutputFilePath determines output file path
func (s *PythonCodeGenStrategy) getOutputFilePath(task string, contextData map[string]interface{}) string {
	// Simple file naming based on task
	filename := strings.ReplaceAll(strings.ToLower(task), " ", "_")
	filename = strings.ReplaceAll(filename, "-", "_")
	if !strings.HasSuffix(filename, ".py") {
		filename += ".py"
	}
	return filename
}

// FormatCode formats Python code using black or autopep8
// Uses tool availability checking for graceful degradation
func (s *PythonCodeGenStrategy) FormatCode(code string) (string, error) {
	// Check tool availability before attempting to use them
	blackAvailable := tools.DefaultRegistry.IsAvailable("black")
	autopep8Available := tools.DefaultRegistry.IsAvailable("autopep8")

	// Try black first (preferred)
	if blackAvailable {
		cmd := exec.Command("black", "--quiet", "--code", code)
		output, err := cmd.CombinedOutput()
		if err == nil && len(output) > 0 {
			return string(output), nil
		}
		// If black is available but failed, log and try autopep8
		fmt.Fprintf(os.Stderr, "⚠️  black formatting failed: %v\n", err)
	}

	// Fallback to autopep8
	if autopep8Available {
		cmd := exec.Command("autopep8", "--aggressive", "--aggressive", "-")
		cmd.Stdin = strings.NewReader(code)
		output, err := cmd.CombinedOutput()
		if err == nil {
			return string(output), nil
		}
		// If autopep8 is available but failed, log it
		fmt.Fprintf(os.Stderr, "⚠️  autopep8 formatting failed: %v\n", err)
	}

	// Graceful degradation: return original code with informative message
	if !blackAvailable && !autopep8Available {
		fmt.Fprintf(os.Stderr, "ℹ️  No Python formatters available (black/autopep8), using unformatted code\n")
		fmt.Fprintf(os.Stderr, "   Install formatters:\n")
		fmt.Fprintf(os.Stderr, "     pip3 install black autopep8\n")
	}

	return code, fmt.Errorf("formatting unavailable or failed, using original code")
}

// ValidateSyntax validates Python syntax
func (s *PythonCodeGenStrategy) ValidateSyntax(code string) error {
	// Use Python's compile to check syntax
	cmd := exec.Command("python3", "-m", "py_compile", "-")
	cmd.Stdin = strings.NewReader(code)
	output, err := cmd.CombinedOutput()

	if err != nil {
		return fmt.Errorf("syntax validation failed: %s", string(output))
	}

	return nil
}

// buildPrompt builds a detailed prompt for Oraculo
func (s *PythonCodeGenStrategy) buildPrompt(task string, contextData map[string]interface{}) string {
	prompt := fmt.Sprintf("Generate Python code for: %s\n\n", task)

	// Add context if available
	if architecture, ok := contextData["architecture_plan"]; ok {
		prompt += fmt.Sprintf("Architecture: %v\n\n", architecture)
	}

	if existingCode, ok := contextData["existing_code"]; ok {
		prompt += fmt.Sprintf("Existing code to modify:\n%v\n\n", existingCode)
	}

	if dependencies, ok := contextData["dependencies"]; ok {
		prompt += fmt.Sprintf("Available dependencies: %v\n\n", dependencies)
	}

	// Add Python best practices
	prompt += `
Requirements:
- Follow PEP 8 style guide
- Include type hints (Python 3.9+)
- Add comprehensive docstrings
- Handle errors properly
- Write testable code
- Use context managers where appropriate
`

	return prompt
}

// detectFramework detects Python framework from context
func (s *PythonCodeGenStrategy) detectFramework(contextData map[string]interface{}) string {
	if framework, ok := contextData["framework"].(string); ok {
		return framework
	}

	// Try to detect from dependencies
	if deps, ok := contextData["dependencies"].([]string); ok {
		for _, dep := range deps {
			if strings.Contains(dep, "fastapi") {
				return "fastapi"
			}
			if strings.Contains(dep, "flask") {
				return "flask"
			}
			if strings.Contains(dep, "django") {
				return "django"
			}
		}
	}

	return "standard"
}

// determineOperation determines if this is create, modify, or delete
func (s *PythonCodeGenStrategy) determineOperation(filePath string, contextData map[string]interface{}) string {
	if existingFiles, ok := contextData["existing_files"].([]string); ok {
		for _, existing := range existingFiles {
			if existing == filePath {
				return "modify"
			}
		}
	}
	return "create"
}
