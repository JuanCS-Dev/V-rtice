
# üìÑ `vertice/connectors/malware.py`

## üìã Descri√ß√£o

Este m√≥dulo define o `MalwareConnector`, a classe de comunica√ß√£o com o microservi√ßo de **An√°lise de Malware**. Ele herda da `BaseConnector` e fornece os m√©todos para submeter arquivos para an√°lise.

Este conector sofre de uma implementa√ß√£o incompleta e insegura, pois envia apenas o caminho de um arquivo para o backend, em vez de seu conte√∫do.

## üèóÔ∏è Classes

### `MalwareConnector(BaseConnector)`

Implementa√ß√£o concreta da `BaseConnector` para o servi√ßo de An√°lise de Malware.

**M√©todos P√∫blicos:**

#### `__init__(self)`
Inicializa o conector. A URL do servi√ßo √© hardcoded para `http://localhost:8011`.

#### `health_check(self) -> bool`
Verifica a sa√∫de do servi√ßo de An√°lise de Malware. Espera que o endpoint `/` retorne um JSON com `{"status": "operational"}`.
- **Retorna:** `True` se o servi√ßo estiver saud√°vel, `False` caso contr√°rio.

#### `scan_file(self, file_path: str) -> Dict[str, Any]`
Envia um arquivo para ser analisado pelo servi√ßo.

**IMPORTANTE:** A implementa√ß√£o atual √© um **placeholder inseguro**. Ela envia apenas o `file_path` (o caminho do arquivo como uma string) para o backend, e n√£o o conte√∫do do arquivo. Isso n√£o funcionaria em um ambiente real e representa um risco de seguran√ßa (Path Traversal no backend).

- **Par√¢metros:**
  - `file_path (str)`: O caminho do arquivo a ser analisado.
- **Retorna:** Um dicion√°rio contendo os resultados da an√°lise.

## üí° Exemplo de Uso

```python
import asyncio
from .malware import MalwareConnector

async def main():
    connector = MalwareConnector()

    if await connector.health_check():
        # Submete um arquivo para an√°lise (implementa√ß√£o atual √© um mock)
        result = await connector.scan_file("/path/to/my/file.exe")
        print(result)

    await connector.close()

if __name__ == "__main__":
    asyncio.run(main())
```

## üß™ Guia de Testes

- Mockar o m√©todo `_post` e verificar se `scan_file` o chama com o JSON contendo `{"file_path": ...}`.
- Testar o `health_check` para respostas de sucesso e erro.

**Para a implementa√ß√£o real:**
- O teste para `scan_file` deve ser reescrito. Ele precisaria verificar se o m√©todo abre o arquivo, l√™ seu conte√∫do e envia os dados bin√°rios em uma requisi√ß√£o `multipart/form-data`, que √© o padr√£o para uploads de arquivos.

## ‚ùó Pontos de Aten√ß√£o e Melhoria

- **Funcionalidade Incompleta (Cr√≠tica):** O m√©todo `scan_file` n√£o implementa a l√≥gica correta de upload de arquivo. Ele √© um placeholder que n√£o funcionaria e representa um d√©bito t√©cnico cr√≠tico.
- **Vulnerabilidade de Path Traversal (Potencial/Alta):** Ao enviar o caminho do arquivo para o backend, a aplica√ß√£o cria um risco de Path Traversal no servidor se a entrada n√£o for tratada com extremo cuidado l√°.
- **Comunica√ß√£o Insegura (Alta):** A URL usa `http`, enviando dados em texto plano.
- **URL Hardcoded (M√©dia):** A URL do servi√ßo est√° fixa no c√≥digo, dificultando a configura√ß√£o.
- **Duplica√ß√£o de C√≥digo:** O `health_check` √© um copy-paste de outros conectores.
- **N√∫mero M√°gico:** A porta `8011` est√° hardcoded.
