"""
End-to-End Tests: Full Pentest Workflow
========================================

Test complete penetration testing workflows from start to finish.
"""

import pytest
from pathlib import Path
import tempfile
from datetime import datetime

from vertice.workspace import WorkspaceManager
from vertice.ai import MaximusAssistant
from vertice.analytics import RiskScorer, RiskFactor
from vertice.siem_integration import CEFFormatter


class TestPentestWorkflowE2E:
    """End-to-end penetration testing workflow tests."""

    @pytest.fixture
    def workspace_dir(self):
        """Create temporary workspace directory."""
        with tempfile.TemporaryDirectory() as tmpdir:
            yield Path(tmpdir)

    @pytest.fixture
    def workspace(self, workspace_dir):
        """Create workspace manager instance."""
        return WorkspaceManager(workspace_root=workspace_dir)

    @pytest.fixture
    def assistant(self, workspace):
        """Create Maximus assistant with workspace integration."""
        return MaximusAssistant(workspace_manager=workspace)

    @pytest.fixture
    def scorer(self):
        """Create risk scorer instance."""
        return RiskScorer(use_backend=False)

    @pytest.fixture
    def siem_formatter(self):
        """Create SIEM formatter."""
        return CEFFormatter()

    def test_complete_pentest_workflow(
        self, workspace, assistant, scorer, siem_formatter
    ):
        """Test complete pentest workflow: scan → analyze → prioritize → report → SIEM."""

        # ==========================================
        # PHASE 1: PROJECT CREATION
        # ==========================================
        project = workspace.create_project(
            name="e2e-pentest-demo",
            description="End-to-end workflow test",
            scope="10.10.1.0/24",
        )

        workspace.switch_project("e2e-pentest-demo")

        assert workspace.get_active_project().name == "e2e-pentest-demo"

        # ==========================================
        # PHASE 2: RECONNAISSANCE & SCANNING
        # ==========================================

        # Simulate Nmap scan results
        scan_results = [
            {
                "ip": "10.10.1.10",
                "hostname": "web-server.test.com",
                "os": "Linux",
                "ports": [
                    {"port": 22, "service": "ssh", "version": "OpenSSH 7.4"},
                    {"port": 80, "service": "http", "version": "Apache 2.4.41"},
                    {"port": 443, "service": "https", "version": "Apache 2.4.41"},
                ],
            },
            {
                "ip": "10.10.1.20",
                "hostname": "db-server.test.com",
                "os": "Linux",
                "ports": [
                    {"port": 22, "service": "ssh", "version": "OpenSSH 8.0"},
                    {"port": 3306, "service": "mysql", "version": "MySQL 5.7.30"},
                ],
            },
            {
                "ip": "10.10.1.30",
                "hostname": "app-server.test.com",
                "os": "Linux",
                "ports": [
                    {"port": 22, "service": "ssh", "version": "OpenSSH 7.4"},
                    {"port": 8080, "service": "http", "version": "Tomcat 9.0"},
                ],
            },
        ]

        # Store scan results in workspace
        for result in scan_results:
            host = workspace.add_host(
                ip_address=result["ip"],
                hostname=result["hostname"],
                os_family=result["os"],
            )

            for port_data in result["ports"]:
                workspace.add_port(
                    host_id=host.id,
                    port=port_data["port"],
                    protocol="tcp",
                    state="open",
                    service=port_data["service"],
                    version=port_data["version"],
                )

        # Verify reconnaissance data
        hosts = workspace.query_hosts()
        assert len(hosts) == 3

        # ==========================================
        # PHASE 3: VULNERABILITY ASSESSMENT
        # ==========================================

        # Simulate Nuclei vulnerability findings
        vulns_data = [
            {
                "ip": "10.10.1.10",
                "cve": "CVE-2021-44228",
                "title": "Apache Log4j RCE",
                "severity": "critical",
                "cvss": 10.0,
            },
            {
                "ip": "10.10.1.10",
                "cve": "CVE-2021-41773",
                "title": "Apache Path Traversal",
                "severity": "high",
                "cvss": 7.5,
            },
            {
                "ip": "10.10.1.20",
                "cve": "CVE-2021-3156",
                "title": "Sudo Privilege Escalation",
                "severity": "high",
                "cvss": 7.8,
            },
            {
                "ip": "10.10.1.30",
                "cve": "CVE-2020-9484",
                "title": "Tomcat RCE",
                "severity": "high",
                "cvss": 7.0,
            },
        ]

        # Store vulnerabilities
        for vuln_data in vulns_data:
            # Find host by IP
            host = next(h for h in hosts if h.ip_address == vuln_data["ip"])

            workspace.add_vulnerability(
                host_id=host.id,
                cve_id=vuln_data["cve"],
                title=vuln_data["title"],
                severity=vuln_data["severity"],
                cvss_score=vuln_data["cvss"],
            )

        # Verify vulnerabilities stored
        all_vulns = workspace.query_vulnerabilities()
        assert len(all_vulns) == 4

        # ==========================================
        # PHASE 4: RISK ANALYSIS & PRIORITIZATION
        # ==========================================

        # Calculate risk scores for each host
        host_risks = []

        for host in hosts:
            vulns = workspace.get_vulnerabilities(host_id=host.id)

            # Convert vulns to risk factors
            risk_factors = [
                RiskFactor(
                    name=f"Vuln: {v.cve_id}",
                    category="vulnerability",
                    score_impact=(v.cvss_score / 10.0) * 100,
                    weight=1.0,
                    description=v.title,
                    evidence={"cve": v.cve_id, "severity": v.severity},
                )
                for v in vulns
            ]

            if risk_factors:
                risk_score = scorer.calculate_risk_score(
                    entity_id=f"host_{host.id}",
                    entity_type="endpoint",
                    risk_factors=risk_factors,
                )

                host_risks.append((host, risk_score))

        # Sort by risk (highest first)
        host_risks.sort(key=lambda x: x[1].total_score, reverse=True)

        # Verify prioritization (web-server has Log4Shell = highest risk)
        assert host_risks[0][0].hostname == "web-server.test.com"
        assert host_risks[0][1].total_score > host_risks[1][1].total_score

        # ==========================================
        # PHASE 5: NATURAL LANGUAGE QUERY
        # ==========================================

        # Query workspace using Maximus Assistant
        query_result = assistant.query_nl("show all web servers")

        assert query_result["parsed_query"]["type"] == "filter"
        assert query_result["parsed_query"]["service"] in [["http", "https"], "http", "https"]

        # ==========================================
        # PHASE 6: CVE CORRELATION
        # ==========================================

        # Auto-correlate Apache version with CVEs
        apache_cves = assistant.correlate_vulns("Apache", "2.4.41")

        assert len(apache_cves) > 0
        assert any("Log4j" in cve.get("description", "") or "2021-44228" in cve.get("cve_id", "") for cve in apache_cves)

        # ==========================================
        # PHASE 7: AI SUGGESTIONS
        # ==========================================

        # Get Maximus suggestions based on workspace state
        suggestions = assistant.suggest_next_steps(
            context={
                "total_hosts": len(hosts),
                "scanned_hosts": len(hosts),
                "total_vulns": len(all_vulns),
                "critical_vulns": len([v for v in all_vulns if v.severity == "critical"]),
            }
        )

        # Should suggest deeper scanning for critical vulns
        assert len(suggestions) > 0

        # ==========================================
        # PHASE 8: REPORT GENERATION
        # ==========================================

        # Generate report from workspace
        report = assistant.generate_report(format="markdown")

        assert "# Penetration Test Report" in report
        assert "CVE-2021-44228" in report  # Critical finding should be in report

        # ==========================================
        # PHASE 9: SIEM FORWARDING
        # ==========================================

        # Forward critical findings to SIEM
        critical_vulns = [v for v in all_vulns if v.severity == "critical"]

        siem_events = []
        for vuln in critical_vulns:
            host = next(h for h in hosts if h.id == vuln.host_id)

            event = {
                "name": vuln.title,
                "severity": vuln.severity,
                "src": host.ip_address,
                "shost": host.hostname,
                "message": f"Critical vulnerability {vuln.cve_id} detected",
                "cve": vuln.cve_id,
                "cvss": vuln.cvss_score,
            }

            cef_event = siem_formatter.format(event)
            siem_events.append(cef_event)

        # Verify SIEM events
        assert len(siem_events) == 1  # Only 1 critical vuln
        assert all("CEF:" in event for event in siem_events)
        assert "CVE-2021-44228" in siem_events[0]

        # ==========================================
        # PHASE 10: WORKSPACE STATISTICS
        # ==========================================

        stats = workspace.get_statistics()

        assert stats["total_hosts"] == 3
        assert stats["total_vulnerabilities"] == 4
        assert stats["critical_vulns"] == 1
        assert stats["high_vulns"] == 3

        # ==========================================
        # WORKFLOW COMPLETE ✅
        # ==========================================

    def test_minimal_pentest_workflow(self, workspace):
        """Test minimal workflow: scan → store → query."""

        # Create project
        project = workspace.create_project("minimal-test")
        workspace.switch_project("minimal-test")

        # Add single host
        host = workspace.add_host(ip_address="192.168.1.100")

        # Add port
        workspace.add_port(
            host_id=host.id,
            port=80,
            protocol="tcp",
            state="open",
            service="http",
        )

        # Add vulnerability
        workspace.add_vulnerability(
            host_id=host.id,
            cve_id="CVE-2021-1234",
            severity="high",
        )

        # Query results
        hosts = workspace.query_hosts()
        vulns = workspace.query_vulnerabilities()

        # Verify workflow
        assert len(hosts) == 1
        assert len(vulns) == 1
        assert hosts[0].ip_address == "192.168.1.100"
        assert vulns[0].cve_id == "CVE-2021-1234"
